
{{DEVELOPMENT}} --------(((DEBUGINFO)))--------{{DEVELOPMENT}} 

 DRIVER SYMBOLS (alphabet order)
-------------------------------
ARM_CORTEX_M0P=
Abstract=Common\MQXLiteAbstract.inc
CPU_ARCH=ARM_CORTEX_M0P
CPU_SUBFAMILY=KL2
DefaultMemInterruptsLocation=INTERNAL_FLASH
Description_SystemTimer1_OnCounterRestart=Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
DriverAuthor=Marek Vinkler
DriverDate=19.02.2012
DriverVersion=01.00
EndOfInterface=
InpStringCopy=\
MQX_LITE_VERSION_NUMBER=0x01000000
MqxSourcePath=D:/FreeScale/CW MCU v10.3_B121029/MCU/ProcessorExpert/lib/mqxlite/V1.0.0/
Settings=Common\MQXLiteSettings.inc
TaskLowestPriority=9
loc_tmpChar=\
mqx_RelLibPath=psp\cortex_m\compiler\gccarm\comp.h
mqx_compiler=gccarm
mqx_core=M0
mqx_srcLibDir=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\lib\mqxlite\V1.0.0\source\
mqx_srcPath=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\lib\mqxlite\V1.0.0\source\psp\cortex_m\compiler\gccarm\**\*
mqx_srcRelPath=psp\cortex_m\core\M0\**\*
new_dispatcher_m0=yes
numFiles=3
taskAttributes=MQX_AUTO_START_TASK
tmpFirstUserIntIdx=15
tmp_OutString=D:/FreeScale/CW MCU v10.3_B121029/MCU/ProcessorExpert/lib/mqxlite/V1.0.0/
tmp_TaskCreationParameter=0
tmp_TaskEntryFunction=Task1_task
tmp_TaskName=Task1
tmp_TaskPriority=9
tmp_TaskStackSize=1024
RTOSAdap_enum_componentTypes=[HAL_UART_Polling|HAL_UART_Int|HAL_I2C_Polling|HAL_I2C_Int|HAL_GPIO|HAL_ADC|HAL_RTC|HAL_Ethernet|HAL_TimerUnit|AsyncSerial_LDD|USB_LDD]
RTOSAdap_enum_defaultParameterNames=[componentType|simpleComponentType|componentInstanceName|genReentrantMethods|genCriticalSectionMethods|constantDeclarationsThread|allocatedDevice|allocatedDeviceBaseAddr|SPIN_LOCK]
RTOSAdap_enum_simpleComponentTypes=[HAL_UART|HAL_I2C|HAL_GPIO|HAL_ADC|HAL_RTC|HAL_Ethernet|HAL_TimerUnit|AsyncSerial_LDD|USB_LDD]
VersionNums=[1|0|0]

 LOCAL SYMBOLS (alphabet order)
-------------------------------
BeanVersion=01.083
CHG_BeanIsEnabled=yes
CopyFilesToProject=yes
DeviceName=MQX1
DeviceType=MQXLite
MQXUserDefinitionsLines=1
MQX_ENABLE_LOW_POWER=0
MQX_INTERRUPT_STACK_SIZE=1024
MQX_KERNEL_LOGGING=0
MQX_USE_IDLE_TASK=1
MQX_USE_LWEVENTS=0
MQX_USE_LWMSGQ=0
MQX_USE_LWTIMER=0
MQX_USE_MUTEXES=0
MQX_USE_SEMAPHORES=1
ManageAllocatedInterrupts=no
ModuleName=MQX1
SystemTimer=SystemTimer1
Task0=Task1
TaskGrp0=Enabled
TaskTemplateListMaxItem=0
TaskTemplateListNumItems=1
Version=V1.0.0
_int_default_isr=_int_default_isr
_int_default_isr_Hint=void MQX1__int_default_isr(void* vector_number);
_int_default_isr_HintHint=Default ISR that MQX calls if an unhandled interrupt or exception occurs.
_int_default_isr_HintHintLong=Default ISR that MQX calls if an unhandled interrupt or exception occurs.
_int_disable=_int_disable
_int_disable_Hint=void MQX1__int_disable(void);
_int_disable_HintHint=The function _int_disable() disables all hardware interrupts at priorities up...
_int_disable_HintHintLong=The function _int_disable() disables all hardware interrupts at priorities up to and including the MQX disable-interrupt level. As a result, no task can interrupt the active task while the active task is running until interrupts are re-enabled with _int_enable(). If the active task blocks while interrupts are disabled, the state of the interrupts (disabled or enabled) depends on the interrupt-disabled state of the next task that MQX makes ready.
_int_enable=_int_enable
_int_enable_Hint=void MQX1__int_enable(void);
_int_enable_HintHint=The function _int_enable() resets the processor priority to the hardware...
_int_enable_HintHintLong=The function _int_enable() resets the processor priority to the hardware priority that corresponds to the active task’s software priority.
_int_exception_isr=_int_exception_isr
_int_exception_isr_Hint=void MQX1__int_exception_isr(void* parameter);
_int_exception_isr_HintHint=To provide support for exception handlers, applications can use this ISR to...
_int_exception_isr_HintHintLong=To provide support for exception handlers, applications can use this ISR to replace the default ISR. The ISR is specific to the PSP.   An application calls _int_install_exception_isr() to install _int_exception_isr().   The function _int_exception_isr() does the following:   If an exception occurs when a task is running and a task exception ISR exists, MQX runs the ISR;   If a task exception ISR does not exist, MQX aborts the task by calling _task_abort().   If an exception occurs when an ISR is running and an ISR exception ISR exists, MQX aborts the   running ISR and runs the ISR’s exception ISR.   The function walks the interrupt stack looking for information about the ISR or task that was   running before the exception occurred. If the function determines that the interrupt stack contains   incorrect information, it calls _mqx_fatal_error() with error code MQX_CORRUPT_INTERRUPT_STACK.
_int_get_default_isr=_int_get_default_isr
_int_get_default_isr_Hint=INT_ISR_FPTR MQX1__int_get_default_isr(void);
_int_get_default_isr_HintHint=Gets a pointer to the default ISR that MQX calls when an unexpected interrupt...
_int_get_default_isr_HintHintLong=Gets a pointer to the default ISR that MQX calls when an unexpected interrupt occurs.
_int_get_exception_handler=_int_get_exception_handler
_int_get_exception_handler_Hint=INT_EXCEPTION_FPTR MQX1__int_get_exception_handler(_mqx_uint vector_number);
_int_get_exception_handler_HintHint=Gets a pointer to the current ISR exception handler for the vector number.
_int_get_exception_handler_HintHintLong=Gets a pointer to the current ISR exception handler for the vector number.
_int_get_isr=_int_get_isr
_int_get_isr_Hint=INT_ISR_FPTR MQX1__int_get_isr(void* vector_number);
_int_get_isr_HintHint=Gets the current ISR for the vector number.
_int_get_isr_HintHintLong=Gets the current ISR for the vector number.
_int_get_isr_data=_int_get_isr_data
_int_get_isr_data_Hint=void* MQX1__int_get_isr_data(void* vector_number);
_int_get_isr_data_HintHint=Gets the data that is associated with the vector number.
_int_get_isr_data_HintHintLong=Gets the data that is associated with the vector number.
_int_get_isr_depth=_int_get_isr_depth
_int_get_isr_depth_Hint=_mqx_uint MQX1__int_get_isr_depth(void);
_int_get_isr_depth_HintHint=Gets the depth of nesting of the current interrupt stack.
_int_get_isr_depth_HintHintLong=Gets the depth of nesting of the current interrupt stack.
_int_get_kernel_isr=_int_get_kernel_isr
_int_get_kernel_isr_Hint=INT_KERNEL_ISR_FPTR MQX1__int_get_kernel_isr(void* vector_number);
_int_get_kernel_isr_HintHint=Gets a pointer to the kernel ISR for the vector number. The kernel ISR...
_int_get_kernel_isr_HintHintLong=Gets a pointer to the kernel ISR for the vector number. The kernel ISR depends on the PSP.
_int_get_previous_vector_table=_int_get_previous_vector_table
_int_get_previous_vector_table_Hint=_mqx_max_type MQX1__int_get_previous_vector_table(void);
_int_get_previous_vector_table_HintHint=Gets the address of the interrupt vector table that MQX might have created...
_int_get_previous_vector_table_HintHintLong=Gets the address of the interrupt vector table that MQX might have created when it started.
_int_get_vector_table=_int_get_vector_table
_int_get_vector_table_Hint=_mqx_max_type MQX1__int_get_vector_table(void);
_int_get_vector_table_HintHint=Gets the address of the current interrupt vector table. The function depends...
_int_get_vector_table_HintHintLong=Gets the address of the current interrupt vector table. The function depends on the PSP.
_int_install_default_isr=_int_install_default_isr
_int_install_default_isr_Hint=INT_ISR_FPTR MQX1__int_install_default_isr(void* default_isr);
_int_install_default_isr_HintHint=Installs an application-provided default ISR.
_int_install_default_isr_HintHintLong=Installs an application-provided default ISR.
_int_install_exception_isr=_int_install_exception_isr
_int_install_exception_isr_Hint=INT_ISR_FPTR MQX1__int_install_exception_isr(void);
_int_install_exception_isr_HintHint=Installs the MQX-provided _int_exception_isr() as the default ISR for...
_int_install_exception_isr_HintHintLong=Installs the MQX-provided _int_exception_isr() as the default ISR for unhandled interrupts and exceptions.
_int_install_isr=_int_install_isr
_int_install_isr_Hint=INT_ISR_FPTR MQX1__int_install_isr(void* vector, void* isr_ptr, void* isr_data);
_int_install_isr_HintHint=Installs the ISR. The application defines the ISR data, which can be a...
_int_install_isr_HintHintLong=Installs the ISR. The application defines the ISR data, which can be a constant or a pointer to a memory block from _mem_alloc().
_int_install_kernel_isr=_int_install_kernel_isr
_int_install_kernel_isr_Hint=INT_KERNEL_ISR_FPTR MQX1__int_install_kernel_isr(void* vector, void* isr_ptr);
_int_install_kernel_isr_HintHint=Installs the kernel ISR. The kernel ISR depends on the PSP.   Some real-time...
_int_install_kernel_isr_HintHintLong=Installs the kernel ISR. The kernel ISR depends on the PSP.   Some real-time applications need special event handling to occur outside the scope of MQX. The need   might arise that the latency in servicing an interrupt be less than the MQX interrupt latency. If this is the   case, an application can use _int_install_kernel_isr() to bypass MQX and let the interrupt be serviced   immediately.   Because the function returns the previous kernel ISR, applications can temporarily install an ISR or chain   ISRs so that each new one calls the one installed before it.   A kernel ISR must save the registers that it needs and must service the hardware interrupt. When the kernel   ISR is finished, it must restore the registers and perform a return-from-interrupt instruction.   A kernel ISR cannot call MQX functions. However, it can put data in global data, which a task can access.
_int_install_unexpected_isr=_int_install_unexpected_isr
_int_install_unexpected_isr_Hint=INT_ISR_FPTR MQX1__int_install_unexpected_isr(void);
_int_install_unexpected_isr_HintHint=Installs the MQX-provided unexpected ISR, _int_unexpected_isr(), for all...
_int_install_unexpected_isr_HintHintLong=Installs the MQX-provided unexpected ISR, _int_unexpected_isr(), for all interrupts that do not have an application-installed ISR.
_int_kernel_isr=_int_kernel_isr
_int_kernel_isr_Hint=void MQX1__int_kernel_isr(void);
_int_kernel_isr_HintHint=Default kernel ISR that MQX calls to intercept all interrupts.
_int_kernel_isr_HintHintLong=Default kernel ISR that MQX calls to intercept all interrupts.
_int_set_exception_handler=_int_set_exception_handler
_int_set_exception_handler_Hint=INT_EXCEPTION_FPTR MQX1__int_set_exception_handler(void* vector, void*...
_int_set_exception_handler_HintHint=The function sets the exception handler for an ISR. When an exception...
_int_set_exception_handler_HintHintLong=The function sets the exception handler for an ISR. When an exception (unhandled interrupt) occurs while   the ISR is running, MQX calls the exception handler and terminates the ISR.   An application should install _int_exception_isr() as the MQX default ISR.   The returned exception handler is either the default handler or one that the application previously installed   with _int_set_exception_handler().
_int_set_isr_data=_int_set_isr_data
_int_set_isr_data_Hint=void* MQX1__int_set_isr_data(void* vector, void* data);
_int_set_isr_data_HintHint=Sets the data associated with the interrupt.
_int_set_isr_data_HintHintLong=Sets the data associated with the interrupt.
_int_set_vector_table=_int_set_vector_table
_int_set_vector_table_Hint=_mqx_max_type MQX1__int_set_vector_table(void* new);
_int_set_vector_table_HintHint=Changes the location of the interrupt vector table.
_int_set_vector_table_HintHintLong=Changes the location of the interrupt vector table.
_int_unexpected_isr=_int_unexpected_isr
_int_unexpected_isr_Hint=void MQX1__int_unexpected_isr(void* parameter);
_int_unexpected_isr_HintHint=An MQX-provided default ISR for unhandled interrupts. The function depends on...
_int_unexpected_isr_HintHintLong=An MQX-provided default ISR for unhandled interrupts. The function depends on the PSP.
_klog_control=_klog_control
_klog_control_Hint=void MQX1__klog_control(void* bit_mask, bool set_bits);
_klog_control_HintHint=Controls logging in kernel log.   The application must first create kernel...
_klog_control_HintHintLong=Controls logging in kernel log.   The application must first create kernel log with _klog_create().   The function _klog_control() sets or clears bits in the kernel log control variable, which MQX uses to   control logging. To select which functions to log, set combinations of bits in the   KLOG_FUNCTIONS_ENABLED flag for the bit_mask parameter.   MQX logs to kernel log only if KLOG_ENABLED is set in bit_mask.
_klog_create_at=_klog_create_at
_klog_create_at_Hint=_mqx_uint MQX1__klog_create_at(void* max_size, void* flags, void* where);
_klog_create_at_HintHint=
_klog_create_at_HintHintLong=
_klog_disable_logging_task=_klog_disable_logging_task
_klog_disable_logging_task_Hint=void MQX1__klog_disable_logging_task(void* task_id);
_klog_disable_logging_task_HintHint=Disables kernel logging for the task.   If the application calls...
_klog_disable_logging_task_HintHintLong=Disables kernel logging for the task.   If the application calls _klog_control() with KLOG_TASK_QUALIFIED, it must call   _klog_enable_logging_task() for each task for which it wants to log information.   The application disables logging by calling _klog_disable_logging_task() for each task for which it wants   to stop logging. If the application did not first enable logging for the task, MQX ignores the request.
_klog_display=_klog_display
_klog_display_Hint=bool MQX1__klog_display(void);
_klog_display_HintHint=Displays the oldest entry in kernel log and delete the entry.   The function...
_klog_display_HintHintLong=Displays the oldest entry in kernel log and delete the entry.   The function prints the oldest entry in kernel log to the default output stream of the current task and deletes the entry.
_klog_enable_logging_task=_klog_enable_logging_task
_klog_enable_logging_task_Hint=void MQX1__klog_enable_logging_task(void* task_id);
_klog_enable_logging_task_HintHint=Enables kernel logging for the task.   If the application calls...
_klog_enable_logging_task_HintHintLong=Enables kernel logging for the task.   If the application calls _klog_control() with KLOG_TASK_QUALIFIED, it must call   _klog_enable_logging_task() for each task for which it wants to log information.   The application disables logging by calling _klog_disable_logging_task() for each task for which it wants   to stop logging. If the application did not first enable logging for the task, MQX ignores the request.
_klog_get_interrupt_stack_usage=_klog_get_interrupt_stack_usage
_klog_get_interrupt_stack_usage_Hint=_mqx_uint MQX1__klog_get_interrupt_stack_usage(void* stack_size_ptr, void*...
_klog_get_interrupt_stack_usage_HintHint=Gets the size of the interrupt stack and the total amount of it used.
_klog_get_interrupt_stack_usage_HintHintLong=Gets the size of the interrupt stack and the total amount of it used.
_klog_get_task_stack_usage=_klog_get_task_stack_usage
_klog_get_task_stack_usage_Hint=_mqx_uint MQX1__klog_get_task_stack_usage(void* stack_size_ptr, void*...
_klog_get_task_stack_usage_HintHint=Gets the size of the interrupt stack and the total amount of it used.   The...
_klog_get_task_stack_usage_HintHintLong=Gets the size of the interrupt stack and the total amount of it used.   The amount used is a highwater mark—the highest amount of interrupt stack that the application has used   so far. It shows only how much of the stack has been written to at this point. If the amount is 0, the interrupt   stack is not large enough.
_klog_show_stack_usage=_klog_show_stack_usage
_klog_show_stack_usage_Hint=void MQX1__klog_show_stack_usage(void);
_klog_show_stack_usage_HintHint=Displays the amount of interrupt stack used and the amount of stack used by...
_klog_show_stack_usage_HintHintLong=Displays the amount of interrupt stack used and the amount of stack used by each task.   The function displays the information on the standard output stream for the calling task.
_lwevent_clear=_lwevent_clear
_lwevent_clear_Hint=_mqx_uint MQX1__lwevent_clear(void* event_group_ptr, void* bit_mask);
_lwevent_clear_HintHint=Clears the specified event bits in the lightweight event group.
_lwevent_clear_HintHintLong=Clears the specified event bits in the lightweight event group.
_lwevent_create=_lwevent_create
_lwevent_create_Hint=_mqx_uint MQX1__lwevent_create(void* lwevent_group_ptr, void* flags);
_lwevent_create_HintHint=Initializes the lightweight event group.
_lwevent_create_HintHintLong=Initializes the lightweight event group.
_lwevent_destroy=_lwevent_destroy
_lwevent_destroy_Hint=_mqx_uint MQX1__lwevent_destroy(void* lwevent_group_ptr);
_lwevent_destroy_HintHint=Deinitializes the lightweight event group.
_lwevent_destroy_HintHintLong=Deinitializes the lightweight event group.
_lwevent_get_signalled=_lwevent_get_signalled
_lwevent_get_signalled_Hint=_mqx_uint MQX1__lwevent_get_signalled(void);
_lwevent_get_signalled_HintHint=Gets which particular bit(s) in the lwevent unblocked recent wait command.
_lwevent_get_signalled_HintHintLong=Gets which particular bit(s) in the lwevent unblocked recent wait command.
_lwevent_set=_lwevent_set
_lwevent_set_Hint=_mqx_uint MQX1__lwevent_set(void* lwevent_group_ptr, void* flags);
_lwevent_set_HintHint=Sets the specified event bits in the lightweight event group.
_lwevent_set_HintHintLong=Sets the specified event bits in the lightweight event group.
_lwevent_set_auto_clear=_lwevent_set_auto_clear
_lwevent_set_auto_clear_Hint=_mqx_uint MQX1__lwevent_set_auto_clear(void* lwevent_group_ptr, void*...
_lwevent_set_auto_clear_HintHint=Sets autoclearing behavior of event bits in the lightweight event group.
_lwevent_set_auto_clear_HintHintLong=Sets autoclearing behavior of event bits in the lightweight event group.
_lwevent_test=_lwevent_test
_lwevent_test_Hint=_mqx_uint MQX1__lwevent_test(void* lwevent_error_ptr, void* td_error_ptr);
_lwevent_test_HintHint=Tests the lightweight event component.
_lwevent_test_HintHintLong=Tests the lightweight event component.
_lwevent_wait_for=_lwevent_wait_for
_lwevent_wait_for_Hint=_mqx_uint MQX1__lwevent_wait_for(void* event_ptr, void* bit_mask, bool all,...
_lwevent_wait_for_HintHint=Wait for the specified lightweight event bits to be set in the lightweight...
_lwevent_wait_for_HintHintLong=Wait for the specified lightweight event bits to be set in the lightweight event group for the number of ticks (in tick time).
_lwevent_wait_ticks=_lwevent_wait_ticks
_lwevent_wait_ticks_Hint=_mqx_uint MQX1__lwevent_wait_ticks(void* event_ptr, void* bit_mask, bool all,...
_lwevent_wait_ticks_HintHint=Wait for the specified lightweight event bits to be set in the lightweight...
_lwevent_wait_ticks_HintHintLong=Wait for the specified lightweight event bits to be set in the lightweight event group for the number of ticks
_lwevent_wait_until=_lwevent_wait_until
_lwevent_wait_until_Hint=_mqx_uint MQX1__lwevent_wait_until(void* event_ptr, void* bit_mask, bool all,...
_lwevent_wait_until_HintHint=Wait for the specified lightweight event bits to be set in the lightweight...
_lwevent_wait_until_HintHintLong=Wait for the specified lightweight event bits to be set in the lightweight event group until the specified time (in tick time)
_lwlog_calculate_size=_lwlog_calculate_size
_lwlog_calculate_size_Hint=_mem_size MQX1__lwlog_calculate_size(void* entries);
_lwlog_calculate_size_HintHint=Calculates the number of single-addressable units required for the...
_lwlog_calculate_size_HintHintLong=Calculates the number of single-addressable units required for the lightweight log.
_lwlog_create_at=_lwlog_create_at
_lwlog_create_at_Hint=_mqx_uint MQX1__lwlog_create_at(void* log_number, void* max_size, void*...
_lwlog_create_at_HintHint=Creates the lightweight log at the specific location.
_lwlog_create_at_HintHintLong=Creates the lightweight log at the specific location.
_lwlog_create_component=_lwlog_create_component
_lwlog_create_component_Hint=_mqx_uint MQX1__lwlog_create_component(void);
_lwlog_create_component_HintHint=Creates the lightweight log component.
_lwlog_create_component_HintHintLong=Creates the lightweight log component.
_lwlog_destroy=_lwlog_destroy
_lwlog_destroy_Hint=_mqx_uint MQX1__lwlog_destroy(void* log_number);
_lwlog_destroy_HintHint=Destroys the lightweight log.
_lwlog_destroy_HintHintLong=Destroys the lightweight log.
_lwlog_disable=_lwlog_disable
_lwlog_disable_Hint=_mqx_uint MQX1__lwlog_disable(void* log_number);
_lwlog_disable_HintHint=Stops logging to the lightweight log.
_lwlog_disable_HintHintLong=Stops logging to the lightweight log.
_lwlog_enable=_lwlog_enable
_lwlog_enable_Hint=_mqx_uint MQX1__lwlog_enable(void* log_number);
_lwlog_enable_HintHint=
_lwlog_enable_HintHintLong=
_lwlog_read=_lwlog_read
_lwlog_read_Hint=_mqx_uint MQX1__lwlog_read(void* log_number, void* read_type, void* entry_ptr);
_lwlog_read_HintHint=Reads the information in the lightweight log.
_lwlog_read_HintHintLong=Reads the information in the lightweight log.
_lwlog_reset=_lwlog_reset
_lwlog_reset_Hint=_mqx_uint MQX1__lwlog_reset(void* log_number);
_lwlog_reset_HintHint=Resets the lightweight log to its initial state (remove all entries).
_lwlog_reset_HintHintLong=Resets the lightweight log to its initial state (remove all entries).
_lwlog_test=_lwlog_test
_lwlog_test_Hint=_mqx_uint MQX1__lwlog_test(void* log_error_ptr);
_lwlog_test_HintHint=Tests the lightweight log component.
_lwlog_test_HintHintLong=Tests the lightweight log component.
_lwlog_write=_lwlog_write
_lwlog_write_Hint=_mqx_uint MQX1__lwlog_write(void* log_number, void* p1, void* p2, void* p3,...
_lwlog_write_HintHint=Writes to the lightweight log.
_lwlog_write_HintHintLong=Writes to the lightweight log.
_lwmsgq_init=_lwmsgq_init
_lwmsgq_init_Hint=_mqx_uint MQX1__lwmsgq_init(void* location, void* num_message, void* msg_size);
_lwmsgq_init_HintHint=Create a lightweight message queue.
_lwmsgq_init_HintHintLong=Create a lightweight message queue.
_lwmsgq_receive=_lwmsgq_receive
_lwmsgq_receive_Hint=_mqx_uint MQX1__lwmsgq_receive(void* handle, void* message, void* flags,...
_lwmsgq_receive_HintHint=Get a message from a lightweight message queue.
_lwmsgq_receive_HintHintLong=Get a message from a lightweight message queue.
_lwmsgq_send=_lwmsgq_send
_lwmsgq_send_Hint=_mqx_uint MQX1__lwmsgq_send(void* handle, void* message, void* flags);
_lwmsgq_send_HintHint=Put a message on a lightweight message queue.
_lwmsgq_send_HintHintLong=Put a message on a lightweight message queue.
_lwsem_create=_lwsem_create
_lwsem_create_Hint=_mqx_uint MQX1__lwsem_create(void* lwsem_ptr, void* initial_count);
_lwsem_create_HintHint=Creates the lightweight semaphore.
_lwsem_create_HintHintLong=Creates the lightweight semaphore.
_lwsem_destroy=_lwsem_destroy
_lwsem_destroy_Hint=_mqx_uint MQX1__lwsem_destroy(void* lwsem_ptr);
_lwsem_destroy_HintHint=Destroys the lightweight semaphore.
_lwsem_destroy_HintHintLong=Destroys the lightweight semaphore.
_lwsem_poll=_lwsem_poll
_lwsem_poll_Hint=bool MQX1__lwsem_poll(void* lwsem_ptr);
_lwsem_poll_HintHint=Poll for the lightweight semaphore.
_lwsem_poll_HintHintLong=Poll for the lightweight semaphore.
_lwsem_post=_lwsem_post
_lwsem_post_Hint=_mqx_uint MQX1__lwsem_post(void* lwsem_ptr);
_lwsem_post_HintHint=Posts the lightweight semaphore.
_lwsem_post_HintHintLong=Posts the lightweight semaphore.
_lwsem_test=_lwsem_test
_lwsem_test_Hint=_mqx_uint MQX1__lwsem_test(void* lwsem_error_ptr, void* td_error_ptr);
_lwsem_test_HintHint=Tests the data structures (including queues) of the lightweight semaphores...
_lwsem_test_HintHintLong=Tests the data structures (including queues) of the lightweight semaphores component.
_lwsem_wait=_lwsem_wait
_lwsem_wait_Hint=_mqx_uint MQX1__lwsem_wait(void* sem_ptr);
_lwsem_wait_HintHint=Wait (in FIFO order) for the lightweight semaphore until it is available.
_lwsem_wait_HintHintLong=Wait (in FIFO order) for the lightweight semaphore until it is available.
_lwsem_wait_for=_lwsem_wait_for
_lwsem_wait_for_Hint=_mqx_uint MQX1__lwsem_wait_for(void* sem_ptr, void* tick_timeout);
_lwsem_wait_for_HintHint=Wait (in FIFO order) for the lightweight semaphore for the number of ticks
_lwsem_wait_for_HintHintLong=Wait (in FIFO order) for the lightweight semaphore for the number of ticks
_lwsem_wait_ticks=_lwsem_wait_ticks
_lwsem_wait_ticks_Hint=_mqx_uint MQX1__lwsem_wait_ticks(void* sem_ptr, void* tick_time_timeout_ptr);
_lwsem_wait_ticks_HintHint=Wait (in FIFO order) for the lightweight semaphore for the number of ticks...
_lwsem_wait_ticks_HintHintLong=Wait (in FIFO order) for the lightweight semaphore for the number of ticks (in tick time)
_lwsem_wait_until=_lwsem_wait_until
_lwsem_wait_until_Hint=_mqx_uint MQX1__lwsem_wait_until(void* sem_ptr, void* tick_time_ptr);
_lwsem_wait_until_HintHint=Wait (in FIFO order) for the lightweight semaphore until the specified time...
_lwsem_wait_until_HintHintLong=Wait (in FIFO order) for the lightweight semaphore until the specified time (in tick time)
_lwtimer_add_timer_to_queue=_lwtimer_add_timer_to_queue
_lwtimer_add_timer_to_queue_Hint=_mqx_uint MQX1__lwtimer_add_timer_to_queue(void* period_ptr, void* timer_ptr,...
_lwtimer_add_timer_to_queue_HintHint=Adds the lightweight timer to the periodic queue.
_lwtimer_add_timer_to_queue_HintHintLong=Adds the lightweight timer to the periodic queue.
_lwtimer_cancel_period=_lwtimer_cancel_period
_lwtimer_cancel_period_Hint=_mqx_uint MQX1__lwtimer_cancel_period(void* period_ptr);
_lwtimer_cancel_period_HintHint=Cancels all the lightweight timers in the periodic queue.
_lwtimer_cancel_period_HintHintLong=Cancels all the lightweight timers in the periodic queue.
_lwtimer_cancel_timer=_lwtimer_cancel_timer
_lwtimer_cancel_timer_Hint=_mqx_uint MQX1__lwtimer_cancel_timer(void* timer_ptr);
_lwtimer_cancel_timer_HintHint=Cancels the outstanding timer request.
_lwtimer_cancel_timer_HintHintLong=Cancels the outstanding timer request.
_lwtimer_create_periodic_queue=_lwtimer_create_periodic_queue
_lwtimer_create_periodic_queue_Hint=_mqx_uint MQX1__lwtimer_create_periodic_queue(void* timer_ptr, void* period,...
_lwtimer_create_periodic_queue_HintHint=Creates the periodic timer queue.
_lwtimer_create_periodic_queue_HintHintLong=Creates the periodic timer queue.
_lwtimer_test=_lwtimer_test
_lwtimer_test_Hint=_mqx_uint MQX1__lwtimer_test(void* period_error_ptr, void* timer_error_ptr);
_lwtimer_test_HintHint=Tests all the periodic queues and their lightweight timers for validity and...
_lwtimer_test_HintHintLong=Tests all the periodic queues and their lightweight timers for validity and consistency.
_mem_test_and_set=_mem_test_and_set
_mem_test_and_set_Hint=_mqx_uint MQX1__mem_test_and_set(void* location_ptr);
_mem_test_and_set_HintHint=Tests and sets a memory location.   The function can be used to implement...
_mem_test_and_set_HintHintLong=Tests and sets a memory location.   The function can be used to implement mutual exclusion between tasks. If the single-addressable unit was 0, the function sets the high bit. If possible, the function uses a bus-cycle indivisible instruction.
_mem_zero=_mem_zero
_mem_zero_Hint=void MQX1__mem_zero(void* ptr, void* num_units);
_mem_zero_HintHint=Fills the region of memory with 0x0.
_mem_zero_HintHintLong=Fills the region of memory with 0x0.
_mqx_exit=_mqx_exit
_mqx_exit_Hint=void MQX1__mqx_exit(void* error_code);
_mqx_exit_HintHint=Terminate the MQX application and return to the environment that started the...
_mqx_exit_HintHintLong=Terminate the MQX application and return to the environment that started the application.
_mqx_fatal_error=_mqx_fatal_error
_mqx_fatal_error_Hint=void MQX1__mqx_fatal_error(void* error);
_mqx_fatal_error_HintHint=Indicates that an error occurred that is so severe that MQX or the...
_mqx_fatal_error_HintHintLong=Indicates that an error occurred that is so severe that MQX or the application can no longer function.
_mqx_get_counter=_mqx_get_counter
_mqx_get_counter_Hint=_mqx_uint MQX1__mqx_get_counter(void);
_mqx_get_counter_HintHint=Gets a unique number.
_mqx_get_counter_HintHintLong=Gets a unique number.
_mqx_get_cpu_type=_mqx_get_cpu_type
_mqx_get_cpu_type_Hint=_mqx_uint MQX1__mqx_get_cpu_type(void);
_mqx_get_cpu_type_HintHint=Gets the CPU type.
_mqx_get_cpu_type_HintHintLong=Gets the CPU type.
_mqx_get_exit_handler=_mqx_get_exit_handler
_mqx_get_exit_handler_Hint=MQX_EXIT_FPTR MQX1__mqx_get_exit_handler(void);
_mqx_get_exit_handler_HintHint=Gets a pointer to the MQX exit handler, which MQX calls when it exits.
_mqx_get_exit_handler_HintHintLong=Gets a pointer to the MQX exit handler, which MQX calls when it exits.
_mqx_get_initialization=_mqx_get_initialization
_mqx_get_initialization_Hint=MQX_INITIALIZATION_STRUCT_PTR MQX1__mqx_get_initialization(void);
_mqx_get_initialization_HintHint=Gets a pointer to the MQX initialization structure.
_mqx_get_initialization_HintHintLong=Gets a pointer to the MQX initialization structure.
_mqx_get_kernel_data=_mqx_get_kernel_data
_mqx_get_kernel_data_Hint=void* MQX1__mqx_get_kernel_data(void);
_mqx_get_kernel_data_HintHint=Gets a pointer to kernel data.
_mqx_get_kernel_data_HintHintLong=Gets a pointer to kernel data.
_mqx_get_system_task_id=_mqx_get_system_task_id
_mqx_get_system_task_id_Hint=_task_id MQX1__mqx_get_system_task_id(void);
_mqx_get_system_task_id_HintHint=Gets the task ID of System Task.
_mqx_get_system_task_id_HintHintLong=Gets the task ID of System Task.
_mqx_get_tad_data=_mqx_get_tad_data
_mqx_get_tad_data_Hint=void* MQX1__mqx_get_tad_data(void* td);
_mqx_get_tad_data_HintHint=Gets the TAD_RESERVED field from the task descriptor.
_mqx_get_tad_data_HintHintLong=Gets the TAD_RESERVED field from the task descriptor.
_mqx_idle_task=_mqx_idle_task
_mqx_idle_task_Hint=void MQX1__mqx_idle_task(void* parameter);
_mqx_idle_task_HintHint=Idle Task is an MQX task that runs if all application tasks are blocked. The...
_mqx_idle_task_HintHintLong=Idle Task is an MQX task that runs if all application tasks are blocked. The function implements a simple counter, whose size depends on the CPU.
_mqx_set_cpu_type=_mqx_set_cpu_type
_mqx_set_cpu_type_Hint=void MQX1__mqx_set_cpu_type(void* cpu_type);
_mqx_set_cpu_type_HintHint=The function sets CPU_TYPE in kernel data. The MQX Host Tools family of...
_mqx_set_cpu_type_HintHintLong=The function sets CPU_TYPE in kernel data. The MQX Host Tools family of products uses CPU type. CPU types begin with PSP_CPU_TYPE_ and are defined in source\\psp\\cpu_family\\cpu_family.h.
_mqx_set_exit_handler=_mqx_set_exit_handler
_mqx_set_exit_handler_Hint=void MQX1__mqx_set_exit_handler(MQX_EXIT_FPTR entry);
_mqx_set_exit_handler_HintHint=Sets the address of the MQX exit handler, which MQX calls when it exits.
_mqx_set_exit_handler_HintHintLong=Sets the address of the MQX exit handler, which MQX calls when it exits.
_mutatr_destroy=_mutatr_destroy
_mutatr_destroy_Hint=_mqx_uint MQX1__mutatr_destroy(void* attr_ptr);
_mutatr_destroy_HintHint=Deinitializes the mutex attributes structure.
_mutatr_destroy_HintHintLong=Deinitializes the mutex attributes structure.
_mutatr_get_priority_ceiling=_mutatr_get_priority_ceiling
_mutatr_get_priority_ceiling_Hint=_mqx_uint MQX1__mutatr_get_priority_ceiling(void* attr_ptr, void* priority_ptr);
_mutatr_get_priority_ceiling_HintHint=Gets the priority value of the mutex attributes structure.
_mutatr_get_priority_ceiling_HintHintLong=Gets the priority value of the mutex attributes structure.
_mutatr_get_sched_protocol=_mutatr_get_sched_protocol
_mutatr_get_sched_protocol_Hint=_mqx_uint MQX1__mutatr_get_sched_protocol(void* attr_ptr, void* protocol_ptr);
_mutatr_get_sched_protocol_HintHint=Gets the scheduling protocol of the mutex attributes.
_mutatr_get_sched_protocol_HintHintLong=Gets the scheduling protocol of the mutex attributes.
_mutatr_get_spin_limit=_mutatr_get_spin_limit
_mutatr_get_spin_limit_Hint=_mqx_uint MQX1__mutatr_get_spin_limit(void* attr_ptr, void* spin_count_ptr);
_mutatr_get_spin_limit_HintHint=Gets the spin limit of the mutex attributes structure.
_mutatr_get_spin_limit_HintHintLong=Gets the spin limit of the mutex attributes structure.
_mutatr_get_wait_protocol=_mutatr_get_wait_protocol
_mutatr_get_wait_protocol_Hint=_mqx_uint MQX1__mutatr_get_wait_protocol(void* attr_ptr, void*...
_mutatr_get_wait_protocol_HintHint=Gets the waiting policy of the mutex attributes structure.
_mutatr_get_wait_protocol_HintHintLong=Gets the waiting policy of the mutex attributes structure.
_mutatr_init=_mutatr_init
_mutatr_init_Hint=_mqx_uint MQX1__mutatr_init(void* attr_ptr);
_mutatr_init_HintHint=Initializes the mutex attributes structure to default values.
_mutatr_init_HintHintLong=Initializes the mutex attributes structure to default values.
_mutatr_set_priority_ceiling=_mutatr_set_priority_ceiling
_mutatr_set_priority_ceiling_Hint=_mqx_uint MQX1__mutatr_set_priority_ceiling(void* attr_ptr, void* priority);
_mutatr_set_priority_ceiling_HintHint=Sets the priority value of the mutex attributes structure.
_mutatr_set_priority_ceiling_HintHintLong=Sets the priority value of the mutex attributes structure.
_mutatr_set_sched_protocol=_mutatr_set_sched_protocol
_mutatr_set_sched_protocol_Hint=_mqx_uint MQX1__mutatr_set_sched_protocol(void* attr_ptr, void* protocol);
_mutatr_set_sched_protocol_HintHint=
_mutatr_set_sched_protocol_HintHintLong=
_mutatr_set_spin_limit=_mutatr_set_spin_limit
_mutatr_set_spin_limit_Hint=_mqx_uint MQX1__mutatr_set_spin_limit(void* attr_ptr, void* spin_count);
_mutatr_set_spin_limit_HintHint=Sets the spin limit of the mutex attributes structure.
_mutatr_set_spin_limit_HintHintLong=Sets the spin limit of the mutex attributes structure.
_mutatr_set_wait_protocol=_mutatr_set_wait_protocol
_mutatr_set_wait_protocol_Hint=_mqx_uint MQX1__mutatr_set_wait_protocol(void* attr_ptr, void*...
_mutatr_set_wait_protocol_HintHint=Sets the waiting policy of the mutex attributes structure.
_mutatr_set_wait_protocol_HintHintLong=Sets the waiting policy of the mutex attributes structure.
_mutex_create_component=_mutex_create_component
_mutex_create_component_Hint=_mqx_uint MQX1__mutex_create_component(void);
_mutex_create_component_HintHint=Creates the mutex component.
_mutex_create_component_HintHintLong=Creates the mutex component.
_mutex_destroy=_mutex_destroy
_mutex_destroy_Hint=_mqx_uint MQX1__mutex_destroy(void* mutex_ptr);
_mutex_destroy_HintHint=Deinitializes the mutex.
_mutex_destroy_HintHintLong=Deinitializes the mutex.
_mutex_get_priority_ceiling=_mutex_get_priority_ceiling
_mutex_get_priority_ceiling_Hint=_mqx_uint MQX1__mutex_get_priority_ceiling(void* mutex_ptr, void* priority_ptr);
_mutex_get_priority_ceiling_HintHint=
_mutex_get_priority_ceiling_HintHintLong=
_mutex_get_wait_count=_mutex_get_wait_count
_mutex_get_wait_count_Hint=_mqx_uint MQX1__mutex_get_wait_count(void* mutex_ptr);
_mutex_get_wait_count_HintHint=Gets the number of tasks that are waiting for the mutex.
_mutex_get_wait_count_HintHintLong=Gets the number of tasks that are waiting for the mutex.
_mutex_init=_mutex_init
_mutex_init_Hint=_mqx_uint MQX1__mutex_init(void* mutex_ptr, void* attr_ptr);
_mutex_init_HintHint=Initializes the mutex.
_mutex_init_HintHintLong=Initializes the mutex.
_mutex_set_priority_ceiling=_mutex_set_priority_ceiling
_mutex_set_priority_ceiling_Hint=_mqx_uint MQX1__mutex_set_priority_ceiling(void* mutex_ptr, void* priority,...
_mutex_set_priority_ceiling_HintHint=Sets the priority of the mutex.
_mutex_set_priority_ceiling_HintHintLong=Sets the priority of the mutex.
_mutex_test=_mutex_test
_mutex_test_Hint=_mqx_uint MQX1__mutex_test(void* mutex_error_ptr);
_mutex_test_HintHint=Tests the mutex component.
_mutex_test_HintHintLong=Tests the mutex component.
_mutex_try_lock=_mutex_try_lock
_mutex_try_lock_Hint=_mqx_uint MQX1__mutex_try_lock(void* mutex_ptr);
_mutex_try_lock_HintHint=Tries to lock the mutex.
_mutex_try_lock_HintHintLong=Tries to lock the mutex.
_mutex_unlock=_mutex_unlock
_mutex_unlock_Hint=_mqx_uint MQX1__mutex_unlock(void* mutex_ptr);
_mutex_unlock_HintHint=
_mutex_unlock_HintHintLong=
_sched_get_max_priority=_sched_get_max_priority
_sched_get_max_priority_Hint=_mqx_uint MQX1__sched_get_max_priority(void* policy);
_sched_get_max_priority_HintHint=Gets the maximum priority that a task can be.
_sched_get_max_priority_HintHintLong=Gets the maximum priority that a task can be.
_sched_get_min_priority=_sched_get_min_priority
_sched_get_min_priority_Hint=_mqx_uint MQX1__sched_get_min_priority(void* policy);
_sched_get_min_priority_HintHint=Gets the minimum priority that an application task can be.
_sched_get_min_priority_HintHintLong=Gets the minimum priority that an application task can be.
_sched_yield=_sched_yield
_sched_yield_Hint=void MQX1__sched_yield(void);
_sched_yield_HintHint=Puts the active task at the end of its ready queue. The function effectively...
_sched_yield_HintHintLong=Puts the active task at the end of its ready queue. The function effectively performs a timeslice. If there are no other tasks in this ready queue, the task continues to be the active task.
_task_abort=_task_abort
_task_abort_Hint=_mqx_uint MQX1__task_abort(void* task_id);
_task_abort_HintHint=Makes a task run its task exit handler and then destroys itself.
_task_abort_HintHintLong=Makes a task run its task exit handler and then destroys itself.
_task_block=_task_block
_task_block_Hint=void MQX1__task_block(void);
_task_block_HintHint=Blocks the active task. The function removes the active task from the task’s...
_task_block_HintHintLong=Blocks the active task. The function removes the active task from the task’s ready queue and sets the BLOCKED bit in the STATE field of the task descriptor. The task does not run again until another task explicitly makes it ready with _task_ready().
_task_check_stack=_task_check_stack
_task_check_stack_Hint=bool MQX1__task_check_stack(void);
_task_check_stack_HintHint=Determines whether the stack for the active task is currently out of bounds. ...
_task_check_stack_HintHintLong=Determines whether the stack for the active task is currently out of bounds.   The function indicates whether the stack is currently past its limit. The function does not indicate whether the stack previously passed its limit.
_task_create_at=_task_create_at
_task_create_at_Hint=_task_id MQX1__task_create_at(void* processor_number, void* template_index,...
_task_create_at_HintHint=Creates the task with the stack location specified
_task_create_at_HintHintLong=Creates the task with the stack location specified
_task_destroy=_task_destroy
_task_destroy_Hint=_mqx_uint MQX1__task_destroy(void);
_task_destroy_HintHint=Destroys the task.   The function does the following for the task being...
_task_destroy_HintHintLong=Destroys the task.   The function does the following for the task being destroyed:   Frees memory resources that the task allocated with functions from the _mem and _partition   families.   Closes all queues that the task owns and frees all the queue elements.   Frees any other component resources that the task owns.
_task_disable_fp=_task_disable_fp
_task_disable_fp_Hint=void MQX1__task_disable_fp(void);
_task_disable_fp_HintHint=Disables floating-point context switching for the active task if the   task...
_task_disable_fp_HintHintLong=Disables floating-point context switching for the active task if the   task is a floating-point task.
_task_enable_fp=_task_enable_fp
_task_enable_fp_Hint=void MQX1__task_enable_fp(void);
_task_enable_fp_HintHint=Enables floating-point context switching for the active task.
_task_enable_fp_HintHintLong=Enables floating-point context switching for the active task.
_task_get_creator=_task_get_creator
_task_get_creator_Hint=_task_id MQX1__task_get_creator(void);
_task_get_creator_HintHint=Gets the task ID of the task that created the calling task.
_task_get_creator_HintHintLong=Gets the task ID of the task that created the calling task.
_task_get_environment=_task_get_environment
_task_get_environment_Hint=void* MQX1__task_get_environment(void* task_id);
_task_get_environment_HintHint=Gets a pointer to the application-specific environment data for the task.
_task_get_environment_HintHintLong=Gets a pointer to the application-specific environment data for the task.
_task_get_error=_task_get_error
_task_get_error_Hint=_mqx_uint MQX1__task_get_error(void);
_task_get_error_HintHint=Sets the task error code.   MQX uses the function to indicate an error. MQX...
_task_get_error_HintHintLong=Sets the task error code.   MQX uses the function to indicate an error. MQX never sets the task error code to MQX_OK; that is, MQX   does not reset the task error code. It is the responsibility of the application to reset the task error code.   As a result, when an application calls _task_get_error(), it gets the first error that MQX detected since the   last time the application reset the task error code.
_task_get_error_ptr=_task_get_error_ptr
_task_get_error_ptr_Hint=void* MQX1__task_get_error_ptr(void);
_task_get_error_ptr_HintHint=Gets a pointer to the task error code.
_task_get_error_ptr_HintHintLong=Gets a pointer to the task error code.
_task_get_exception_handler=_task_get_exception_handler
_task_get_exception_handler_Hint=TASK_EXCEPTION_FPTR MQX1__task_get_exception_handler(void* task_id);
_task_get_exception_handler_HintHint=Gets a pointer to the task exception handler.
_task_get_exception_handler_HintHintLong=Gets a pointer to the task exception handler.
_task_get_exit_handler=_task_get_exit_handler
_task_get_exit_handler_Hint=MQX_EXIT_FPTR MQX1__task_get_exit_handler(void* task_id);
_task_get_exit_handler_HintHint=Gets a pointer to the task exit handler for the task.
_task_get_exit_handler_HintHintLong=Gets a pointer to the task exit handler for the task.
_task_get_id_from_name=_task_get_id_from_name
_task_get_id_from_name_Hint=_task_id MQX1__task_get_id_from_name(void* name_ptr);
_task_get_id_from_name_HintHint=Gets the task ID that is associated with the task name.
_task_get_id_from_name_HintHintLong=Gets the task ID that is associated with the task name.
_task_get_index_from_id=_task_get_index_from_id
_task_get_index_from_id_Hint=_mqx_uint MQX1__task_get_index_from_id(void* task_id);
_task_get_index_from_id_HintHint=Gets the task template index for the task ID.
_task_get_index_from_id_HintHintLong=Gets the task template index for the task ID.
_task_get_parameter=_task_get_parameter
_task_get_parameter_Hint=uint_32 MQX1__task_get_parameter(void);
_task_get_parameter_HintHint=Gets the task creation parameter of the active task.
_task_get_parameter_HintHintLong=Gets the task creation parameter of the active task.
_task_get_parameter_for=_task_get_parameter_for
_task_get_parameter_for_Hint=uint_32 MQX1__task_get_parameter_for(void* task_id);
_task_get_parameter_for_HintHint=Gets the task creation parameter of the specified task
_task_get_parameter_for_HintHintLong=Gets the task creation parameter of the specified task
_task_get_priority=_task_get_priority
_task_get_priority_Hint=_mqx_uint MQX1__task_get_priority(void* task_id);
_task_get_priority_HintHint=Gets the priority of the task.
_task_get_priority_HintHintLong=Gets the priority of the task.
_task_get_processor=_task_get_processor
_task_get_processor_Hint=_processor_number MQX1__task_get_processor(void* task_id);
_task_get_processor_HintHint=
_task_get_processor_HintHintLong=
_task_get_td=_task_get_td
_task_get_td_Hint=void* MQX1__task_get_td(void* task_id);
_task_get_td_HintHint=Gets a pointer to the task descriptor for the task ID.
_task_get_td_HintHintLong=Gets a pointer to the task descriptor for the task ID.
_task_get_template_index=_task_get_template_index
_task_get_template_index_Hint=MQXLITE_TASK_TEMPLATE_STRUCT_PTR MQX1__task_get_template_index(void* task_id);
_task_get_template_index_HintHint=Gets the pointer to the task template for the task ID.
_task_get_template_index_HintHintLong=Gets the pointer to the task template for the task ID.
_task_ready=_task_ready
_task_ready_Hint=void MQX1__task_ready(void* td_ptr);
_task_ready_HintHint=Makes the task ready to run by putting it in its ready queue.
_task_ready_HintHintLong=Makes the task ready to run by putting it in its ready queue.
_task_restart=_task_restart
_task_restart_Hint=_mqx_uint MQX1__task_restart(void* task_id, void* param_ptr, bool blocked);
_task_restart_HintHint=Restarts the task.
_task_restart_HintHintLong=Restarts the task.
_task_set_environment=_task_set_environment
_task_set_environment_Hint=void* MQX1__task_set_environment(void* task_id, void* environment_ptr);
_task_set_environment_HintHint=Sets the address of the application-specific environment   data for the task.
_task_set_environment_HintHintLong=Sets the address of the application-specific environment   data for the task.
_task_set_error=_task_set_error
_task_set_error_Hint=_mqx_uint MQX1__task_set_error(void* error_code);
_task_set_error_HintHint=Sets the task error code.
_task_set_error_HintHintLong=Sets the task error code.
_task_set_exception_handler=_task_set_exception_handler
_task_set_exception_handler_Hint=TASK_EXCEPTION_FPTR MQX1__task_set_exception_handler(void* task_id, void*...
_task_set_exception_handler_HintHint=Sets the address of the task exception handler.
_task_set_exception_handler_HintHintLong=Sets the address of the task exception handler.
_task_set_exit_handler=_task_set_exit_handler
_task_set_exit_handler_Hint=MQX_EXIT_FPTR MQX1__task_set_exit_handler(void* task_id, void*...
_task_set_exit_handler_HintHint=Sets the address of the task exit handler for the task.
_task_set_exit_handler_HintHintLong=Sets the address of the task exit handler for the task.
_task_set_parameter=_task_set_parameter
_task_set_parameter_Hint=uint_32 MQX1__task_set_parameter(void* new_value);
_task_set_parameter_HintHint=
_task_set_parameter_HintHintLong=
_task_set_parameter_for=_task_set_parameter_for
_task_set_parameter_for_Hint=uint_32 MQX1__task_set_parameter_for(void* new_value, void* task_id);
_task_set_parameter_for_HintHint=Sets the task creation parameter of the specified task.
_task_set_parameter_for_HintHintLong=Sets the task creation parameter of the specified task.
_task_set_priority=_task_set_priority
_task_set_priority_Hint=_mqx_uint MQX1__task_set_priority(void* task_id, void* new_priority, void*...
_task_set_priority_HintHint=Sets the priority of the task.
_task_set_priority_HintHintLong=Sets the priority of the task.
_task_start_preemption=_task_start_preemption
_task_start_preemption_Hint=void MQX1__task_start_preemption(void);
_task_start_preemption_HintHint=Enables preemption of the current task.
_task_start_preemption_HintHintLong=Enables preemption of the current task.
_task_stop_preemption=_task_stop_preemption
_task_stop_preemption_Hint=void MQX1__task_stop_preemption(void);
_task_stop_preemption_HintHint=Disables preemption of the current task.
_task_stop_preemption_HintHintLong=Disables preemption of the current task.
_taskq_create=_taskq_create
_taskq_create_Hint=void* MQX1__taskq_create(void* policy);
_taskq_create_HintHint=Creates a task queue.
_taskq_create_HintHintLong=Creates a task queue.
_taskq_destroy=_taskq_destroy
_taskq_destroy_Hint=_mqx_uint MQX1__taskq_destroy(void* task_queue_ptr);
_taskq_destroy_HintHint=Destroys the task queue.
_taskq_destroy_HintHintLong=Destroys the task queue.
_taskq_get_value=_taskq_get_value
_taskq_get_value_Hint=_mqx_uint MQX1__taskq_get_value(void* task_queue_ptr);
_taskq_get_value_HintHint=Gets the number of tasks that are in the task queue.
_taskq_get_value_HintHintLong=Gets the number of tasks that are in the task queue.
_taskq_resume=_taskq_resume
_taskq_resume_Hint=_mqx_uint MQX1__taskq_resume(void* task_queue, bool all_tasks);
_taskq_resume_HintHint=Restarts the task that is suspended in the task queue.
_taskq_resume_HintHintLong=Restarts the task that is suspended in the task queue.
_taskq_suspend=_taskq_suspend
_taskq_suspend_Hint=_mqx_uint MQX1__taskq_suspend(void* task_queue);
_taskq_suspend_HintHint=Suspends the active task and put it in the task queue.
_taskq_suspend_HintHintLong=Suspends the active task and put it in the task queue.
_taskq_suspend_task=_taskq_suspend_task
_taskq_suspend_task_Hint=_mqx_uint MQX1__taskq_suspend_task(void* task_id, void* task_queue_ptr);
_taskq_suspend_task_HintHint=Suspends the ready task in the task queue.
_taskq_suspend_task_HintHintLong=Suspends the ready task in the task queue.
_taskq_test=_taskq_test
_taskq_test_Hint=_mqx_uint MQX1__taskq_test(void* task_queue_error_ptr, void* td_error_ptr);
_taskq_test_HintHint=Tests the task queues.
_taskq_test_HintHintLong=Tests the task queues.
_time_delay_ticks=_time_delay_ticks
_time_delay_ticks_Hint=void MQX1__time_delay_ticks(void* tick_delay);
_time_delay_ticks_HintHint=Suspend the active task for the number of ticks.
_time_delay_ticks_HintHintLong=Suspend the active task for the number of ticks.
_time_diff_ticks=_time_diff_ticks
_time_diff_ticks_Hint=_mqx_uint MQX1__time_diff_ticks(void* tick_end_time_ptr, void*...
_time_diff_ticks_HintHint=Get the difference between two tick times.
_time_diff_ticks_HintHintLong=Get the difference between two tick times.
_time_get_elapsed_ticks=_time_get_elapsed_ticks
_time_get_elapsed_ticks_Hint=void MQX1__time_get_elapsed_ticks(void* tick_time_ptr);
_time_get_elapsed_ticks_HintHint=Get the time in this format since MQX started tick time.
_time_get_elapsed_ticks_HintHintLong=Get the time in this format since MQX started tick time.
_time_get_hwticks=_time_get_hwticks
_time_get_hwticks_Hint=uint_32 MQX1__time_get_hwticks(void);
_time_get_hwticks_HintHint=Gets the number of hardware ticks since the last tick.
_time_get_hwticks_HintHintLong=Gets the number of hardware ticks since the last tick.
_time_get_hwticks_per_tick=_time_get_hwticks_per_tick
_time_get_hwticks_per_tick_Hint=uint_32 MQX1__time_get_hwticks_per_tick(void);
_time_get_hwticks_per_tick_HintHint=Gets the number of hardware ticks per tick.
_time_get_hwticks_per_tick_HintHintLong=Gets the number of hardware ticks per tick.
_time_get_ticks=_time_get_ticks
_time_get_ticks_Hint=void MQX1__time_get_ticks(void* tick_time_ptr);
_time_get_ticks_HintHint=Get the absolute time in tick time
_time_get_ticks_HintHintLong=Get the absolute time in tick time
_time_get_ticks_per_sec=_time_get_ticks_per_sec
_time_get_ticks_per_sec_Hint=_mqx_uint MQX1__time_get_ticks_per_sec(void);
_time_get_ticks_per_sec_HintHint=Gets the timer frequency (in ticks per second) that MQX uses.
_time_get_ticks_per_sec_HintHintLong=Gets the timer frequency (in ticks per second) that MQX uses.
_time_init_ticks=_time_init_ticks
_time_init_ticks_Hint=_mqx_uint MQX1__time_init_ticks(void* tick_time_ptr, void* ticks);
_time_init_ticks_HintHint=Initializes a tick time structure with the number of ticks.
_time_init_ticks_HintHintLong=Initializes a tick time structure with the number of ticks.
_time_notify_kernel=_time_notify_kernel
_time_notify_kernel_Hint=void MQX1__time_notify_kernel(void);
_time_notify_kernel_HintHint=The BSP periodic timer ISR calls the function when a periodic timer interrupt...
_time_notify_kernel_HintHintLong=The BSP periodic timer ISR calls the function when a periodic timer interrupt occurs.
_time_set_hwtick_function=_time_set_hwtick_function
_time_set_hwtick_function_Hint=void MQX1__time_set_hwtick_function(MQX_GET_HWTICKS_FPTR hwtick_function_ptr,...
_time_set_hwtick_function_HintHint=Set the fields in kernel data to get the hardware ticks.
_time_set_hwtick_function_HintHintLong=Set the fields in kernel data to get the hardware ticks.
_time_set_hwticks_per_tick=_time_set_hwticks_per_tick
_time_set_hwticks_per_tick_Hint=void MQX1__time_set_hwticks_per_tick(void* new_ticks);
_time_set_hwticks_per_tick_HintHint=Sets the number of hardware ticks per tick.
_time_set_hwticks_per_tick_HintHintLong=Sets the number of hardware ticks per tick.
_time_set_resolution=_time_set_resolution
_time_set_resolution_Hint=_mqx_uint MQX1__time_set_resolution(void* resolution);
_time_set_resolution_HintHint=Sets the resolution of the periodic timer interrupt.
_time_set_resolution_HintHintLong=Sets the resolution of the periodic timer interrupt.
_time_set_ticks=_time_set_ticks
_time_set_ticks_Hint=void MQX1__time_set_ticks(void* tick_time_ptr);
_time_set_ticks_HintHint=Set the absolute time in tick time
_time_set_ticks_HintHintLong=Set the absolute time in tick time
_time_set_ticks_per_sec=_time_set_ticks_per_sec
_time_set_ticks_per_sec_Hint=void MQX1__time_set_ticks_per_sec(void* ticks_per_sec);
_time_set_ticks_per_sec_HintHint=Sets the timer frequency (in ticks per second) that MQX uses.
_time_set_ticks_per_sec_HintHintLong=Sets the timer frequency (in ticks per second) that MQX uses.
_time_set_timer_vector=_time_set_timer_vector
_time_set_timer_vector_Hint=void MQX1__time_set_timer_vector(void* vector);
_time_set_timer_vector_HintHint=Sets the periodic timer interrupt vector number that MQX uses.
_time_set_timer_vector_HintHintLong=Sets the periodic timer interrupt vector number that MQX uses.
_usr_lwevent_clear=_usr_lwevent_clear
_usr_lwevent_clear_Hint=_mqx_uint MQX1__usr_lwevent_clear(void* event_group_ptr, void* bit_mask);
_usr_lwevent_clear_HintHint=This function is an equivalent to the _lwevent_clear API call but it can be...
_usr_lwevent_clear_HintHintLong=This function is an equivalent to the _lwevent_clear API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwevent_create=_usr_lwevent_create
_usr_lwevent_create_Hint=_mqx_uint MQX1__usr_lwevent_create(void* lwevent_group_ptr, void* flags);
_usr_lwevent_create_HintHint=This function is an equivalent to the _lwevent_create API call but it can be...
_usr_lwevent_create_HintHintLong=This function is an equivalent to the _lwevent_create API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwevent_destroy=_usr_lwevent_destroy
_usr_lwevent_destroy_Hint=_mqx_uint MQX1__usr_lwevent_destroy(void* wevent_group_ptr);
_usr_lwevent_destroy_HintHint=This function is an equivalent to the _lwevent_destroy API call but it can be...
_usr_lwevent_destroy_HintHintLong=This function is an equivalent to the _lwevent_destroy API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwevent_get_signalled=_usr_lwevent_get_signalled
_usr_lwevent_get_signalled_Hint=_mqx_uint MQX1__usr_lwevent_get_signalled(void);
_usr_lwevent_get_signalled_HintHint=This function is an equivalent to the _lwevent_get_signalled API call but it...
_usr_lwevent_get_signalled_HintHintLong=This function is an equivalent to the _lwevent_get_signalled API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection equirements as described in the parameter list below.
_usr_lwevent_set=_usr_lwevent_set
_usr_lwevent_set_Hint=_mqx_uint MQX1__usr_lwevent_set(void* lwevent_group_ptr, void* flags);
_usr_lwevent_set_HintHint=This function is an equivalent to the _lwevent_set API call but it can be...
_usr_lwevent_set_HintHintLong=This function is an equivalent to the _lwevent_set API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwevent_set_auto_clear=_usr_lwevent_set_auto_clear
_usr_lwevent_set_auto_clear_Hint=_mqx_uint MQX1__usr_lwevent_set_auto_clear(void* lwevent_group_ptr, void*...
_usr_lwevent_set_auto_clear_HintHint=
_usr_lwevent_set_auto_clear_HintHintLong=
_usr_lwevent_wait_for=_usr_lwevent_wait_for
_usr_lwevent_wait_for_Hint=_mqx_uint MQX1__usr_lwevent_wait_for(void* event_ptr, void* bit_mask, bool...
_usr_lwevent_wait_for_HintHint=Wait for the specified lightweight event bits to be set in the lightweight...
_usr_lwevent_wait_for_HintHintLong=Wait for the specified lightweight event bits to be set in the lightweight event group for the number of ticks (in tick time)
_usr_lwevent_wait_ticks=_usr_lwevent_wait_ticks
_usr_lwevent_wait_ticks_Hint=_mqx_uint MQX1__usr_lwevent_wait_ticks(void* event_ptr, void* bit_mask, bool...
_usr_lwevent_wait_ticks_HintHint=Wait for the specified lightweight event bits to be set in the lightweight...
_usr_lwevent_wait_ticks_HintHintLong=Wait for the specified lightweight event bits to be set in the lightweight event group for the number of ticks
_usr_lwevent_wait_until=_usr_lwevent_wait_until
_usr_lwevent_wait_until_Hint=_mqx_uint MQX1__usr_lwevent_wait_until(void* event_ptr, void* bit_mask, bool...
_usr_lwevent_wait_until_HintHint=Wait for the specified lightweight event bits to be set in the lightweight...
_usr_lwevent_wait_until_HintHintLong=Wait for the specified lightweight event bits to be set in the lightweight event group until the specified time (in tick time)
_usr_lwmsgq_init=_usr_lwmsgq_init
_usr_lwmsgq_init_Hint=_mqx_uint MQX1__usr_lwmsgq_init(void);
_usr_lwmsgq_init_HintHint=
_usr_lwmsgq_init_HintHintLong=
_usr_lwsem_create=_usr_lwsem_create
_usr_lwsem_create_Hint=_mqx_uint MQX1__usr_lwsem_create(void* lwsem_ptr, void* initial_count);
_usr_lwsem_create_HintHint=This function is an equivalent to the _lwsem_create API call but it can be...
_usr_lwsem_create_HintHintLong=This function is an equivalent to the _lwsem_create API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwsem_destroy=_usr_lwsem_destroy
_usr_lwsem_destroy_Hint=_mqx_uint MQX1__usr_lwsem_destroy(void* lwsem_ptr);
_usr_lwsem_destroy_HintHint=This function is an equivalent to the _lwsem_destroy API call but it can be...
_usr_lwsem_destroy_HintHintLong=This function is an equivalent to the _lwsem_destroy API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements
_usr_lwsem_poll=_usr_lwsem_poll
_usr_lwsem_poll_Hint=_mqx_uint MQX1__usr_lwsem_poll(void* lwsem_ptr);
_usr_lwsem_poll_HintHint=This function is an equivalent to the _lwsem_poll API call but it can be...
_usr_lwsem_poll_HintHintLong=This function is an equivalent to the _lwsem_poll API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwsem_post=_usr_lwsem_post
_usr_lwsem_post_Hint=_mqx_uint MQX1__usr_lwsem_post(void* lwsem_ptr);
_usr_lwsem_post_HintHint=This function is an equivalent to the _lwsem_post API call but it can be...
_usr_lwsem_post_HintHintLong=This function is an equivalent to the _lwsem_post API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_lwsem_wait=_usr_lwsem_wait
_usr_lwsem_wait_Hint=_mqx_uint MQX1__usr_lwsem_wait(void* sem_ptr);
_usr_lwsem_wait_HintHint=Wait (in FIFO order) for the lightweight semaphore until it is available.
_usr_lwsem_wait_HintHintLong=Wait (in FIFO order) for the lightweight semaphore until it is available.
_usr_lwsem_wait_for=_usr_lwsem_wait_for
_usr_lwsem_wait_for_Hint=_mqx_uint MQX1__usr_lwsem_wait_for(void* sem_ptr, void* tick_time_timeout_ptr);
_usr_lwsem_wait_for_HintHint=Wait (in FIFO order) for the lightweight semaphore for the number of ticks...
_usr_lwsem_wait_for_HintHintLong=Wait (in FIFO order) for the lightweight semaphore for the number of ticks (in tick time)
_usr_lwsem_wait_ticks=_usr_lwsem_wait_ticks
_usr_lwsem_wait_ticks_Hint=_mqx_uint MQX1__usr_lwsem_wait_ticks(void* sem_ptr, void* tick_timeout);
_usr_lwsem_wait_ticks_HintHint=Wait (in FIFO order) for the lightweight semaphore for the number of ticks
_usr_lwsem_wait_ticks_HintHintLong=Wait (in FIFO order) for the lightweight semaphore for the number of ticks
_usr_lwsem_wait_until=_usr_lwsem_wait_until
_usr_lwsem_wait_until_Hint=_mqx_uint MQX1__usr_lwsem_wait_until(void* sem_ptr, void* tick_time_ptr);
_usr_lwsem_wait_until_HintHint=Wait (in FIFO order) for the lightweight semaphore until the specified time...
_usr_lwsem_wait_until_HintHintLong=Wait (in FIFO order) for the lightweight semaphore until the specified time (in tick time)
_usr_task_abort=_usr_task_abort
_usr_task_abort_Hint=_mqx_uint MQX1__usr_task_abort(void* task_id);
_usr_task_abort_HintHint=This function is an equivalent to the _task_abort API call but it can be...
_usr_task_abort_HintHintLong=This function is an equivalent to the _task_abort API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_task_create=_usr_task_create
_usr_task_create_Hint=_task_id MQX1__usr_task_create(void* processor_number, void* template_index,...
_usr_task_create_HintHint=This function is an equivalent to the _task_create API call but it can be...
_usr_task_create_HintHintLong=This function is an equivalent to the _task_create API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_task_destroy=_usr_task_destroy
_usr_task_destroy_Hint=_mqx_uint MQX1__usr_task_destroy(void* task_id);
_usr_task_destroy_HintHint=This function is an equivalent to the _task_destroy API call but it can be...
_usr_task_destroy_HintHintLong=This function is an equivalent to the _task_destroy API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_task_get_td=_usr_task_get_td
_usr_task_get_td_Hint=void* MQX1__usr_task_get_td(void* task_id);
_usr_task_get_td_HintHint=This function is an equivalent to the _task_get_td API call but it can be...
_usr_task_get_td_HintHintLong=This function is an equivalent to the _task_get_td API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_task_ready=_usr_task_ready
_usr_task_ready_Hint=void MQX1__usr_task_ready(void* td_ptr);
_usr_task_ready_HintHint=This function is an equivalent to the _task_ready API call but it can be...
_usr_task_ready_HintHintLong=This function is an equivalent to the _task_ready API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_task_set_error=_usr_task_set_error
_usr_task_set_error_Hint=_mqx_uint MQX1__usr_task_set_error(void* error_code);
_usr_task_set_error_HintHint=This function is an equivalent to the _task_set_error API call but it can be...
_usr_task_set_error_HintHintLong=This function is an equivalent to the _task_set_error API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_time_delay=_usr_time_delay
_usr_time_delay_Hint=void MQX1__usr_time_delay(void* ms_delay);
_usr_time_delay_HintHint=These functions are equivalents to _time_delay … API calls but they can be...
_usr_time_delay_HintHintLong=These functions are equivalents to _time_delay … API calls but they can be executed from within the User task or other code running in the CPU User mode. Parameters passed to these functions by pointer are required to meet the memory protection requirements as described in the parameter list below.
_usr_time_delay_ticks=_usr_time_delay_ticks
_usr_time_delay_ticks_Hint=void MQX1__usr_time_delay_ticks(void* tick_delay);
_usr_time_delay_ticks_HintHint=
_usr_time_delay_ticks_HintHintLong=
_usr_time_get_elapsed_ticks=_usr_time_get_elapsed_ticks
_usr_time_get_elapsed_ticks_Hint=void MQX1__usr_time_get_elapsed_ticks(void* tick_time_ptr);
_usr_time_get_elapsed_ticks_HintHint=This function is an equivalent to the _time_get_elapsed_ticks API call but it...
_usr_time_get_elapsed_ticks_HintHintLong=This function is an equivalent to the _time_get_elapsed_ticks API call but it can be executed from within the User task or other code running in the CPU User mode. Parameters passed to this function by pointer are required to meet the memory protection requirements as described in the parameter list below.
hasUserEnterCriticalFun=no
hasUserExitCriticalFun=no
ivINT_ADC0=defaultInt
ivINT_ADC0_No=31
ivINT_ADC0_UserCount=0
ivINT_CMP0=defaultInt
ivINT_CMP0_No=32
ivINT_CMP0_UserCount=0
ivINT_DAC0=defaultInt
ivINT_DAC0_No=41
ivINT_DAC0_UserCount=0
ivINT_DMA0=defaultInt
ivINT_DMA0_No=16
ivINT_DMA0_UserCount=0
ivINT_DMA1=defaultInt
ivINT_DMA1_No=17
ivINT_DMA1_UserCount=0
ivINT_DMA2=defaultInt
ivINT_DMA2_No=18
ivINT_DMA2_UserCount=0
ivINT_DMA3=defaultInt
ivINT_DMA3_No=19
ivINT_DMA3_UserCount=0
ivINT_FTFA=defaultInt
ivINT_FTFA_No=21
ivINT_FTFA_UserCount=0
ivINT_Hard_Fault=defaultInt
ivINT_Hard_Fault_No=3
ivINT_Hard_Fault_UserCount=0
ivINT_I2C0=defaultInt
ivINT_I2C0_No=24
ivINT_I2C0_UserCount=0
ivINT_I2C1=defaultInt
ivINT_I2C1_No=25
ivINT_I2C1_UserCount=0
ivINT_Initial_Program_Counter=defaultInt
ivINT_Initial_Program_Counter_No=1
ivINT_Initial_Program_Counter_RESET=
ivINT_Initial_Program_Counter_UserCount=0
ivINT_Initial_Stack_Pointer=defaultInt
ivINT_Initial_Stack_Pointer_No=0
ivINT_Initial_Stack_Pointer_RESET=
ivINT_Initial_Stack_Pointer_UserCount=0
ivINT_LLW=defaultInt
ivINT_LLW_No=23
ivINT_LLW_UserCount=0
ivINT_LPTimer=defaultInt
ivINT_LPTimer_No=44
ivINT_LPTimer_UserCount=0
ivINT_LVD_LVW=defaultInt
ivINT_LVD_LVW_No=22
ivINT_LVD_LVW_UserCount=1
ivINT_MCG=defaultInt
ivINT_MCG_No=43
ivINT_MCG_UserCount=0
ivINT_NMI=defaultInt
ivINT_NMI_No=2
ivINT_NMI_UserCount=1
ivINT_PIT=defaultInt
ivINT_PIT_No=38
ivINT_PIT_UserCount=0
ivINT_PORTA=defaultInt
ivINT_PORTA_No=46
ivINT_PORTA_UserCount=0
ivINT_PORTD=defaultInt
ivINT_PORTD_No=47
ivINT_PORTD_UserCount=0
ivINT_PendableSrvReq=defaultInt
ivINT_PendableSrvReq_No=14
ivINT_PendableSrvReq_UserCount=0
ivINT_RTC=defaultInt
ivINT_RTC_No=36
ivINT_RTC_Seconds=defaultInt
ivINT_RTC_Seconds_No=37
ivINT_RTC_Seconds_UserCount=0
ivINT_RTC_UserCount=0
ivINT_Reserved10=defaultInt
ivINT_Reserved10_No=10
ivINT_Reserved10_UserCount=0
ivINT_Reserved12=defaultInt
ivINT_Reserved12_No=12
ivINT_Reserved12_UserCount=0
ivINT_Reserved13=defaultInt
ivINT_Reserved13_No=13
ivINT_Reserved13_UserCount=0
ivINT_Reserved20=defaultInt
ivINT_Reserved20_No=20
ivINT_Reserved20_UserCount=0
ivINT_Reserved39=defaultInt
ivINT_Reserved39_No=39
ivINT_Reserved39_UserCount=0
ivINT_Reserved4=defaultInt
ivINT_Reserved45=defaultInt
ivINT_Reserved45_No=45
ivINT_Reserved45_UserCount=0
ivINT_Reserved4_No=4
ivINT_Reserved4_UserCount=0
ivINT_Reserved5=defaultInt
ivINT_Reserved5_No=5
ivINT_Reserved5_UserCount=0
ivINT_Reserved6=defaultInt
ivINT_Reserved6_No=6
ivINT_Reserved6_UserCount=0
ivINT_Reserved7=defaultInt
ivINT_Reserved7_No=7
ivINT_Reserved7_UserCount=0
ivINT_Reserved8=defaultInt
ivINT_Reserved8_No=8
ivINT_Reserved8_UserCount=0
ivINT_Reserved9=defaultInt
ivINT_Reserved9_No=9
ivINT_Reserved9_UserCount=0
ivINT_SPI0=defaultInt
ivINT_SPI0_No=26
ivINT_SPI0_UserCount=0
ivINT_SPI1=defaultInt
ivINT_SPI1_No=27
ivINT_SPI1_UserCount=0
ivINT_SVCall=defaultInt
ivINT_SVCall_No=11
ivINT_SVCall_UserCount=0
ivINT_SysTick=defaultInt
ivINT_SysTick_No=15
ivINT_SysTick_UserCount=2
ivINT_TPM0=defaultInt
ivINT_TPM0_No=33
ivINT_TPM0_UserCount=0
ivINT_TPM1=defaultInt
ivINT_TPM1_No=34
ivINT_TPM1_UserCount=0
ivINT_TPM2=defaultInt
ivINT_TPM2_No=35
ivINT_TPM2_UserCount=0
ivINT_TSI0=defaultInt
ivINT_TSI0_No=42
ivINT_TSI0_UserCount=0
ivINT_UART0=defaultInt
ivINT_UART0_No=28
ivINT_UART0_UserCount=0
ivINT_UART1=defaultInt
ivINT_UART1_No=29
ivINT_UART1_UserCount=0
ivINT_UART2=defaultInt
ivINT_UART2_No=30
ivINT_UART2_UserCount=0
ivINT_USB0=defaultInt
ivINT_USB0_No=40
ivINT_USB0_UserCount=1
runSpeedModeNum=1
InhrSymbolList=[SystemTimer]
InterruptVectorAddrs=[0|4|8|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96|100|104|108|112|116|120|124|128|132|136|140|144|148|152|156|160|164|168|172|176|180|184|188]
InterruptVectors=[ivINT_Initial_Stack_Pointer|ivINT_Initial_Program_Counter|ivINT_NMI|ivINT_Hard_Fault|ivINT_Reserved4|ivINT_Reserved5|ivINT_Reserved6|ivINT_Reserved7|ivINT_Reserved8|ivINT_Reserved9|ivINT_Reserved10|ivINT_SVCall|ivINT_Reserved12|ivINT_Reserved13|ivINT_PendableSrvReq|ivINT_SysTick|ivINT_DMA0|ivINT_DMA1|ivINT_DMA2|ivINT_DMA3|ivINT_Reserved20|ivINT_FTFA|ivINT_LVD_LVW|ivINT_LLW|ivINT_I2C0|ivINT_I2C1|ivINT_SPI0|ivINT_SPI1|ivINT_UART0|ivINT_UART1|ivINT_UART2|ivINT_ADC0|ivINT_CMP0|ivINT_TPM0|ivINT_TPM1|ivINT_TPM2|ivINT_RTC|ivINT_RTC_Seconds|ivINT_PIT|ivINT_Reserved39|ivINT_USB0|ivINT_DAC0|ivINT_TSI0|ivINT_MCG|ivINT_LPTimer|ivINT_Reserved45|ivINT_PORTA|ivINT_PORTD]
MQXUserDefinitions=[/* Additional settings can be defined in the property User Definitions > Definitions of the MQXLite RTOS component */]
MQXUserDefinitionsLen=[117]
MethodHintList=[void MQX1__int_default_isr(void* vector_number);|void MQX1__int_disable(void);|void MQX1__int_enable(void);|void MQX1__int_exception_isr(void* parameter);|INT_ISR_FPTR MQX1__int_get_default_isr(void);|INT_EXCEPTION_FPTR MQX1__int_get_exception_handler(_mqx_uint vector_number);|INT_ISR_FPTR MQX1__int_get_isr(void* vector_number);|_mqx_uint MQX1__int_get_isr_depth(void);|void* MQX1__int_get_isr_data(void* vector_number);|INT_KERNEL_ISR_FPTR MQX1__int_get_kernel_isr(void* vector_number);|_mqx_max_type MQX1__int_get_previous_vector_table(void);|_mqx_max_type MQX1__int_get_vector_table(void);|INT_ISR_FPTR MQX1__int_install_default_isr(void* default_isr);|INT_KERNEL_ISR_FPTR MQX1__int_install_kernel_isr(void* vector, void* isr_ptr);|INT_ISR_FPTR MQX1__int_install_isr(void* vector, void* isr_ptr, void* isr_data);|INT_ISR_FPTR MQX1__int_install_exception_isr(void);|INT_ISR_FPTR MQX1__int_install_unexpected_isr(void);|void MQX1__int_kernel_isr(void);|INT_EXCEPTION_FPTR MQX1__int_set_exception_handler(void* vector, void* error_handler_addr);|void* MQX1__int_set_isr_data(void* vector, void* data);|_mqx_max_type MQX1__int_set_vector_table(void* new);|void MQX1__int_unexpected_isr(void* parameter);|_mqx_uint MQX1__klog_create_at(void* max_size, void* flags, void* where);|_mqx_uint MQX1__klog_get_interrupt_stack_usage(void* stack_size_ptr, void* stack_used_ptr);|_mqx_uint MQX1__klog_get_task_stack_usage(void* stack_size_ptr, void* stack_used_ptr);|void MQX1__klog_control(void* bit_mask, bool set_bits);|void MQX1__klog_disable_logging_task(void* task_id);|bool MQX1__klog_display(void);|void MQX1__klog_enable_logging_task(void* task_id);|void MQX1__klog_show_stack_usage(void);|_mqx_uint MQX1__lwsem_create(void* lwsem_ptr, void* initial_count);|_mqx_uint MQX1__lwsem_destroy(void* lwsem_ptr);|bool MQX1__lwsem_poll(void* lwsem_ptr);|_mqx_uint MQX1__lwsem_post(void* lwsem_ptr);|_mqx_uint MQX1__lwsem_test(void* lwsem_error_ptr, void* td_error_ptr);|_mqx_uint MQX1__lwsem_wait(void* sem_ptr);|_mqx_uint MQX1__lwsem_wait_ticks(void* sem_ptr, void* tick_time_timeout_ptr);|_mqx_uint MQX1__lwsem_wait_for(void* sem_ptr, void* tick_timeout);|_mqx_uint MQX1__lwsem_wait_until(void* sem_ptr, void* tick_time_ptr);|void MQX1__mem_zero(void* ptr, void* num_units);|_mqx_uint MQX1__mem_test_and_set(void* location_ptr);|void MQX1__mqx_exit(void* error_code);|void MQX1__mqx_fatal_error(void* error);|_mqx_uint MQX1__mqx_get_counter(void);|_mqx_uint MQX1__mqx_get_cpu_type(void);|MQX_INITIALIZATION_STRUCT_PTR MQX1__mqx_get_initialization(void);|void* MQX1__mqx_get_kernel_data(void);|MQX_EXIT_FPTR MQX1__mqx_get_exit_handler(void);|_task_id MQX1__mqx_get_system_task_id(void);|void* MQX1__mqx_get_tad_data(void* td);|void MQX1__mqx_idle_task(void* parameter);|void MQX1__mqx_set_cpu_type(void* cpu_type);|void MQX1__mqx_set_exit_handler(MQX_EXIT_FPTR entry);|_mqx_uint MQX1__sched_get_max_priority(void* policy);|_mqx_uint MQX1__sched_get_min_priority(void* policy);|void MQX1__sched_yield(void);|_mqx_uint MQX1__task_abort(void* task_id);|void MQX1__task_block(void);|bool MQX1__task_check_stack(void);|_task_id MQX1__task_create_at(void* processor_number, void* template_index, void* parameter, void* stack_ptr, void* stack_size);|_mqx_uint MQX1__task_destroy(void);|void MQX1__task_disable_fp(void);|void MQX1__task_enable_fp(void);|_task_id MQX1__task_get_creator(void);|void* MQX1__task_get_environment(void* task_id);|TASK_EXCEPTION_FPTR MQX1__task_get_exception_handler(void* task_id);|_mqx_uint MQX1__task_get_error(void);|void* MQX1__task_get_error_ptr(void);|MQX_EXIT_FPTR MQX1__task_get_exit_handler(void* task_id);|_task_id MQX1__task_get_id_from_name(void* name_ptr);|_mqx_uint MQX1__task_get_index_from_id(void* task_id);|uint_32 MQX1__task_get_parameter(void);|uint_32 MQX1__task_get_parameter_for(void* task_id);|_processor_number MQX1__task_get_processor(void* task_id);|_mqx_uint MQX1__task_get_priority(void* task_id);|void* MQX1__task_get_td(void* task_id);|MQXLITE_TASK_TEMPLATE_STRUCT_PTR MQX1__task_get_template_index(void* task_id);|void MQX1__task_ready(void* td_ptr);|_mqx_uint MQX1__task_restart(void* task_id, void* param_ptr, bool blocked);|void* MQX1__task_set_environment(void* task_id, void* environment_ptr);|_mqx_uint MQX1__task_set_error(void* error_code);|TASK_EXCEPTION_FPTR MQX1__task_set_exception_handler(void* task_id, void* handler_address);|MQX_EXIT_FPTR MQX1__task_set_exit_handler(void* task_id, void* exit_handler_address);|uint_32 MQX1__task_set_parameter(void* new_value);|uint_32 MQX1__task_set_parameter_for(void* new_value, void* task_id);|_mqx_uint MQX1__task_set_priority(void* task_id, void* new_priority, void* old_priority_ptr);|void MQX1__task_stop_preemption(void);|void MQX1__task_start_preemption(void);|void* MQX1__taskq_create(void* policy);|_mqx_uint MQX1__taskq_destroy(void* task_queue_ptr);|_mqx_uint MQX1__taskq_resume(void* task_queue, bool all_tasks);|_mqx_uint MQX1__taskq_suspend(void* task_queue);|_mqx_uint MQX1__taskq_suspend_task(void* task_id, void* task_queue_ptr);|_mqx_uint MQX1__taskq_test(void* task_queue_error_ptr, void* td_error_ptr);|_mqx_uint MQX1__taskq_get_value(void* task_queue_ptr);|void MQX1__time_delay_ticks(void* tick_delay);|_mqx_uint MQX1__time_diff_ticks(void* tick_end_time_ptr, void* tick_start_time_ptr, void* tick_diff_time_ptr);|void MQX1__time_get_elapsed_ticks(void* tick_time_ptr);|uint_32 MQX1__time_get_hwticks(void);|uint_32 MQX1__time_get_hwticks_per_tick(void);|void MQX1__time_get_ticks(void* tick_time_ptr);|_mqx_uint MQX1__time_get_ticks_per_sec(void);|_mqx_uint MQX1__time_init_ticks(void* tick_time_ptr, void* ticks);|void MQX1__time_notify_kernel(void);|void MQX1__time_set_hwtick_function(MQX_GET_HWTICKS_FPTR hwtick_function_ptr, void* parameter);|void MQX1__time_set_hwticks_per_tick(void* new_ticks);|_mqx_uint MQX1__time_set_resolution(void* resolution);|void MQX1__time_set_ticks(void* tick_time_ptr);|void MQX1__time_set_ticks_per_sec(void* ticks_per_sec);|void MQX1__time_set_timer_vector(void* vector);|_mqx_uint MQX1__lwevent_create(void* lwevent_group_ptr, void* flags);|_mqx_uint MQX1__lwevent_destroy(void* lwevent_group_ptr);|_mqx_uint MQX1__lwevent_set(void* lwevent_group_ptr, void* flags);|_mqx_uint MQX1__lwevent_set_auto_clear(void* lwevent_group_ptr, void* auto_mask);|_mqx_uint MQX1__lwevent_clear(void* event_group_ptr, void* bit_mask);|_mqx_uint MQX1__lwevent_wait_for(void* event_ptr, void* bit_mask, bool all, void* tick_ptr);|_mqx_uint MQX1__lwevent_wait_ticks(void* event_ptr, void* bit_mask, bool all, void* timeout_in_ticks);|_mqx_uint MQX1__lwevent_wait_until(void* event_ptr, void* bit_mask, bool all, void* tick_ptr);|_mqx_uint MQX1__lwevent_get_signalled(void);|_mqx_uint MQX1__lwevent_test(void* lwevent_error_ptr, void* td_error_ptr);|_mqx_uint MQX1__mutatr_destroy(void* attr_ptr);|_mqx_uint MQX1__mutatr_get_priority_ceiling(void* attr_ptr, void* priority_ptr);|_mqx_uint MQX1__mutatr_get_sched_protocol(void* attr_ptr, void* protocol_ptr);|_mqx_uint MQX1__mutatr_get_spin_limit(void* attr_ptr, void* spin_count_ptr);|_mqx_uint MQX1__mutatr_get_wait_protocol(void* attr_ptr, void* waiting_protocol_ptr);|_mqx_uint MQX1__mutatr_set_priority_ceiling(void* attr_ptr, void* priority);|_mqx_uint MQX1__mutatr_set_sched_protocol(void* attr_ptr, void* protocol);|_mqx_uint MQX1__mutatr_set_spin_limit(void* attr_ptr, void* spin_count);|_mqx_uint MQX1__mutatr_set_wait_protocol(void* attr_ptr, void* waiting_protocol);|_mqx_uint MQX1__mutatr_init(void* attr_ptr);|_mqx_uint MQX1__mutex_create_component(void);|_mqx_uint MQX1__mutex_destroy(void* mutex_ptr);|_mqx_uint MQX1__mutex_get_priority_ceiling(void* mutex_ptr, void* priority_ptr);|_mqx_uint MQX1__mutex_get_wait_count(void* mutex_ptr);|_mqx_uint MQX1__mutex_init(void* mutex_ptr, void* attr_ptr);|_mqx_uint MQX1__mutex_set_priority_ceiling(void* mutex_ptr, void* priority, void* old_priority_ptr);|_mqx_uint MQX1__mutex_test(void* mutex_error_ptr);|_mqx_uint MQX1__mutex_unlock(void* mutex_ptr);|_mqx_uint MQX1__mutex_try_lock(void* mutex_ptr);|_mem_size MQX1__lwlog_calculate_size(void* entries);|_mqx_uint MQX1__lwlog_create_at(void* log_number, void* max_size, void* flags, void* where);|_mqx_uint MQX1__lwlog_create_component(void);|_mqx_uint MQX1__lwlog_destroy(void* log_number);|_mqx_uint MQX1__lwlog_disable(void* log_number);|_mqx_uint MQX1__lwlog_enable(void* log_number);|_mqx_uint MQX1__lwlog_read(void* log_number, void* read_type, void* entry_ptr);|_mqx_uint MQX1__lwlog_reset(void* log_number);|_mqx_uint MQX1__lwlog_test(void* log_error_ptr);|_mqx_uint MQX1__lwlog_write(void* log_number, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7);|_mqx_uint MQX1__lwmsgq_init(void* location, void* num_message, void* msg_size);|_mqx_uint MQX1__lwmsgq_send(void* handle, void* message, void* flags);|_mqx_uint MQX1__lwmsgq_receive(void* handle, void* message, void* flags, void* ticks, void* tick_ptr);|_mqx_uint MQX1__lwtimer_add_timer_to_queue(void* period_ptr, void* timer_ptr, void* ticks, LWTIMER_ISR_FPTR function, void* parameter);|_mqx_uint MQX1__lwtimer_cancel_period(void* period_ptr);|_mqx_uint MQX1__lwtimer_cancel_timer(void* timer_ptr);|_mqx_uint MQX1__lwtimer_create_periodic_queue(void* timer_ptr, void* period, void* wait_ticks);|_mqx_uint MQX1__lwtimer_test(void* period_error_ptr, void* timer_error_ptr);|_mqx_uint MQX1__usr_lwevent_create(void* lwevent_group_ptr, void* flags);|_mqx_uint MQX1__usr_lwevent_destroy(void* wevent_group_ptr);|_mqx_uint MQX1__usr_lwevent_set_auto_clear(void* lwevent_group_ptr, void* auto_mask);|_mqx_uint MQX1__usr_lwevent_set(void* lwevent_group_ptr, void* flags);|_mqx_uint MQX1__usr_lwevent_clear(void* event_group_ptr, void* bit_mask);|_mqx_uint MQX1__usr_lwevent_wait_for(void* event_ptr, void* bit_mask, bool all, void* tick_ptr);|_mqx_uint MQX1__usr_lwevent_wait_ticks(void* event_ptr, void* bit_mask, bool all, void* timeout_in_ticks);|_mqx_uint MQX1__usr_lwevent_wait_until(void* event_ptr, void* bit_mask, bool all, void* tick_ptr);|_mqx_uint MQX1__usr_lwevent_get_signalled(void);|_mqx_uint MQX1__usr_lwsem_create(void* lwsem_ptr, void* initial_count);|_mqx_uint MQX1__usr_lwsem_destroy(void* lwsem_ptr);|_mqx_uint MQX1__usr_lwsem_poll(void* lwsem_ptr);|_mqx_uint MQX1__usr_lwsem_post(void* lwsem_ptr);|_mqx_uint MQX1__usr_lwsem_wait(void* sem_ptr);|_mqx_uint MQX1__usr_lwsem_wait_ticks(void* sem_ptr, void* tick_timeout);|_mqx_uint MQX1__usr_lwsem_wait_for(void* sem_ptr, void* tick_time_timeout_ptr);|_mqx_uint MQX1__usr_lwsem_wait_until(void* sem_ptr, void* tick_time_ptr);|_task_id MQX1__usr_task_create(void* processor_number, void* template_index, void* parameter);|_mqx_uint MQX1__usr_task_destroy(void* task_id);|_mqx_uint MQX1__usr_task_abort(void* task_id);|_mqx_uint MQX1__usr_task_set_error(void* error_code);|void* MQX1__usr_task_get_td(void* task_id);|void MQX1__usr_task_ready(void* td_ptr);|void MQX1__usr_time_delay(void* ms_delay);|void MQX1__usr_time_delay_ticks(void* tick_delay);|void MQX1__usr_time_get_elapsed_ticks(void* tick_time_ptr);|_mqx_uint MQX1__usr_lwmsgq_init(void);]
MethodList=[_int_default_isr|_int_disable|_int_enable|_int_exception_isr|_int_get_default_isr|_int_get_exception_handler|_int_get_isr|_int_get_isr_depth|_int_get_isr_data|_int_get_kernel_isr|_int_get_previous_vector_table|_int_get_vector_table|_int_install_default_isr|_int_install_kernel_isr|_int_install_isr|_int_install_exception_isr|_int_install_unexpected_isr|_int_kernel_isr|_int_set_exception_handler|_int_set_isr_data|_int_set_vector_table|_int_unexpected_isr|_klog_create_at|_klog_get_interrupt_stack_usage|_klog_get_task_stack_usage|_klog_control|_klog_disable_logging_task|_klog_display|_klog_enable_logging_task|_klog_show_stack_usage|_lwsem_create|_lwsem_destroy|_lwsem_poll|_lwsem_post|_lwsem_test|_lwsem_wait|_lwsem_wait_ticks|_lwsem_wait_for|_lwsem_wait_until|_mem_zero|_mem_test_and_set|_mqx_exit|_mqx_fatal_error|_mqx_get_counter|_mqx_get_cpu_type|_mqx_get_initialization|_mqx_get_kernel_data|_mqx_get_exit_handler|_mqx_get_system_task_id|_mqx_get_tad_data|_mqx_idle_task|_mqx_set_cpu_type|_mqx_set_exit_handler|_sched_get_max_priority|_sched_get_min_priority|_sched_yield|_task_abort|_task_block|_task_check_stack|_task_create_at|_task_destroy|_task_disable_fp|_task_enable_fp|_task_get_creator|_task_get_environment|_task_get_exception_handler|_task_get_error|_task_get_error_ptr|_task_get_exit_handler|_task_get_id_from_name|_task_get_index_from_id|_task_get_parameter|_task_get_parameter_for|_task_get_processor|_task_get_priority|_task_get_td|_task_get_template_index|_task_ready|_task_restart|_task_set_environment|_task_set_error|_task_set_exception_handler|_task_set_exit_handler|_task_set_parameter|_task_set_parameter_for|_task_set_priority|_task_stop_preemption|_task_start_preemption|_taskq_create|_taskq_destroy|_taskq_resume|_taskq_suspend|_taskq_suspend_task|_taskq_test|_taskq_get_value|_time_delay_ticks|_time_diff_ticks|_time_get_elapsed_ticks|_time_get_hwticks|_time_get_hwticks_per_tick|_time_get_ticks|_time_get_ticks_per_sec|_time_init_ticks|_time_notify_kernel|_time_set_hwtick_function|_time_set_hwticks_per_tick|_time_set_resolution|_time_set_ticks|_time_set_ticks_per_sec|_time_set_timer_vector|_lwevent_create|_lwevent_destroy|_lwevent_set|_lwevent_set_auto_clear|_lwevent_clear|_lwevent_wait_for|_lwevent_wait_ticks|_lwevent_wait_until|_lwevent_get_signalled|_lwevent_test|_mutatr_destroy|_mutatr_get_priority_ceiling|_mutatr_get_sched_protocol|_mutatr_get_spin_limit|_mutatr_get_wait_protocol|_mutatr_set_priority_ceiling|_mutatr_set_sched_protocol|_mutatr_set_spin_limit|_mutatr_set_wait_protocol|_mutatr_init|_mutex_create_component|_mutex_destroy|_mutex_get_priority_ceiling|_mutex_get_wait_count|_mutex_init|_mutex_set_priority_ceiling|_mutex_test|_mutex_unlock|_mutex_try_lock|_lwlog_calculate_size|_lwlog_create_at|_lwlog_create_component|_lwlog_destroy|_lwlog_disable|_lwlog_enable|_lwlog_read|_lwlog_reset|_lwlog_test|_lwlog_write|_lwmsgq_init|_lwmsgq_send|_lwmsgq_receive|_lwtimer_add_timer_to_queue|_lwtimer_cancel_period|_lwtimer_cancel_timer|_lwtimer_create_periodic_queue|_lwtimer_test|_usr_lwevent_create|_usr_lwevent_destroy|_usr_lwevent_set_auto_clear|_usr_lwevent_set|_usr_lwevent_clear|_usr_lwevent_wait_for|_usr_lwevent_wait_ticks|_usr_lwevent_wait_until|_usr_lwevent_get_signalled|_usr_lwsem_create|_usr_lwsem_destroy|_usr_lwsem_poll|_usr_lwsem_post|_usr_lwsem_wait|_usr_lwsem_wait_ticks|_usr_lwsem_wait_for|_usr_lwsem_wait_until|_usr_task_create|_usr_task_destroy|_usr_task_abort|_usr_task_set_error|_usr_task_get_td|_usr_task_ready|_usr_time_delay|_usr_time_delay_ticks|_usr_time_get_elapsed_ticks|_usr_lwmsgq_init]
runSpeedMode=[Yes]

GLOBAL SYMBOLS (alphabet order)
-------------------------------
ADC0AsynchroClockAddr=1073983496
ADC0AsynchroClockReg=ADC0_CFG1
ADC0BusClockAddr=1073983496
ADC0BusClockReg=ADC0_CFG1
ADC0ClkSelAddr=1073983496
ADC0ClkSelReg=ADC0_CFG1
ActiveConfigIdentifier=PEcfg_FLASH
ActiveConfiguration=FLASH
CPUDB_BUS_FREQ_HZ_MAX=24000000
CPUDB_CPU_MASTER=MKL25Z4
CPUDB_CW_MCU_ID=28695
CPUDB_CW_MCU_NAME=MKL25Z128xxx4
CPUDB_LQFP80=-1
CPUDB_MKL25Z128xxx4=-1
CPUDB_MKL25Z4=-1
CPUDB_PACKAGE=LQFP80
CPUDB_PLL_INPUT_FREQ_HZ_MAX=4000000
CPUDB_PLL_INPUT_FREQ_HZ_MIN=2000000
CPUDB_PLL_OUTPUT_FREQ_HZ_MAX=100000000
CPUDB_PLL_OUTPUT_FREQ_HZ_MIN=48000000
CPUDB_ProgramFlashBlockCount=1
CPUDB_ProgramFlashEraseUnitSize=1024
CPUDB_ProgramFlashSize=131072
CPUDB_ProgramFlashWriteUnitSize=4
CPUDB_SYSTEM_FREQ_HZ_MAX=48000000
CPU_DB_version=3.00.000
CPUendian=little
CPUfamily=Kinetis
CPUproducer=Freescale
CPUrunSpeedModeNum=1
CPUsubFamily=MKL25
CPUtype=MKL25Z128LK4
CPUvariant=MKL25Z128VLK4
ClientDir_Binary=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\MKL25Z128\USB_MSD_DEVICE_MQX_Lite_MKL25Z128_PEx\Sources\
ClientDir_Code=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\MKL25Z128\USB_MSD_DEVICE_MQX_Lite_MKL25Z128_PEx\Generated_Code\
ClientDir_PE=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\
ClientDir_Project=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\MKL25Z128\USB_MSD_DEVICE_MQX_Lite_MKL25Z128_PEx\
CommentBrackets=/**/
Compiler=GNUC
CompilerID=GNU C Compiler
DirRel_Binary=Sources\
DirRel_BinaryToEvents=
DirRel_Code=Generated_Code\
DirRel_Docs=Documentation\
DirRel_EventToBinary=
DirRel_Events=Sources\
DirRel_ProjectSettings=Project_Settings\
EclipseProjectName=USB_MSD_DEVICE_MQX_Lite_MKL25Z128_PEx
InterruptTableType=ROM
Language=ANSIC
Not_for_MPC512x=
OnChipEEPROM=0
OnChipFLASH=131072
OnChipRAM=16384
OperatingSystemId=MQXLite
PE_DEBUG=
PE_DEVELOPMENT=
PE_ECLIPSE=
PE_GENERATING=
PE_G_4PEx_ToolChain_Linker_EntryPoint=__boot
PE_G_CPUCFG_AutoIncludeIO_Map=yes
PE_G_CPUCFG_EntryPointFunctionName=__init_hardware
PE_G_CPUCFG_EntryPointFunctionReturn=
PE_G_CPUCFG_EntryPointFunctionReturnType=void __attribute__ ((constructor))
PE_G_CPUCFG_GenerateLinkerFile=yes
PE_G_CPUCFG_GenerateMainModule=yes
PE_G_CPUCFG_InitIntVectorTableSym=yes
PE_G_CPUCFG_ManageInterruptVectorTable=yes
PE_G_GenBitMask=
PE_G_InternalMethodDescriptionNotFound=
PE_G_MisraCnfBackParams_0=
PE_G_MisraCnfParams_0=
PE_G_MisraRuleList_0=
PE_G_MisraStackIdx=-1
PE_G_NO_SETREGMACROS=
PE_G_RTOSAdap_P_RTOSFun_EnterCritical=_int_disable
PE_G_RTOSAdap_P_RTOSFun_ExitCritical=_int_enable
PE_G_RTOSAdap_regCompIndex=0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventEnabled_OnCounterRestart=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel0=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel1=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel2=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel3=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel4=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel5=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel6=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel7=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnCounterRestart=(void (*)(LDD_TUserData *UserDataPtr))&SystemTimer1_SystemTimer1_OnCounterRestart
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_Deinit=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_Enable=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_GetCounterValue=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_GetInputFrequency=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_GetPeriodTicks=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_Init=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_ResetCounter=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_SetPeriodTicks=
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_ConnectPin=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask PinMask))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Deinit=(void (*)(LDD_TDeviceData *DeviceDataPtr))&SystemTimer1_Deinit
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Disable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Enable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&SystemTimer1_Enable
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetCaptureValue=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, SystemTimer1_TValueType *ValuePtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetCounterValue=(SystemTimer1_TValueType (*)(LDD_TDeviceData *DeviceDataPtr))&SystemTimer1_GetCounterValue
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetDriverState=(LDD_TDriverState (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetEventMask=(LDD_TEventMask (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetEventStatus=(LDD_TEventMask (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetInputFrequency=(uint32_t (*)(LDD_TDeviceData *DeviceDataPtr))&SystemTimer1_GetInputFrequency
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetInputFrequencyReal=(LDD_TimerUnit_Tfloat (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetOffsetTicks=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, SystemTimer1_TValueType *TicksPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetPeriodTicks=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, SystemTimer1_TValueType *TicksPtr))&SystemTimer1_GetPeriodTicks
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Init=(LDD_TDeviceData* (*)(LDD_TUserData *UserDataPtr))&SystemTimer1_Init
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_ResetCounter=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&SystemTimer1_ResetCounter
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SelectCaptureEdge=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, LDD_TimerUnit_TEdge Edge))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SelectInputFrequency=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, SystemTimer1_TClockList InputFrequency))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SelectOutputAction=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, LDD_TimerUnit_TOutAction CompareAction, LDD_TimerUnit_TOutAction CounterAction))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetEventMask=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetOffsetTicks=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, SystemTimer1_TValueType Ticks))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetOperationMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr))0
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetPeriodTicks=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, SystemTimer1_TValueType Ticks))&SystemTimer1_SetPeriodTicks
PE_G_USE_UINTXX_T=
PE_ProductVersion=10.0
PEversion=05.03
PEversionDecimal=1283
ProcessorModule=Cpu
ProcessorName=Cpu
ProjectModule=ProcessorExpert
ProjectName=ProcessorExpert
ServerDir_PE=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\
SetHighSpeedMode=
SupportedCPUfamily=
TimeStamp=2012-11-19, 17:40, # CodeGen: 9
Xtal_kHz=4000
Xtal_kHz_real=4000
ivINT_ADC0=_int_kernel_isr
ivINT_CMP0=_int_kernel_isr
ivINT_DAC0=_int_kernel_isr
ivINT_DMA0=_int_kernel_isr
ivINT_DMA1=_int_kernel_isr
ivINT_DMA2=_int_kernel_isr
ivINT_DMA3=_int_kernel_isr
ivINT_FTFA=_int_kernel_isr
ivINT_I2C0=_int_kernel_isr
ivINT_I2C1=_int_kernel_isr
ivINT_Initial_Program_Counter=__boot
ivINT_LLW=_int_kernel_isr
ivINT_LPTimer=_int_kernel_isr
ivINT_LVD_LVW=_int_kernel_isr
ivINT_MCG=_int_kernel_isr
ivINT_PIT=_int_kernel_isr
ivINT_PORTA=_int_kernel_isr
ivINT_PORTD=_int_kernel_isr
ivINT_RTC=_int_kernel_isr
ivINT_RTC_Seconds=_int_kernel_isr
ivINT_Reserved20=_int_kernel_isr
ivINT_Reserved39=_int_kernel_isr
ivINT_Reserved45=_int_kernel_isr
ivINT_SPI0=_int_kernel_isr
ivINT_SPI1=_int_kernel_isr
ivINT_SysTick=_int_kernel_isr
ivINT_TPM0=_int_kernel_isr
ivINT_TPM1=_int_kernel_isr
ivINT_TPM2=_int_kernel_isr
ivINT_TSI0=_int_kernel_isr
ivINT_UART0=_int_kernel_isr
ivINT_UART1=_int_kernel_isr
ivINT_UART2=_int_kernel_isr
ivINT_USB0=_int_kernel_isr
virtual_ADC0_TotalConversionPrescalerAddr=1073983496
virtual_ADC0_TotalConversionPrescalerReg=ADC0_CFG1

 DEPRECATED GLOBAL SYMBOLS (alphabet order)
-------------------------------------------
ADC0AsynchroClockAddr=null
ADC0AsynchroClockReg=null
ADC0BusClockAddr=null
ADC0BusClockReg=null
ADC0ClkSelAddr=null
ADC0ClkSelReg=null
ActiveConfigIdentifier=null
ActiveConfiguration=null
CPUDB_BUS_FREQ_HZ_MAX=null
CPUDB_CPU_MASTER=null
CPUDB_CW_MCU_ID=null
CPUDB_CW_MCU_NAME=null
CPUDB_LQFP80=null
CPUDB_MKL25Z128xxx4=null
CPUDB_MKL25Z4=null
CPUDB_PACKAGE=null
CPUDB_PLL_INPUT_FREQ_HZ_MAX=null
CPUDB_PLL_INPUT_FREQ_HZ_MIN=null
CPUDB_PLL_OUTPUT_FREQ_HZ_MAX=null
CPUDB_PLL_OUTPUT_FREQ_HZ_MIN=null
CPUDB_ProgramFlashBlockCount=null
CPUDB_ProgramFlashEraseUnitSize=null
CPUDB_ProgramFlashSize=null
CPUDB_ProgramFlashWriteUnitSize=null
CPUDB_SYSTEM_FREQ_HZ_MAX=null
CPU_DB_version=null
CPUendian=null
CPUfamily=null
CPUproducer=null
CPUrunSpeedModeNum=null
CPUsubFamily=null
CPUtype=null
CPUvariant=null
ClientDir_Binary=null
ClientDir_Code=null
ClientDir_PE=null
ClientDir_Project=null
CommentBrackets=null
Compiler=null
CompilerID=null
DirRel_Binary=null
DirRel_BinaryToEvents=null
DirRel_Code=null
DirRel_Docs=null
DirRel_EventToBinary=null
DirRel_Events=null
DirRel_ProjectSettings=null
EclipseProjectName=null
InterruptTableType=null
Language=null
Not_for_MPC512x=null
OnChipEEPROM=null
OnChipFLASH=null
OnChipRAM=null
OperatingSystemId=null
PE_DEBUG=null
PE_DEVELOPMENT=null
PE_ECLIPSE=null
PE_GENERATING=null
PE_G_4PEx_ToolChain_Linker_EntryPoint=null
PE_G_CPUCFG_AutoIncludeIO_Map=null
PE_G_CPUCFG_EntryPointFunctionName=null
PE_G_CPUCFG_EntryPointFunctionReturn=null
PE_G_CPUCFG_EntryPointFunctionReturnType=null
PE_G_CPUCFG_GenerateLinkerFile=null
PE_G_CPUCFG_GenerateMainModule=null
PE_G_CPUCFG_InitIntVectorTableSym=null
PE_G_CPUCFG_ManageInterruptVectorTable=null
PE_G_GenBitMask=null
PE_G_InternalMethodDescriptionNotFound=null
PE_G_MisraCnfBackParams_0=null
PE_G_MisraCnfParams_0=null
PE_G_MisraRuleList_0=null
PE_G_MisraStackIdx=null
PE_G_NO_SETREGMACROS=null
PE_G_RTOSAdap_P_RTOSFun_EnterCritical=null
PE_G_RTOSAdap_P_RTOSFun_ExitCritical=null
PE_G_RTOSAdap_regCompIndex=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventEnabled_OnCounterRestart=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel0=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel1=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel2=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel3=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel4=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel5=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel6=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnChannel7=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_eventPtr_OnCounterRestart=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_Deinit=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_Enable=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_GetCounterValue=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_GetInputFrequency=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_GetPeriodTicks=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_Init=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_ResetCounter=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodEnabled_SetPeriodTicks=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_ConnectPin=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Deinit=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Disable=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Enable=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetCaptureValue=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetCounterValue=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetDriverState=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetEventMask=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetEventStatus=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetInputFrequency=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetInputFrequencyReal=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetOffsetTicks=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_GetPeriodTicks=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_Init=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_ResetCounter=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SelectCaptureEdge=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SelectInputFrequency=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SelectOutputAction=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetEventMask=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetOffsetTicks=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetOperationMode=null
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methodPtr_SetPeriodTicks=null
PE_G_USE_UINTXX_T=null
PE_ProductVersion=null
PEversion=null
PEversionDecimal=null
ProcessorModule=null
ProcessorName=null
ProjectModule=null
ProjectName=null
ServerDir_PE=null
SetHighSpeedMode=null
SupportedCPUfamily=null
TimeStamp=null
Xtal_kHz=null
Xtal_kHz_real=null
ivINT_ADC0=null
ivINT_CMP0=null
ivINT_DAC0=null
ivINT_DMA0=null
ivINT_DMA1=null
ivINT_DMA2=null
ivINT_DMA3=null
ivINT_FTFA=null
ivINT_I2C0=null
ivINT_I2C1=null
ivINT_Initial_Program_Counter=null
ivINT_LLW=null
ivINT_LPTimer=null
ivINT_LVD_LVW=null
ivINT_MCG=null
ivINT_PIT=null
ivINT_PORTA=null
ivINT_PORTD=null
ivINT_RTC=null
ivINT_RTC_Seconds=null
ivINT_Reserved20=null
ivINT_Reserved39=null
ivINT_Reserved45=null
ivINT_SPI0=null
ivINT_SPI1=null
ivINT_SysTick=null
ivINT_TPM0=null
ivINT_TPM1=null
ivINT_TPM2=null
ivINT_TSI0=null
ivINT_UART0=null
ivINT_UART1=null
ivINT_UART2=null
ivINT_USB0=null
virtual_ADC0_TotalConversionPrescalerAddr=null
virtual_ADC0_TotalConversionPrescalerReg=null

 GLOBAL LISTS (alphabet order)
-------------------------------------------
ADC0AsynchroClock=[1]
ADC0AsynchroClock_Setting=[ADC0Async_FullPower_HighSpeed]
ADC0BusClock=[1]
ADC0BusClock_Setting=[1]
ADC0ClkSel=[1]
ADC0ClkSel_Setting=[ADC0BusClock]
COPClkSelect=[1]
COPClkSelect_Setting=[COPBusClock]
ERCLK32KSel=[1]
ERCLK32KSel_Setting=[SYSTEM_OSC]
EventModuleList=[Events|mqx_tasks]
I2C0_LoTimeoutClkSel=[1]
I2C0_LoTimeoutClkSel_Setting=[I2C0_LoTimeout_BusClkDiv64]
I2C1_LoTimeoutClkSel=[1]
I2C1_LoTimeoutClkSel_Setting=[I2C1_LoTimeout_BusClkDiv64]
IRCLKSel=[1]
IRCLKSel_Setting=[IRC_32kHz]
IncludeSharedModules=[PE_Types|PE_Error|PE_Const|IO_Map]
InstructionClock=[undef]
LPTMR0_ClockSelect=[1]
LPTMR0_ClockSelect_Setting=[ERCLK]
MCGOUTSel=[1]
MCGOUTSel_Setting=[MCGPLLCLK]
MCG_FLL_MFactor=[640]
MCG_FLL_MFactor_Setting=[640]
MCG_FLL_RCLKSel=[1]
MCG_FLL_RCLKSel_Setting=[MCG_FRDIV]
MCG_FRDIV=[256]
MCG_FRDIV_Setting=[256]
MCG_PRDIV=[2]
MCG_PRDIV_Setting=[2]
MCG_VDIV=[24]
MCG_VDIV_Setting=[24]
ModuleList=[MQX1|SystemTimer1|usb_device|USB_LDD]
OUTDIV1Presc=[2]
OUTDIV1Presc_Setting=[2]
OUTDIV4Presc=[2]
OUTDIV4Presc_Setting=[2]
PE_G_4PEx_ToolChain_Asm_SearchUserPaths=["${ProjDirPath}/MQXLITE/include"|"${ProjDirPath}/MQXLITE/kernel"|"${ProjDirPath}/MQXLITE/psp/cortex_m"|"${ProjDirPath}/MQXLITE/psp/cortex_m/core/M0"|"${ProjDirPath}/MQXLITE/psp/cortex_m/compiler/gccarm"]
PE_G_4PEx_ToolChain_Compiler_SearchUserPaths=["${ProjDirPath}/MQXLITE/include"|"${ProjDirPath}/MQXLITE/kernel"|"${ProjDirPath}/MQXLITE/psp/cortex_m"|"${ProjDirPath}/MQXLITE/psp/cortex_m/core/M0"|"${ProjDirPath}/MQXLITE/psp/cortex_m/compiler/gccarm"]
PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT=[/* MQX Lite component BEGIN */|* (KERNEL)|__VECTOR_TABLE_START = __vector_table;|. = ALIGN(0x4);|*(.rdata)|. = ALIGN(0x4);|*(.exception)|. = ALIGN(0x4);|__exception_table_start__ = .;|/* EXCEPTION */|__exception_table_end__ = .;|__sinit__ = .;|/* STATICINIT */|/* MQX Lite component END */]
PE_G_RTOSAdap_regCompInstanceAllocatedDevices=[SysTick]
PE_G_RTOSAdap_regCompInstanceDeviceBaseAddrs=[3758153744]
PE_G_RTOSAdap_regCompInstanceIds=[0]
PE_G_RTOSAdap_regCompInstanceNames=[SystemTimer1]
PE_G_RTOSAdap_regCompInstanceSharedComponentName=[SystemTimer1]
PE_G_RTOSAdap_regCompInstanceTypes=[TimerUnit_LDD]
PE_G_RTOSAdap_regCompInstance_SystemTimer1_events=[OnCounterRestart|OnChannel0|OnChannel1|OnChannel2|OnChannel3|OnChannel4|OnChannel5|OnChannel6|OnChannel7]
PE_G_RTOSAdap_regCompInstance_SystemTimer1_methods=[Init|Deinit|Enable|Disable|SetEventMask|GetEventMask|GetEventStatus|SelectInputFrequency|GetInputFrequencyReal|GetInputFrequency|SetPeriodTicks|GetPeriodTicks|ResetCounter|GetCounterValue|SetOffsetTicks|GetOffsetTicks|GetCaptureValue|SelectOutputAction|SelectCaptureEdge|ConnectPin|SetOperationMode|GetDriverState]
PLLFLLSel=[1]
PLLFLLSel_Setting=[MCGPLLCLKDIV2]
SPI0_BaudRatePrescDiv=[1]
SPI0_BaudRatePrescDiv_Setting=[1]
SPI1_BaudRatePrescDiv=[1]
SPI1_BaudRatePrescDiv_Setting=[1]
SharedModules=[Kinetis\PE_Types.drv|Kinetis\PE_Error.drv|Kinetis\PE_Const.drv|Kinetis\IO_Map.drv]
SpeedModeList=[SpeedMode0]
SpeedModeNames=[SpeedMode0|SpeedMode1|SpeedMode2|SpeedMode3|SpeedMode4|SpeedMode5|SpeedMode6|SpeedMode7]
SystemPrescaler=[1]
SystemPrescaler_Setting=[1]
TPMClk=[1]
TPMClk_Setting=[PLLFLLSelDistr]
UART0_ClkSel=[1]
UART0_ClkSel_Setting=[PLLFLLSelDistr]
UART0_Divider=[4]
UART0_Divider_Setting=[4]
USB0_ClkSel=[1]
USB0_ClkSel_Setting=[USB0_PLLFLL0]
virtual_ADC0_TotalConversionPrescaler=[1]
virtual_ADC0_TotalConversionPrescaler_Setting=[1]

{{DEVELOPMENT}} --------(((DEBUGINFO)))--------.{{DEVELOPMENT}} 

