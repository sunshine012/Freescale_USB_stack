/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : usb_host_audio.c
**     Project     : ProcessorExpert
**     Processor   : MK60DN512ZVLQ10
**     Component   : USB_AUDIO_CLASS
**     Version     : Component 01.000, Driver 01.00, CPU db: 3.00.001
**     Compiler    : CodeWarrior ARM C Compiler
**     Date/Time   : 2012-11-19, 11:52, # CodeGen: 191
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         usb_class_audio_init_ipipe                 - USB_STATUS usb_host_audio_usb_class_audio_init_ipipe(CLASS_CALL_STRUCT_PTR...
**         usb_audio_recv_data                        - USB_STATUS usb_host_audio_usb_audio_recv_data(CLASS_CALL_STRUCT_PTR...
**         usb_audio_send_data                        - USB_STATUS usb_host_audio_usb_audio_send_data(CLASS_CALL_STRUCT_PTR...
**         usb_class_audio_get_copy_protect           - USB_STATUS usb_host_audio_usb_class_audio_get_copy_protect(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_copy_protect           - USB_STATUS usb_host_audio_usb_class_audio_set_copy_protect(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_mute               - USB_STATUS usb_host_audio_usb_class_audio_get_cur_mute(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_mute               - USB_STATUS usb_host_audio_usb_class_audio_set_cur_mute(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_volume             - USB_STATUS usb_host_audio_usb_class_audio_get_cur_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_volume             - USB_STATUS usb_host_audio_usb_class_audio_set_cur_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_min_volume             - USB_STATUS usb_host_audio_usb_class_audio_get_min_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_min_volume             - USB_STATUS usb_host_audio_usb_class_audio_set_min_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_max_volume             - USB_STATUS usb_host_audio_usb_class_audio_get_max_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_res_volume             - USB_STATUS usb_host_audio_usb_class_audio_get_res_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_max_volume             - USB_STATUS usb_host_audio_usb_class_audio_set_max_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_res_volume             - USB_STATUS usb_host_audio_usb_class_audio_set_res_volume(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_bass               - USB_STATUS usb_host_audio_usb_class_audio_get_cur_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_bass               - USB_STATUS usb_host_audio_usb_class_audio_set_cur_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_min_bass               - USB_STATUS usb_host_audio_usb_class_audio_get_min_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_min_bass               - USB_STATUS usb_host_audio_usb_class_audio_set_min_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_max_bass               - USB_STATUS usb_host_audio_usb_class_audio_set_max_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_max_bass               - USB_STATUS usb_host_audio_usb_class_audio_get_max_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_res_bass               - USB_STATUS usb_host_audio_usb_class_audio_get_res_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_mid                - USB_STATUS usb_host_audio_usb_class_audio_get_cur_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_res_bass               - USB_STATUS usb_host_audio_usb_class_audio_set_res_bass(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_mid                - USB_STATUS usb_host_audio_usb_class_audio_set_cur_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_min_mid                - USB_STATUS usb_host_audio_usb_class_audio_get_min_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_min_mid                - USB_STATUS usb_host_audio_usb_class_audio_set_min_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_max_mid                - USB_STATUS usb_host_audio_usb_class_audio_get_max_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_max_mid                - USB_STATUS usb_host_audio_usb_class_audio_set_max_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_res_mid                - USB_STATUS usb_host_audio_usb_class_audio_get_res_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_res_mid                - USB_STATUS usb_host_audio_usb_class_audio_set_res_mid(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_treble             - USB_STATUS usb_host_audio_usb_class_audio_get_cur_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_treble             - USB_STATUS usb_host_audio_usb_class_audio_set_cur_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_min_treble             - USB_STATUS usb_host_audio_usb_class_audio_get_min_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_min_treble             - USB_STATUS usb_host_audio_usb_class_audio_set_min_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_max_treble             - USB_STATUS usb_host_audio_usb_class_audio_get_max_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_max_treble             - USB_STATUS usb_host_audio_usb_class_audio_set_max_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_res_treble             - USB_STATUS usb_host_audio_usb_class_audio_get_res_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_res_treble             - USB_STATUS usb_host_audio_usb_class_audio_set_res_treble(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_min_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_cur_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_min_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_max_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_max_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_res_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_res_graphic_eq         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_cur_automatic_gain     - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_cur_automatic_gain     - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_cur_delay              - USB_STATUS usb_host_audio_usb_class_audio_get_cur_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_delay              - USB_STATUS usb_host_audio_usb_class_audio_set_cur_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_min_delay              - USB_STATUS usb_host_audio_usb_class_audio_get_min_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_min_delay              - USB_STATUS usb_host_audio_usb_class_audio_set_min_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_max_delay              - USB_STATUS usb_host_audio_usb_class_audio_get_max_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_max_delay              - USB_STATUS usb_host_audio_usb_class_audio_set_max_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_res_delay              - USB_STATUS usb_host_audio_usb_class_audio_get_res_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_res_delay              - USB_STATUS usb_host_audio_usb_class_audio_set_res_delay(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_cur_bass_boost         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_cur_bass_boost         - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_cur_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_cur_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_min_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_min_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_max_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_max_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_res_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_set_res_sampling_frequency - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_get_cur_pitch              - USB_STATUS usb_host_audio_usb_class_audio_get_cur_pitch(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_cur_pitch              - USB_STATUS usb_host_audio_usb_class_audio_set_cur_pitch(AUDIO_COMMAND_PTR...
**         usb_class_audio_get_mem_endpoint           - USB_STATUS usb_host_audio_usb_class_audio_get_mem_endpoint(AUDIO_COMMAND_PTR...
**         usb_class_audio_set_mem_endpoint           - USB_STATUS usb_host_audio_usb_class_audio_set_mem_endpoint(AUDIO_COMMAND_PTR...
**         usb_class_audio_control_init               - void usb_host_audio_usb_class_audio_control_init(PIPE_BUNDLE_STRUCT_PTR...
**         usb_class_audio_stream_init                - void usb_host_audio_usb_class_audio_stream_init(PIPE_BUNDLE_STRUCT_PTR...
**         usb_class_audio_get_ctrl_interface         - CLASS_CALL_STRUCT_PTR usb_host_audio_usb_class_audio_get_ctrl_interface(void*...
**         usb_class_audio_control_get_descriptors    - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_stream_get_descriptors     - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_control_set_descriptors    - USB_STATUS usb_host_audio_usb_class_aud...
**         usb_class_audio_stream_set_descriptors     - USB_STATUS usb_host_audio_usb_class_aud...
**
**     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE usb_host_audio. */

#include "usb_host_audio.h"

static void usb_class_audio_cntrl_callback(pointer, pointer, uchar_ptr, uint_32, USB_STATUS);
static USB_STATUS check_valid_fu(USB_AUDIO_CTRL_DESC_FU_PTR,uint_8,uint_8);
static USB_STATUS check_valid_ep(USB_AUDIO_STREAM_DESC_SPECIFIC_ISO_ENDP_PTR,uint_8);

/*FUNCTION*----------------------------------------------------------------
*
* Function Name  : usb_class_audio_cntrl_callback
* Returned Value : USB_OK if command has been passed on USB.
* Comments       :
*     This is the callback used when audio control information is sent or received.
*
*END*--------------------------------------------------------------------*/
static void usb_class_audio_cntrl_callback
(
/* [IN] Unused */
pointer     pipe,

/* [IN] Pointer to the class interface instance */
pointer     param,

/* [IN] Data buffer */
uchar_ptr   buffer,

/* [IN] Length of buffer */
uint_32     len,

/* [IN] Error code (if any) */
USB_STATUS  status
)
{ /* Body */
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR      if_ptr;

    /*
    ** There is no need for USB_lock in the callback function, and there is also no
    ** need to check if the device is still attached (otherwise this callback
    ** would never have been called!
    */
    /* Get class interface handle, reset IN_SETUP and call callback */
    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)param;

    if (if_ptr->AUDIO_G.USER_CALLBACK) {
        if_ptr->AUDIO_G.USER_CALLBACK(pipe, if_ptr->AUDIO_G.USER_PARAM, buffer, len, status);
    } /* Endif */

} /* Endbody */

/*FUNCTION*----------------------------------------------------------------
*
* Function Name  : usb_class_audio_cntrl_common
* Returned Value : USB_OK if command has been passed on USB.
* Comments       :
*     This function is used to send a control request.
*     It must be run with USB locked.
*
*END*--------------------------------------------------------------------*/
static USB_STATUS usb_class_audio_cntrl_common
(
/* [IN] The communication device common command structure */
AUDIO_COMMAND_PTR           com_ptr,

/* [IN] Bitmask of the request type */
uint_8                    bmrequesttype,

/* [IN] Request code */
uint_8                    brequest,

/* [IN] Value to copy into WVALUE field of the REQUEST */
uint_16                   wvalue,

/* [IN] Value to copy into WINDEX field of the REQUEST */
uint_16                                   wIndex,

/* [IN] Length of the data associated with REQUEST */
uint_16                   wlength,

/* [IN] Pointer to data buffer used to send/recv */
uchar_ptr                 data
)
{ /* Body */
    USB_AUDIO_GENERAL_CLASS_PTR        if_ptr;
    USB_SETUP                        req;
    USB_STATUS                       status = USBERR_NO_INTERFACE;

    if_ptr = (USB_AUDIO_GENERAL_CLASS_PTR) com_ptr->CLASS_PTR->class_intf_handle;

    /* Save the higher level callback and ID */
    if_ptr->USER_CALLBACK = com_ptr->CALLBACK_FN;
    if_ptr->USER_PARAM = com_ptr->CALLBACK_PARAM;

    /* Setup the request */
    req.BMREQUESTTYPE = bmrequesttype;
    req.BREQUEST = brequest;
    htou16(req.WINDEX, wIndex);
    htou16(req.WVALUE, wvalue);
    htou16(req.WLENGTH, wlength);
    if (USB_STATUS_TRANSFER_QUEUED == (status = _usb_hostdev_cntrl_request(if_ptr->G.dev_handle, &req, data,
                    usb_class_audio_cntrl_callback, if_ptr)))
    status = USB_OK;

    return status;
} /* Endbody */

/*FUNCTION*----------------------------------------------------------------
*
* Function Name  : check_valid_fu
* Returned Value : None
* Comments       :
*     Check whether attribute of feature valid or not.
*
*END*--------------------------------------------------------------------*/
static USB_STATUS check_valid_fu
(
/* [IN] pointer to feature unit */
USB_AUDIO_CTRL_DESC_FU_PTR fu_ptr,

/* [IN] Control mask */
uint_8 control_mask,

uint_8 atribute_index
)
{
    USB_STATUS status=USBERR_ERROR;

    if (NULL!=fu_ptr)
    {
        if(atribute_index<fu_ptr->bControlSize)
        {
            if (fu_ptr->bmaControls[atribute_index] & control_mask)
            {
                status=USB_OK;
            }
        }
    }
    return status;
}

/*FUNCTION*----------------------------------------------------------------
*
* Function Name  : check_valid_ep
* Returned Value : None
* Comments       :
*     Check whether attribute of endpoint valid or not.
*
*END*--------------------------------------------------------------------*/
static USB_STATUS check_valid_ep
(
/* [IN] pointer to isochonounous endpoint */
USB_AUDIO_STREAM_DESC_SPECIFIC_ISO_ENDP_PTR ep_ptr,

/* [IN] control selector */
uint_8 control_selector
)
{
    USB_STATUS status=USBERR_ERROR;

    if (NULL!=ep_ptr)
    {
        if (ep_ptr->bmAttributes && control_selector)
        status=USB_OK;
        else
        status=USBERR_INVALID_REQ_TYPE;
    }

    return status;
}

/*FUNCTION*----------------------------------------------------------------
*
* Function Name  : usb_class_audio_int_callback
* Returned Value : None
* Comments       :
*     Called on interrupt endpoint data reception.
*
*END*--------------------------------------------------------------------*/
static void usb_class_audio_int_callback
(
/* [IN] pointer to pipe */
_usb_pipe_handle  pipe,

/* [IN] user-defined parameter */
pointer           param,

/* [IN] buffer address */
pointer           buffer,

/* [IN] length of data transferred */
uint_32           len,

/* [IN] status, hopefully USB_OK or USB_DONE */
uint_32           status
)
{ /* Body */
    CLASS_CALL_STRUCT_PTR         audio_instance = (CLASS_CALL_STRUCT_PTR) param;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR if_ptr;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR) audio_instance->class_intf_handle;
    if (NULL!=pipe)
    {
        if_ptr->interrupt_callback(pipe,param,buffer,len,status);
    }
    usb_class_audio_init_ipipe(audio_instance,if_ptr->interrupt_callback,if_ptr->interrupt_callback_param);
} /*EndBody */

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_init_ipipe (component USB_AUDIO_CLASS)
**
**     Description :
**         Starts interrupt endpoint to poll for interrupt on specified
**         device.
**     Parameters  :
**         NAME            - DESCRIPTION
**         audio_instance  - ACM interface
**                           instance
**         user_callback   - Callback to application
**       * user_callback_param - Callback
**                           parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_init_ipipe(CLASS_CALL_STRUCT_PTR audio_instance, tr_callback user_callback, void* user_callback_param)
{
    /* Body */
    TR_INIT_PARAM_STRUCT           tr;
    USB_STATUS                     status = USBERR_NO_INTERFACE;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR  if_ptr;

    USB_lock();
    /* Validity checking, always needed when passing data to lower API */
    if (usb_host_class_intf_validate(audio_instance)) {
        if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR) audio_instance->class_intf_handle;
        if_ptr->interrupt_callback = user_callback;
        if_ptr->interrupt_callback_param = user_callback_param;
        if (if_ptr->interrupt_pipe != NULL) {
            usb_hostdev_tr_init(&tr, (tr_callback) usb_class_audio_int_callback, (pointer) audio_instance);
            tr.RX_BUFFER = (uchar_ptr) &if_ptr->interrupt_buffer;
            tr.RX_LENGTH = sizeof(if_ptr->interrupt_buffer);
            if (USB_STATUS_TRANSFER_QUEUED == (status = _usb_host_recv_data(
                            if_ptr->AUDIO_G.G.host_handle,
                            if_ptr->interrupt_pipe,
                            &tr
                            )))
            {
                status = USB_OK;
            }
        }
        else
        status = USBERR_OPEN_PIPE_FAILED;
    }/* Endif */
    USB_unlock();

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_audio_recv_data (component USB_AUDIO_CLASS)
**
**     Description :
**         Receive data on isochronous IN pipe.
**     Parameters  :
**         NAME            - DESCRIPTION
**         control_ptr     - [IN] class-interface
**                           control pointer
**         stream_ptr      - [IN] class-interface stream
**                           pointer
**         callback        - [IN] callback upon completion
**       * call_parm       - [IN] user parameter returned
**                           by callback
**         buf_size        - [IN] data length
**         buffer          - [IN] buffer pointer
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_audio_recv_data(CLASS_CALL_STRUCT_PTR control_ptr, CLASS_CALL_STRUCT_PTR stream_ptr, tr_callback callback, void* call_parm, uint_32 buf_size, uchar_ptr buffer)
{
    /* Body */
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         stream_if_ptr;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         control_if_ptr;
    TR_INIT_PARAM_STRUCT                           tr;
    USB_STATUS                                     status = USBERR_NO_INTERFACE;

    USB_lock();
    /* Validity checking, always needed when passing data to lower API */
    if (!usb_host_class_intf_validate(control_ptr)) {
        USB_unlock();
        return USBERR_NO_INTERFACE;
    }
    stream_if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR) stream_ptr->class_intf_handle;
    control_if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR) control_ptr->class_intf_handle;

    /* Do the device use OUT pipe? */
    if (stream_if_ptr->iso_in_pipe == NULL) {
        USB_unlock();
        return USBERR_OPEN_PIPE_FAILED;
    }

    /* Validity checking, always needed when passing data to lower API */
    if (!usb_host_class_intf_validate(control_ptr)) {
        USB_unlock();
        return USBERR_NO_INTERFACE;
    }
    usb_hostdev_tr_init(&tr, (tr_callback) callback, (pointer) call_parm);
    tr.RX_BUFFER = (uchar_ptr) buffer;
    tr.RX_LENGTH = buf_size;
    status = _usb_host_recv_data(control_if_ptr->AUDIO_G.G.host_handle,
    stream_if_ptr->iso_in_pipe, &tr);
    USB_unlock();

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_audio_send_data (component USB_AUDIO_CLASS)
**
**     Description :
**         Send audio data to device through a isochronous OUT pipe.
**     Parameters  :
**         NAME            - DESCRIPTION
**         control_ptr     - [IN] class-interface
**                           control pointer
**         stream_ptr      - [IN] class-interface stream
**                           pointer
**         callback        - [IN] callback upon completion
**       * call_parm       - [IN] user parameter returned
**                           by callback
**         buf_size        - [IN] data length
**         buffer          - [IN] buffer pointer
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_audio_send_data(CLASS_CALL_STRUCT_PTR control_ptr, CLASS_CALL_STRUCT_PTR stream_ptr, tr_callback callback, void* call_parm, uint_32 buf_size, uchar_ptr buffer)
{
    /* Body */
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         stream_if_ptr;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         control_if_ptr;
    TR_INIT_PARAM_STRUCT                           tr;
    USB_STATUS                                     status = USBERR_NO_INTERFACE;

    USB_lock();
    /* Validity checking, always needed when passing data to lower API */
    if (!usb_host_class_intf_validate(control_ptr)) {
        USB_unlock();
        return USBERR_NO_INTERFACE;
    }
    stream_if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR) stream_ptr->class_intf_handle;
    control_if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR) control_ptr->class_intf_handle;

    /* Do the device use OUT pipe? */
    if (stream_if_ptr->iso_out_pipe == NULL) {
        USB_unlock();
        return USBERR_OPEN_PIPE_FAILED;
    }

    /* Validity checking, always needed when passing data to lower API */
    if (!usb_host_class_intf_validate(control_ptr)) {
        USB_unlock();
        return USBERR_NO_INTERFACE;
    }
    usb_hostdev_tr_init(&tr, (tr_callback) callback, (pointer) call_parm);
    tr.TX_BUFFER = (uchar_ptr) buffer;
    tr.TX_LENGTH = buf_size;
    status = _usb_host_send_data(control_if_ptr->AUDIO_G.G.host_handle, stream_if_ptr->iso_out_pipe, &tr);
    USB_unlock();

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_copy_protect (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get copy
**         protect value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_copy_protect(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    uint_16 wIndex;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->it_desc->bTerminalID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* check valid of input terminal descriptor */
    if (if_ptr->it_desc==NULL)
    {
        return USBERR_NO_DESCRIPTOR;
    }
    else
    {
        return usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((COPY_PROTECT_CONTROL << 8)),wIndex,1,buf);
    }
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_copy_protect (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send copy
**         protect value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_copy_protect(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    uint_16 wIndex;
    USB_AUDIO_CTRL_DESC_OT_PTR ot_desc;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    ot_desc=(USB_AUDIO_CTRL_DESC_OT_PTR)if_ptr->ot_desc;
    wIndex=(uint_16)(((ot_desc->bTerminalID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* check valid of input terminal descriptor */
    if (ot_desc==NULL)
    {
        return USBERR_NO_DESCRIPTOR;
    }
    else
    {
        return usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((COPY_PROTECT_CONTROL << 8)),wIndex,1,buf);
    }
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_mute (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         mute value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_mute(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    uint_16 wIndex;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MUTE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_MUTE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_mute (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         mute value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_mute(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MUTE_MASK,0);

    if (USB_OK==status)
    {
        status = usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_MUTE << 8)),wIndex,1,buf);
    }

    return status;

}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         volume value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status = usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         mute value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min volume
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min
**         volume value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max volume
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=        usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max
**         volume value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         volume value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_volume (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution volume value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_volume(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_VOLUME_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_VOLUME << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         bass value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         bass value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min bass
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min bass
**         value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max bass
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max bass
**         value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         bass value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);

    if (USB_OK==status)
    {
        usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_bass (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution bass value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_bass(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_MASK,0);

    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         mid value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         mid value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min mid
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min mid
**         value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max mid
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }
    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max mid
**         value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         mid value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_mid (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution mid value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_mid(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_MID_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_MID << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         treble value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         treble value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min treble
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min
**         treble value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max treble
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max
**         treble value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         treble value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_treble (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution treble value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_treble(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_TREBLE_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_TREBLE << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         graphic equalizer value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         graphic equalizer value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min
**         graphic equalizer value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min
**         graphic equalizer value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max
**         graphic equalizer value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max
**         graphic equalizer value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;

}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         graphic equalizer value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_graphic_eq (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution graphic equalizer value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_graphic_eq(AUDIO_COMMAND_PTR com_ptr, uint_16 blen, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_GRAPHIC_EQ_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_GRAPHIC_EQ << 8)),wIndex,blen,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_automatic_gain (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         automatic gain control value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_automatic_gain(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */

    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_AGC_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_AGC << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_automatic_gain (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         automatic gain control value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_automatic_gain(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_AGC_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_AGC << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         delay value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         delay value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min delay
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min delay
**         value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MIN,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max delay
**         value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max delay
**         value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_MAX,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         delay value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_delay (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution delay value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_delay(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_DELAY_MASK,0);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_RES,
        (uint_16)((USB_AUDIO_CTRL_FU_DELAY << 8)),wIndex,2,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_bass_boost (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         bass boost value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_bass_boost(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_BOOST_MASK,1);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_ITF,GET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS_BOOST << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_bass_boost (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         bass boost value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_bass_boost(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_16 wIndex;
    AUDIO_CONTROL_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_CONTROL_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;
    wIndex=(uint_16)(((if_ptr->fu_desc->bUnitID)<<8)|(if_ptr->AUDIO_G.IFNUM));

    /* Check whether this attribute valid or not */
    status=check_valid_fu(if_ptr->fu_desc,FU_BASS_BOOST_MASK,1);
    if (USB_OK==status)
    {
        status=usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_ITF,SET_CUR,
        (uint_16)((USB_AUDIO_CTRL_FU_BASS_BOOST << 8)),wIndex,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         sampling frequency value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (NULL!=if_ptr->iso_in_pipe)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_EP,GET_CUR,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         sampling frequency value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_EP,SET_CUR,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_min_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get min
**         sampling frequency value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_min_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_EP,GET_MIN,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_min_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send min
**         sampling frequency value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_min_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_EP,SET_MIN,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_max_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get max
**         sampling frequency value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_max_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_EP,GET_MAX,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_max_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send max
**         sampling frequency value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_max_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_EP,SET_MAX,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_res_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get resolution
**         sampling frequency value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_res_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_EP,GET_RES,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_res_sampling_frequency (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send
**         resolution sampling freqency value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_res_sampling_frequency(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,SAMPLING_FREQ_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_EP,SET_RES,
        (uint_16)((SAMPLING_FREQ_CONTROL << 8)),(uint_16)Endp_num,3,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_cur_pitch (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get current
**         pitch value from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_cur_pitch(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,PITCH_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_EP,GET_CUR,
        (uint_16)((PITCH_CONTROL << 8)),(uint_16)Endp_num,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_cur_pitch (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send current
**         pitch value to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_cur_pitch(AUDIO_COMMAND_PTR com_ptr, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Check whether this attribute valid or not */
    status=check_valid_ep(if_ptr->iso_endp_spec_desc,PITCH_MASK);
    if (USB_OK==status)
    {
        /* Any isochronous pipe is supported? */
        if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
        {
            status=USBERR_INVALID_NUM_OF_ENDPOINTS;
        }
        else if (if_ptr->iso_in_pipe!=NULL)
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
        }
        else
        {
            Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
        }/* Endif */

        status= usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_EP,SET_CUR,
        (uint_16)((PITCH_CONTROL << 8)),(uint_16)Endp_num,1,buf);
    }

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_get_mem_endpoint (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to get memory of
**         the endpoint from the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         offset          - [IN] zero-based offset value
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to receive data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_get_mem_endpoint(AUDIO_COMMAND_PTR com_ptr, uint_16 offset, uint_16 blen, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Any isochronous pipe is supported? */
    if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
    {
        status=USBERR_INVALID_NUM_OF_ENDPOINTS;
    }
    else if (if_ptr->iso_in_pipe!=NULL)
    {
        Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
    }
    else
    {
        Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
    }/* Endif */

    status= usb_class_audio_cntrl_common(com_ptr,  GET_REQUEST_EP,GET_MEM,
    offset,(uint_16)Endp_num,blen,buf);

    return status;
}

/*
** ===================================================================
**     Method      :  usb_host_audio_usb_class_audio_set_mem_endpoint (component USB_AUDIO_CLASS)
**
**     Description :
**         This function is called by the application to send memory of
**         the endpoint to the audio device
**     Parameters  :
**         NAME            - DESCRIPTION
**         com_ptr         - [IN] Class Interface structure
**                           pointer
**         offset          - [IN] zero-based offset value
**         blen            - [IN] length of the Buffer
**       * buf             - [IN] Buffer to send data
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
USB_STATUS usb_class_audio_set_mem_endpoint(AUDIO_COMMAND_PTR com_ptr, uint_16 offset, uint_16 blen, void* buf)
{
    /* Body */
    uint_8 Endp_num;
    AUDIO_STREAM_INTERFACE_STRUCT_PTR         if_ptr;
    USB_STATUS status=USBERR_ERROR;

    if_ptr = (AUDIO_STREAM_INTERFACE_STRUCT_PTR)com_ptr->CLASS_PTR->class_intf_handle;

    /* Any isochronous pipe is supported? */
    if ((NULL==if_ptr->iso_in_pipe) && (NULL==if_ptr->iso_out_pipe))
    {
        status=USBERR_INVALID_NUM_OF_ENDPOINTS;
    }
    else if (if_ptr->iso_in_pipe!=NULL)
    {
        Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_in_pipe)->ENDPOINT_NUMBER;
    }
    else
    {
        Endp_num=((PIPE_DESCRIPTOR_STRUCT_PTR)if_ptr->iso_out_pipe)->ENDPOINT_NUMBER;
    }/* Endif */

    status= usb_class_audio_cntrl_common(com_ptr,  SET_REQUEST_EP,SET_MEM,
    offset,(uint_16)Endp_num,blen,buf);

    return status;
}

/* EOF */
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.0 [05.03]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/

