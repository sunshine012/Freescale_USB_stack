
{{DEVELOPMENT}} --------(((DEBUGINFO)))--------{{DEVELOPMENT}} 

 DRIVER SYMBOLS (alphabet order)
-------------------------------
Abstract=Common\Serial_LDDAbstract.inc
BDHReg=0
BaudAdjustValueSpeed0=0
BaudDivisorSpeed0=13
BdRateInitPrescalerInternPresc=no
C1Reg=0
C3Reg=0
C4Reg=0
DataWidth8Support=
DataWidth9Support=
DataWidthWithParity7Support=
DataWidthWithParity8Support=
DataWidthWithParity9Support=
DataWidthsList=_8_9
DataWidthsWithParityList=_7_8_9
Deinit_Enabled=UART_Deinit
Description_HWEnDi=Enables or disables the peripheral(s) associated with the component. The method is called automatically as a part of the Enable and Disable methods and several internal methods.
Description_Interrupt=The ISR function handling the device receive/transmit interrupt. Calls InterruptTX/InterruptRX methods.
Description_InterruptRx=The method services the receive interrupt of the selected peripheral(s) and eventually invokes the bean's event(s).
Description_InterruptTx=The method services the receive interrupt of the selected peripheral(s) and eventually invokes the bean's event(s).
Description_SetClockConfiguration=This method changes the clock configuration. During a clock configuration change the component changes it's setting immediately upon a request.
DeviceBaseAddr=UART0_BASE_PTR
Doc_Misra_Rule_1=1.1
Doc_Misra_Rule_10=8.10
Doc_Misra_Rule_10_Description=All declarations and definitions of objects or function at file scope shall have internal linkage unless external linkage is required.
Doc_Misra_Rule_10_Lint=Info 765: external 'function' could be made static [MISRA 2004 Rule 8.10]
Doc_Misra_Rule_10_Reason=Device Initialization - ISR declaration is subject of various modifications by the user and may or may not be copied to another module - static is not used.
Doc_Misra_Rule_10_Type=Required
Doc_Misra_Rule_11=10.1
Doc_Misra_Rule_11_Description=The value of an expression of integer type shall not be implicitly converted to a different underlying type.
Doc_Misra_Rule_11_Lint=Note 960: Violates MISRA 2004 Required Rule 10.1, Implicit conversion of integer to smaller type
Doc_Misra_Rule_11_Reason=
Doc_Misra_Rule_11_Type=Required
Doc_Misra_Rule_12=11.3
Doc_Misra_Rule_12_Description=A cast should not be performed between a pointer type and an integral type.
Doc_Misra_Rule_12_Lint=Note 923: cast from 'integer type' to pointer [Encompasses MISRA 2004 Rules 11.1 and 11.3], [MISRA 2004 Rule 11.3]
Doc_Misra_Rule_12_Reason=IO map is based on structures and typecasting from a peripheral base address (integer constant) to a pointer type is used to get a pointer to the given peripheral structure used to access a peripheral registers.
Doc_Misra_Rule_12_Type=Advisory
Doc_Misra_Rule_13=11.4
Doc_Misra_Rule_13_Description=A cast should be not be performed between a pointer to object type and different pointer to object type
Doc_Misra_Rule_13_Lint=Note 929: cast from pointer to pointer [MISRA 2004 Rule 11.4]
Doc_Misra_Rule_13_Reason=See detailed description for particular component
Doc_Misra_Rule_13_Type=Advisory
Doc_Misra_Rule_14=12.1
Doc_Misra_Rule_14_Description=Limited dependence should be placed on C's operator precedence rules in expressions.
Doc_Misra_Rule_14_Lint=Note 961: Violates MISRA 2004 Advisory Rule 12.1, dependence placed on C's operator precedence; operators: ',' and ','
Doc_Misra_Rule_14_Reason=
Doc_Misra_Rule_14_Type=Advisory
Doc_Misra_Rule_15=12.8
Doc_Misra_Rule_15_Description=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand.
Doc_Misra_Rule_15_Lint=Warning 572: Excessive shift value (precision 2 shifted right by 8) [MISRA 2004 Rule 12.8]
Doc_Misra_Rule_15_Reason=
Doc_Misra_Rule_15_Type=Required
Doc_Misra_Rule_16=12.10
Doc_Misra_Rule_16_Description=The comma operator shall not be used.
Doc_Misra_Rule_16_Lint=Note 960: Violates MISRA 2004 Required Rule 12.10, comma operator used
Doc_Misra_Rule_16_Reason=Comma operator is used in PDD macros.
Doc_Misra_Rule_16_Type=Required
Doc_Misra_Rule_17=12.11
Doc_Misra_Rule_17_Description=Evaluation of constant unsigned integer expressions should not lead to wrap-around.
Doc_Misra_Rule_17_Lint=Warning 648: Overflow in computing constant for operation: 'unsigned shift left' [MISRA 2004 Rule 12.11]
Doc_Misra_Rule_17_Reason=
Doc_Misra_Rule_17_Type=Advisory
Doc_Misra_Rule_18=13.7
Doc_Misra_Rule_18_Description=Boolean operations whose results are invariant shall not be permitted.
Doc_Misra_Rule_18_Lint=Warning 506: Constant value Boolean [MISRA 2004 Rules 13.7 and 14.1]
Doc_Misra_Rule_18_Reason=PDD macros define constants that can be passed as parameters to these macros.
Doc_Misra_Rule_18_Type=Required
Doc_Misra_Rule_19=14.2
Doc_Misra_Rule_19_Description=All non-null statements shall either: <br/>a) have at least one side effect however executed, <br/>or b) cause control flow to change.
Doc_Misra_Rule_19_Lint=Warning 522: Highest operation, operator ',', lacks side-effects
Doc_Misra_Rule_19_Reason=Some PDD macros have two commas in the macro implementation.
Doc_Misra_Rule_19_Type=Required
Doc_Misra_Rule_1_Description=All code shall conform to ISO 9899-1990 (C-code guideline)
Doc_Misra_Rule_1_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_1_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_1_Type=Required
Doc_Misra_Rule_2=1.4
Doc_Misra_Rule_20=14.7
Doc_Misra_Rule_20_Description=A function shall have a single point of exit at the end of the function.
Doc_Misra_Rule_20_Lint=Note 904: Return statement before end of function [MISRA 2004 Rule 14.7]
Doc_Misra_Rule_20_Reason=Use of multiple return statements simplifies the code logic.
Doc_Misra_Rule_20_Type=Required
Doc_Misra_Rule_21=18.4
Doc_Misra_Rule_21_Description=Unions shall not be used.
Doc_Misra_Rule_21_Lint=Note 960: Violates MISRA 2004 Required Rule 18.4, unions shall not be used
Doc_Misra_Rule_21_Reason=Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.
Doc_Misra_Rule_21_Type=Required
Doc_Misra_Rule_22=19.13
Doc_Misra_Rule_22_Description=The # and ## preprocessor operators should not be used.
Doc_Misra_Rule_22_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.13, '#/##' operator used
Doc_Misra_Rule_22_Reason=Preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_22_Type=Advisory
Doc_Misra_Rule_2_Description=The compiler/linker shall be checked to ensure that 31 character significance and case sensitivity are supported for external identifiers.
Doc_Misra_Rule_2_Lint=Note Warning 621: Identifier clash [MISRA 2004 Rules 1.2, 1.4 and 5.1]
Doc_Misra_Rule_2_Reason=IO map defines register access constants. The constants' names contain peripheral name, register name, bit name and suffix _MASK/_SHIFT.
Doc_Misra_Rule_2_Type=Required
Doc_Misra_Rule_3=2.1
Doc_Misra_Rule_3_Description=Assembly language shall be encapsulated and isolated.
Doc_Misra_Rule_3_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_3_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_3_Type=Required
Doc_Misra_Rule_4=3.1
Doc_Misra_Rule_4_Description=All usage of implementation-defined behavior shall be documented.
Doc_Misra_Rule_4_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_4_Reason=Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:
Doc_Misra_Rule_4_Type=Required
Doc_Misra_Rule_5=3.2
Doc_Misra_Rule_5_Description=The character set and the corresponding encoding shall be documented.
Doc_Misra_Rule_5_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_5_Reason=Basic character set (see ISO 9899) is used in execution character set. Execution character set uses ASCII encoding (possible codes 0-255). Exception to basic character set: Term component uses NULL(0x00), CR (0x0D), LF(0x0A).
Doc_Misra_Rule_5_Type=Required
Doc_Misra_Rule_6=3.3
Doc_Misra_Rule_6_Description=The implementation of integer division in the chosen compiler should be determined, documented and taken into account.
Doc_Misra_Rule_6_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_6_Reason=The way a Compiler implements division and modulo for negative operands is determined by the hardware implementation of the target's division instructions. See documentation of CodeWarrior S12(X) Build tools for more information.
Doc_Misra_Rule_6_Type=Advisory
Doc_Misra_Rule_7=3.4
Doc_Misra_Rule_7_Description=All uses of the #pragma directives shall be documented and explained.
Doc_Misra_Rule_7_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_7_Reason=Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.
Doc_Misra_Rule_7_Type=Required
Doc_Misra_Rule_8=3.6
Doc_Misra_Rule_8_Description=All libraries used in production code shall be written to comply with the provision of this document and shall have been subject to appropriate validation.
Doc_Misra_Rule_8_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_8_Reason=Only libraries included in CodeWarrior development studio are used in the generated source code.
Doc_Misra_Rule_8_Type=Required
Doc_Misra_Rule_9=6.3
Doc_Misra_Rule_9_Description=Typedef that indicates size and signedness should be used in place of basic types.
Doc_Misra_Rule_9_Lint=Info 970: Use of modifier or type 'int' outside of a typedef [MISRA Rule 6.3]
Doc_Misra_Rule_9_Reason=The type of the function is defined by tool set. ProcessorExpert definition must comply..
Doc_Misra_Rule_9_Type=Advisory
DriverAuthor=Marek Vinkler
DriverDate=25.02.2010
DriverVersion=01.10
EndOfInterface=
EventCount=7
FineAdjustSupport=yes
GetReceivedDataNum_Enabled=UART_GetReceivedDataNum
GetSentDataNum_Enabled=UART_GetSentDataNum
GetTxCompleteStatus_Enabled=UART_GetTxCompleteStatus
Init_Enabled=UART_Init
Location_x=Serial_LDD
MODEMReg=0
Main_Enabled=UART_Main
MaxDataWidth=9
MaxDataWidthWithParity=9
MethodCount=39
Mode10BitMask=32
ModeBitMask=16
PDD=UART_PDD
PEMSL_StrTemp=8
ParBufferPtr=
ParDeviceDataPtr=
ParSize=
ParUserDataPtr=
Par_DeviceData=
PeripheralType=UART
RTOSAdap_alloc_object_DeviceDataPrv=
RTOSAdap_defParam_allocatedDevice=UART0
RTOSAdap_defParam_allocatedDeviceBaseAddr=4294934848
RTOSAdap_defParam_componentInstanceName=UART
RTOSAdap_defParam_componentType=Serial_LDD
RTOSAdap_defParam_genReentrantMethods=no
ReceiveBlock_Enabled=UART_ReceiveBlock
RetVal=
S2Reg=0
SBRpresc=13
SendBlock_Enabled=UART_SendBlock
Settings=Common\Serial_LDDSettings.inc
SharedModuleName=UART
WakeupBitMask=8
col=7
loc_EventName=OnRxActiveEdge
loc_MethodName=GetDriverState
loc_ObjDefSuffix=
loc_Param_Align=undef
loc_Param_Zero=undef
loc_RunDistinctPart=
loc_RunSharedPart=
loc_componentInstanceName=UART
loc_memberPos=0
loc_onlySpacesString=no
tmp=0
Doc_Misra_Rule_10_Location=[Cpu|Vectors.c]
Doc_Misra_Rule_11_Location=[PE_Types.h|SDHC_LDD]
Doc_Misra_Rule_11_Location_Reason=[Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.]
Doc_Misra_Rule_12_Location=[IO_Map.h]
Doc_Misra_Rule_13_Location=[Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD]
Doc_Misra_Rule_13_Location_Reason=[Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.]
Doc_Misra_Rule_14_Location=[SDHC_LDD|Ethernet_LDD]
Doc_Misra_Rule_14_Location_Reason=[Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.]
Doc_Misra_Rule_15_Location=[Ethernet_LDD|TimerUnit_LDD|Serial_LDD]
Doc_Misra_Rule_15_Location_Reason=[Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.]
Doc_Misra_Rule_16_Location=[Global]
Doc_Misra_Rule_17_Location=[Ethernet_LDD]
Doc_Misra_Rule_17_Location_Reason=[Macro for endianness conversion cannot be used on constants.]
Doc_Misra_Rule_18_Location=[Global]
Doc_Misra_Rule_19_Location=[Global]
Doc_Misra_Rule_1_Location=[PE_Types.h|Cpu|Vectors.c|FLASH_LDD]
Doc_Misra_Rule_1_Location_Reason=[The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_20_Location=[Global]
Doc_Misra_Rule_21_Location=[Global|IO_Map.h]
Doc_Misra_Rule_21_Location_Reason=[Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.]
Doc_Misra_Rule_22_Location=[PE_Types.h]
Doc_Misra_Rule_22_Location_Reason=[Used to convert bit name to bit mask in macros accessing registers.]
Doc_Misra_Rule_2_Location=[IO_Map.h]
Doc_Misra_Rule_3_Location=[PE_Types.h|Cpu|Vectors.c]
Doc_Misra_Rule_3_Location_Reason=[The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_4_Location=[PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info]
Doc_Misra_Rule_4_Location_Reason=[Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.]
Doc_Misra_Rule_5_Location=[PE_Info]
Doc_Misra_Rule_6_Location=[PE_Info]
Doc_Misra_Rule_7_Location=[PE_Info]
Doc_Misra_Rule_7_Location_Reason=[Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.]
Doc_Misra_Rule_8_Location=[CAU_LDD]
Doc_Misra_Rule_8_Location_Reason=[CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.]
Doc_Misra_Rule_9_Location=[CPU|Main.c]
EventMaskNameList=[LDD_SERIAL_ON_BLOCK_RECEIVED|LDD_SERIAL_ON_BLOCK_SENT|LDD_SERIAL_ON_BREAK|LDD_SERIAL_ON_TXCOMPLETE|LDD_SERIAL_ON_ERROR]
EventMaskValueList=[1|2|4|8|16]
EventNameList=[OnBlockReceived|OnBlockSent|OnBreak|OnTxComplete|OnError]
PE_MisraErrorCodes=[572]
RTOSAdap_enum_componentTypes=[HAL_UART_Polling|HAL_UART_Int|HAL_I2C_Polling|HAL_I2C_Int|HAL_GPIO|HAL_ADC|HAL_RTC|HAL_Ethernet|HAL_TimerUnit|AsyncSerial_LDD|USB_LDD]
RTOSAdap_enum_defaultParameterNames=[componentType|simpleComponentType|componentInstanceName|genReentrantMethods|genCriticalSectionMethods|constantDeclarationsThread|allocatedDevice|allocatedDeviceBaseAddr|SPIN_LOCK]
RTOSAdap_enum_simpleComponentTypes=[HAL_UART|HAL_I2C|HAL_GPIO|HAL_ADC|HAL_RTC|HAL_Ethernet|HAL_TimerUnit|AsyncSerial_LDD|USB_LDD]
revAuth=[LV|PC|MV|RH|MV|MV|MV|MV|MV|MV]
revCmnt_0=[Clock configuration support]
revCmnt_1=[Fixed runtime setting of the parity and data width]
revCmnt_2=[Support of new Kinetis derivatives - MK50 and other MK10, MK20, MK30, MK40 and MK60 variants.|Support for GNUC (Code Sourcery G++) compiler has been added.]
revCmnt_3=[Support of ColdFire+ derivatives.]
revCmnt_4=[Component auto initialization feature added.]
revCmnt_5=[Fixed the logical condition to return an error code when transmit operation is still in progress.|Fixed detection of transmission complete in the polling mode.|Fixed initialization of the baud rate when the property 'Enabled in init. code' is set to 'no'.]
revCmnt_6=[Support for IAR C compiler for ColdFire has been added.]
revCmnt_7=[SendBlock method usage in OnBlockSent event fixed.]
revCmnt_8=[SendBlock method usage in OnBlockSent event fixed.]
revCmnt_9=[Support for ARM_CC compiler has been added.]
revDate=[22.08.2012|28.05.2012|23.01.2012|01.07.2011|05.05.2011|07.04.2011|11.03.2011|26.01.2011|02.12.2010|15.09.2010]
revLvl=[3|3|3|3|5|5|3|5|6|1]
revVer=[01.10|01.09|01.08|01.07|01.06|01.05|01.04|01.03|01.02|01.01]
revVrf=[PE|PE|PE|PE|PE|PE|PE|PE|PE|PE]

 LOCAL SYMBOLS (alphabet order)
-------------------------------
AutoInitialization=yes
AutoInitializationGrpMaxItem=0
AutoInitializationGrpNumItems=1
BdRateBaudRate=115318
BdRateInitPrescaler_Same=yes
BdRateRuntimeSetting=none
BeanTemplate=TWR_SER_MCF51JF_UART
BeanVersion=01.165
BreakLength=10_11
ClockConfigGrpMaxItem=0
ClockConfigGrpNumItems=1
DataWidth=8
Deinit=Deinit
Deinit_Hint=void UART_Deinit(LDD_TDeviceData *DeviceDataPtr);
Deinit_HintHint=Deinitializes the device. Switches off the device, frees the device data...
Deinit_HintHintLong=Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts vectors, etc.
Device=UART0
DeviceBufferInAddr=4294934855
DeviceBufferInReg=UART0_D
DeviceBufferOutAddr=4294934855
DeviceBufferOutReg=UART0_D
DeviceChanel=UART0
DeviceChannel=UART0
DeviceControlAddr=4294934850
DeviceControlReg=UART0_C1
DeviceName=UART
DeviceSharedByOther=no
DeviceSpec7816_CtrlAddr=4294934872
DeviceSpec7816_CtrlReg=UART0_C7816
DeviceSpec7816_ErrorThresholdAddr=4294934878
DeviceSpec7816_ErrorThresholdReg=UART0_ET7816
DeviceSpec7816_InterruptEnableAddr=4294934873
DeviceSpec7816_InterruptEnableReg=UART0_IE7816
DeviceSpec7816_StatusAddr=4294934874
DeviceSpec7816_StatusReg=UART0_IS7816
DeviceSpec7816_TxLengthAddr=4294934879
DeviceSpec7816_TxLengthReg=UART0_TL7816
DeviceSpec7816_WaitFDAddr=4294934877
DeviceSpec7816_WaitFDReg=UART0_WF7816
DeviceSpec7816_WaitNAddr=4294934876
DeviceSpec7816_WaitNReg=UART0_WN7816
DeviceSpec7816_WaitParamsT0Addr=4294934875
DeviceSpec7816_WaitParamsT0Reg=UART0_WP7816T0
DeviceSpec7816_WaitParamsT1Addr=4294934875
DeviceSpec7816_WaitParamsT1Reg=UART0_WP7816T1
DeviceSpecAnotherClockSourceAddr=2
DeviceSpecAnotherClockSourceReg=CORE_CLOCK
DeviceSpecBaudHighAddr=4294934848
DeviceSpecBaudHighReg=UART0_BDH
DeviceSpecBaudLowAddr=4294934849
DeviceSpecBaudLowReg=UART0_BDL
DeviceSpecCtrl1Addr=4294934850
DeviceSpecCtrl1Reg=UART0_C1
DeviceSpecCtrl2Addr=4294934851
DeviceSpecCtrl2Reg=UART0_C2
DeviceSpecCtrl3Addr=4294934854
DeviceSpecCtrl3Reg=UART0_C3
DeviceSpecCtrl4Addr=4294934858
DeviceSpecCtrl4Reg=UART0_C4
DeviceSpecCtrl5Addr=4294934859
DeviceSpecCtrl5Reg=UART0_C5
DeviceSpecDataAddr=4294934855
DeviceSpecDataReg=UART0_D
DeviceSpecExtendedDataAddr=4294934860
DeviceSpecExtendedDataReg=UART0_ED
DeviceSpecFIFO_CtrlAddr=4294934865
DeviceSpecFIFO_CtrlReg=UART0_CFIFO
DeviceSpecFIFO_ParamsAddr=4294934864
DeviceSpecFIFO_ParamsReg=UART0_PFIFO
DeviceSpecFIFO_RxCountAddr=4294934870
DeviceSpecFIFO_RxCountReg=UART0_RCFIFO
DeviceSpecFIFO_RxWatermarkAddr=4294934869
DeviceSpecFIFO_RxWatermarkReg=UART0_RWFIFO
DeviceSpecFIFO_StatusAddr=4294934866
DeviceSpecFIFO_StatusReg=UART0_SFIFO
DeviceSpecFIFO_TxCountAddr=4294934868
DeviceSpecFIFO_TxCountReg=UART0_TCFIFO
DeviceSpecFIFO_TxWatermarkAddr=4294934867
DeviceSpecFIFO_TxWatermarkReg=UART0_TWFIFO
DeviceSpecMatchAddress1Addr=4294934856
DeviceSpecMatchAddress1Reg=UART0_MA1
DeviceSpecMatchAddress2Addr=4294934857
DeviceSpecMatchAddress2Reg=UART0_MA2
DeviceSpecModemAddr=4294934861
DeviceSpecModemReg=UART0_MODEM
DeviceSpecPERIPHERAL_BASE_ADDRESSAddr=4294934848
DeviceSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
DeviceSpecPE_SPEC_FEATURE_ASERIAL_RTS_CTS_SUPPORT=-1
DeviceSpecPE_SPEC_FEATURE_DataWidthAndParityReg=_7_8_9
DeviceSpecPE_SPEC_FEATURE_DataWidthReg=_8_9
DeviceSpecPE_SPEC_FEATURE_HAS_FIFO=-1
DeviceSpecPE_SPEC_FEATURE_IB_BRFAReg=PE_SPEC_FEATURE_IB_BRFA
DeviceSpecPE_SPEC_FEATURE_IB_ClockGateCtrl_CommonReg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
DeviceSpecPE_SPEC_FEATURE_IB_FIFOSettingsReg=PE_SPEC_FEATURE_IB_FIFOSettings
DeviceSpecPE_SPEC_FEATURE_IB_FIFOs_InterruptsReg=PE_SPEC_FEATURE_IB_FIFOs_Interrupts
DeviceSpecPE_SPEC_FEATURE_IB_ISO7816Reg=PE_SPEC_FEATURE_IB_ISO7816
DeviceSpecPE_SPEC_FEATURE_IB_ISO7816_Interrupts_CommonReg=PE_SPEC_FEATURE_IB_ISO7816_Interrupts_Common
DeviceSpecPE_SPEC_FEATURE_IB_ISO7816_Interrupts_ErrorReg=PE_SPEC_FEATURE_IB_ISO7816_Interrupts_Error
DeviceSpecPE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlusReg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
DeviceSpecPE_SPEC_FEATURE_IB_ModemSettingsReg=PE_SPEC_FEATURE_IB_ModemSettings
DeviceSpecPE_SPEC_FEATURE_IB_PinMuxing_CommonReg=PE_SPEC_FEATURE_IB_PinMuxing_Common
DeviceSpecPE_SPEC_FEATURE_LoopModeReg=_Normal_LocalLoop
DeviceSpecPE_SPEC_FEATURE_ParityReg=_None_Odd_Even
DeviceSpecPE_SPEC_FEATURE_StopBitsReg=_1
DeviceSpecStatus1Addr=4294934852
DeviceSpecStatus1Reg=UART0_S1
DeviceSpecStatus2Addr=4294934853
DeviceSpecStatus2Reg=UART0_S2
DeviceType=Serial_LDD
Device_Name=UART0
EventModule=Events
FlowControlGrp=None
GetReceivedDataNum=GetReceivedDataNum
GetReceivedDataNum_Hint=uint16_t UART_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr);
GetReceivedDataNum_HintHint=Returns the number of received characters in the receive buffer.
GetReceivedDataNum_HintHintLong=Returns the number of received characters in the receive buffer.
GetSentDataNum=GetSentDataNum
GetSentDataNum_Hint=uint16_t UART_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);
GetSentDataNum_HintHint=Returns the number of sent characters.
GetSentDataNum_HintHintLong=Returns the number of sent characters.
GetTxCompleteStatus=GetTxCompleteStatus
GetTxCompleteStatus_Hint=bool UART_GetTxCompleteStatus(LDD_TDeviceData *DeviceDataPtr);
GetTxCompleteStatus_HintHint=Returns whether the transmitter has transmitted all characters and there are...
GetTxCompleteStatus_HintHintLong=Returns whether the transmitter has transmitted all characters and there are no other characters in the transmitter's HW FIFO or the shift register. This method is available only if a peripheral supports this feature.
IdleMode=AfterStartBit
Init=Init
InitEnable=yes
Init_Hint=LDD_TDeviceData* UART_Init(LDD_TUserData *UserDataPtr);
Init_HintHint=Initializes the device. Allocates memory for the device data structure,...
Init_HintHintLong=Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value then the device is also enabled(see the description of the Enable() method). In this case the Enable() method is not necessary and needn't to be generated.
Inp=ADC0_SE14/TSI0_CH6/PTD6/UART0_RX/RGPIO14/FBa_D4
InpBitMask=64
InpBitNum=6
InpPinName=ADC0_SE14/TSI0_CH6/PTD6/UART0_RX/RGPIO14/FBa_D4
InpPinNumber=31
InpPortAddr=4294934576
InpPortCntrAddr=4294934577
InpPortCntrReg=PTD_DD
InpPortName=PTD
InpPortPTDSpecDataAddr=4294934576
InpPortPTDSpecDataReg=PTD_D
InpPortPTDSpecDeviceTypeReg=GPIO
InpPortPTDSpecDirectionAddr=4294934577
InpPortPTDSpecDirectionReg=PTD_DD
InpPortPTDSpecDriveStrengthReg=PCTLD_DS
InpPortPTDSpecGPIO_BASE_NameReg=PTD_BASE_PTR
InpPortPTDSpecInputDataAddr=4294934578
InpPortPTDSpecInputDataReg=PTD_PV
InpPortPTDSpecIntEdgeReg=PCTLD_IES
InpPortPTDSpecIntEnReg=PCTLD_IPE
InpPortPTDSpecIntFlagReg=PCTLD_IF
InpPortPTDSpecInterruptControlReg=PCTLD_IC
InpPortPTDSpecMin8PinGroupsReg=_0to7
InpPortPTDSpecPERIPHERAL_BASE_ADDRESSAddr=4294934576
InpPortPTDSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
InpPortPTDSpecPE_SPEC_FEATURE_IB_ClockGateCtrl_CommonReg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
InpPortPTDSpecPE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlusReg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
InpPortPTDSpecPE_SPEC_FEATURE_IB_PinMuxing_CommonReg=PE_SPEC_FEATURE_IB_PinMuxing_Common
InpPortPTDSpecPE_SPEC_FEATURE_InterruptDetectionModesReg=_Disabled_Low_High_Rising_Falling
InpPortPTDSpecPE_SPEC_FEATURE_InterruptForcesToInputReg=PE_SPEC_FEATURE_InterruptForcesToInput
InpPortPTDSpecPassiveFilterReg=PCTLD_PFE
InpPortPTDSpecPortControl_BASE_NameReg=PCTLD_BASE_PTR
InpPortPTDSpecPullEnableReg=PCTLD_PUE
InpPortPTDSpecPullSelectReg=PCTLD_PUS
InpPortPTDSpecSlewRateReg=PCTLD_SRE
InpPortRGPIOSpecClearDataAddr=12582918
InpPortRGPIOSpecClearDataReg=RGPIO_CLR
InpPortRGPIOSpecDataAddr=12582914
InpPortRGPIOSpecDataReg=RGPIO_DATA
InpPortRGPIOSpecDeviceTypeReg=RGPIO
InpPortRGPIOSpecDirectionAddr=12582912
InpPortRGPIOSpecDirectionReg=RGPIO_DIR
InpPortRGPIOSpecEnableAddr=12582916
InpPortRGPIOSpecEnableReg=RGPIO_ENB
InpPortRGPIOSpecGPIO_BASE_NameReg=RGPIO_BASE_PTR
InpPortRGPIOSpecMin8PinGroupsReg=_0to15
InpPortRGPIOSpecPERIPHERAL_BASE_ADDRESSAddr=12582912
InpPortRGPIOSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
InpPortRGPIOSpecPE_SPEC_FEATURE_IB_ClockGateCtrl_CommonReg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
InpPortRGPIOSpecPE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlusReg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
InpPortRGPIOSpecPE_SPEC_FEATURE_IB_PinMuxing_CommonReg=PE_SPEC_FEATURE_IB_PinMuxing_Common
InpPortRGPIOSpecPE_SPEC_FEATURE_InterruptDetectionModesReg=_Disabled
InpPortRGPIOSpecSetDataAddr=12582922
InpPortRGPIOSpecSetDataReg=RGPIO_SET
InpPortRGPIOSpecToggleDataAddr=12582926
InpPortRGPIOSpecToggleDataReg=RGPIO_TOG
InpPortReg=PTD_D
InpPortSpecDataAddr=4294934576
InpPortSpecDataReg=PTD_D
InpPortSpecDeviceTypeReg=GPIO
InpPortSpecDirectionAddr=4294934577
InpPortSpecDirectionReg=PTD_DD
InpPortSpecDriveStrengthReg=PCTLD_DS
InpPortSpecGPIO_BASE_NameReg=PTD_BASE_PTR
InpPortSpecInputDataAddr=4294934578
InpPortSpecInputDataReg=PTD_PV
InpPortSpecIntEdgeReg=PCTLD_IES
InpPortSpecIntEnReg=PCTLD_IPE
InpPortSpecIntFlagReg=PCTLD_IF
InpPortSpecInterruptControlReg=PCTLD_IC
InpPortSpecMin8PinGroupsReg=_0to7
InpPortSpecPERIPHERAL_BASE_ADDRESSAddr=4294934576
InpPortSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
InpPortSpecPE_SPEC_FEATURE_IB_ClockGateCtrl_CommonReg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
InpPortSpecPE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlusReg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
InpPortSpecPE_SPEC_FEATURE_IB_PinMuxing_CommonReg=PE_SPEC_FEATURE_IB_PinMuxing_Common
InpPortSpecPE_SPEC_FEATURE_InterruptDetectionModesReg=_Disabled_Low_High_Rising_Falling
InpPortSpecPE_SPEC_FEATURE_InterruptForcesToInputReg=PE_SPEC_FEATURE_InterruptForcesToInput
InpPortSpecPassiveFilterReg=PCTLD_PFE
InpPortSpecPortControl_BASE_NameReg=PCTLD_BASE_PTR
InpPortSpecPullEnableReg=PCTLD_PUE
InpPortSpecPullSelectReg=PCTLD_PUS
InpPortSpecSlewRateReg=PCTLD_SRE
InpSharedByOther=no
InpSpecAssignD1Reg=MXC_PTDPF1
InpSpecEnableReg=RGPIO_ENB
InpSpecPortControl_BASE_NameReg=PORTD_BASE_PTR
InpSpecRGPIOBitNumAddr=14
InpSpecRGPIOBitNumReg=RGPIOBitNum
InpSupportsDirInp=yes
InpSupportsDirOut=yes
Inp_Name=ADC0_SE14/TSI0_CH6/PTD6/UART0_RX/RGPIO14/FBa_D4
IntService=no
LoopMode=Normal
Main=Main
Main_Hint=void UART_Main(LDD_TDeviceData *DeviceDataPtr);
Main_HintHint=This method is available only in the polling mode (Interrupt service/event =...
Main_HintHintLong=This method is available only in the polling mode (Interrupt service/event = 'no'). If interrupt service is disabled this method replaces the interrupt handler. This method should be called if Receive/SendBlock was invoked before in order to run the reception/transmission. The end of the receiving/transmitting is indicated by OnBlockSent or OnBlockReceived event.
ModuleName=UART
NonRtosOthrEvntsGrp=
OnBlockReceivedInitState=Disabled
OnBlockSentInitState=Disabled
OnBreakInitState=Disabled
OnErrorInitState=Disabled
OnTxCompleteInitState=Disabled
Out=ADC0_SE13/TSI0_CH5/PTA7/UART0_TX/FTM0_QD_PHA/FBa_D5
OutBitMask=128
OutBitNum=7
OutPinName=ADC0_SE13/TSI0_CH5/PTA7/UART0_TX/FTM0_QD_PHA/FBa_D5
OutPinNumber=30
OutPortAddr=4294934528
OutPortCntrAddr=4294934529
OutPortCntrReg=PTA_DD
OutPortName=PTA
OutPortReg=PTA_D
OutPortSpecDataAddr=4294934528
OutPortSpecDataReg=PTA_D
OutPortSpecDeviceTypeReg=GPIO
OutPortSpecDirectionAddr=4294934529
OutPortSpecDirectionReg=PTA_DD
OutPortSpecDriveStrengthReg=PCTLA_DS
OutPortSpecGPIO_BASE_NameReg=PTA_BASE_PTR
OutPortSpecInputDataAddr=4294934530
OutPortSpecInputDataReg=PTA_PV
OutPortSpecIntEdgeReg=PCTLA_IES
OutPortSpecIntEnReg=PCTLA_IPE
OutPortSpecIntFlagReg=PCTLA_IF
OutPortSpecInterruptControlReg=PCTLA_IC
OutPortSpecMin8PinGroupsReg=_0to7
OutPortSpecPERIPHERAL_BASE_ADDRESSAddr=4294934528
OutPortSpecPERIPHERAL_BASE_ADDRESSReg=PERIPHERAL_BASE_ADDRESS
OutPortSpecPE_SPEC_FEATURE_IB_ClockGateCtrl_CommonReg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
OutPortSpecPE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlusReg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
OutPortSpecPE_SPEC_FEATURE_IB_PinMuxing_CommonReg=PE_SPEC_FEATURE_IB_PinMuxing_Common
OutPortSpecPE_SPEC_FEATURE_InterruptDetectionModesReg=_Disabled_Low_High_Rising_Falling
OutPortSpecPE_SPEC_FEATURE_InterruptForcesToInputReg=PE_SPEC_FEATURE_InterruptForcesToInput
OutPortSpecPassiveFilterReg=PCTLA_PFE
OutPortSpecPortControl_BASE_NameReg=PCTLA_BASE_PTR
OutPortSpecPullEnableReg=PCTLA_PUE
OutPortSpecPullSelectReg=PCTLA_PUS
OutPortSpecSlewRateReg=PCTLA_SRE
OutSharedByOther=no
OutSpecAssignA1Reg=MXC_PTAPF1
OutSpecPortControl_BASE_NameReg=PORTA_BASE_PTR
OutSupportsDirInp=yes
OutSupportsDirOut=yes
Out_Name=ADC0_SE13/TSI0_CH5/PTA7/UART0_TX/FTM0_QD_PHA/FBa_D5
Parity=None
ReceiveBlock=ReceiveBlock
ReceiveBlock_Hint=LDD_TError UART_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
ReceiveBlock_HintHint=Specifies the number of data to receive. The method returns ERR_BUSY until...
ReceiveBlock_HintHintLong=Specifies the number of data to receive. The method returns ERR_BUSY until the specified number of characters is received. Method <CancelBlockReception> can be used to cancel a running receive operation.
Receiver=
ReentrantMethods=no
RxDpinSignal=
RxPolarity=NotInverted
SCIOutMode=0
SendBlock=SendBlock
SendBlock_Hint=LDD_TError UART_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
SendBlock_HintHint=Sends a block of characters. The method returns ERR_BUSY when the previous...
SendBlock_HintHintLong=Sends a block of characters. The method returns ERR_BUSY when the previous block transmission is not completed. Method <CancelBlockTransmission> can be used to cancel a transmit operation. This method is available only if the transmitter property is enabled.
SpeedMode0=
StopBits=1
StopInWait=no
Transmitter=
TxDpinSignal=
TxPolarity=NotInverted
WakeupCond=IdleLine
runSpeedModeNum=1
BdRateBaudRateE_real=[0.000008671662]
BdRateBaudRateE_real_us=[8.671661543716]
BdRateBaudRateE_ticks=[35]
BdRateBaudRateE_ticksR=[34.686646174863]
BdRateInitPrescaler=[416]
BdRateTotalPrescaler=[1]
BdRateTotalPrescalerReal=[1]
MethodHintList=[LDD_TDeviceData* UART_Init(LDD_TUserData *UserDataPtr);|void UART_Deinit(LDD_TDeviceData *DeviceDataPtr);|LDD_TError UART_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size);|LDD_TError UART_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size);|uint16_t UART_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);|uint16_t UART_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr);|bool UART_GetTxCompleteStatus(LDD_TDeviceData *DeviceDataPtr);|void UART_Main(LDD_TDeviceData *DeviceDataPtr);]
MethodList=[Init|Deinit|SendBlock|ReceiveBlock|GetSentDataNum|GetReceivedDataNum|GetTxCompleteStatus|Main]
runSpeedMode=[Yes]

 DEPRECATED LOCAL SYMBOLS (alphabet order)
------------------------------------------
DeviceSpec0Addr=2
DeviceSpec0Reg=CORE_CLOCK
DeviceSpec11Reg=PE_SPEC_FEATURE_IB_PinMuxing_Common
DeviceSpec12Reg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
DeviceSpec13Reg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
DeviceSpec14Addr=4294934848
DeviceSpec14Reg=UART0_BDH
DeviceSpec15Addr=4294934849
DeviceSpec15Reg=UART0_BDL
DeviceSpec16Addr=4294934850
DeviceSpec16Reg=UART0_C1
DeviceSpec17Addr=4294934851
DeviceSpec17Reg=UART0_C2
DeviceSpec18Addr=4294934852
DeviceSpec18Reg=UART0_S1
DeviceSpec19Addr=4294934853
DeviceSpec19Reg=UART0_S2
DeviceSpec1Reg=_Normal_LocalLoop
DeviceSpec20Addr=4294934854
DeviceSpec20Reg=UART0_C3
DeviceSpec21Addr=4294934855
DeviceSpec21Reg=UART0_D
DeviceSpec22Addr=4294934856
DeviceSpec22Reg=UART0_MA1
DeviceSpec23Addr=4294934857
DeviceSpec23Reg=UART0_MA2
DeviceSpec24Addr=4294934858
DeviceSpec24Reg=UART0_C4
DeviceSpec25Addr=4294934859
DeviceSpec25Reg=UART0_C5
DeviceSpec26Addr=4294934860
DeviceSpec26Reg=UART0_ED
DeviceSpec27Addr=4294934861
DeviceSpec27Reg=UART0_MODEM
DeviceSpec28Addr=4294934864
DeviceSpec28Reg=UART0_PFIFO
DeviceSpec29Addr=4294934865
DeviceSpec29Reg=UART0_CFIFO
DeviceSpec30Addr=4294934866
DeviceSpec30Reg=UART0_SFIFO
DeviceSpec31Addr=4294934867
DeviceSpec31Reg=UART0_TWFIFO
DeviceSpec32Addr=4294934868
DeviceSpec32Reg=UART0_TCFIFO
DeviceSpec33Addr=4294934869
DeviceSpec33Reg=UART0_RWFIFO
DeviceSpec34Addr=4294934870
DeviceSpec34Reg=UART0_RCFIFO
DeviceSpec35Addr=4294934872
DeviceSpec35Reg=UART0_C7816
DeviceSpec36Addr=4294934873
DeviceSpec36Reg=UART0_IE7816
DeviceSpec37Addr=4294934874
DeviceSpec37Reg=UART0_IS7816
DeviceSpec38Addr=4294934875
DeviceSpec38Reg=UART0_WP7816T1
DeviceSpec39Addr=4294934875
DeviceSpec39Reg=UART0_WP7816T0
DeviceSpec3Reg=_8_9
DeviceSpec40Addr=4294934876
DeviceSpec40Reg=UART0_WN7816
DeviceSpec41Addr=4294934877
DeviceSpec41Reg=UART0_WF7816
DeviceSpec42Addr=4294934878
DeviceSpec42Reg=UART0_ET7816
DeviceSpec43Addr=4294934879
DeviceSpec43Reg=UART0_TL7816
DeviceSpec44Reg=PE_SPEC_FEATURE_IB_BRFA
DeviceSpec45Reg=PE_SPEC_FEATURE_IB_ModemSettings
DeviceSpec46Reg=PE_SPEC_FEATURE_IB_FIFOSettings
DeviceSpec47Reg=PE_SPEC_FEATURE_IB_ISO7816
DeviceSpec48Reg=PE_SPEC_FEATURE_IB_ISO7816_Interrupts_Common
DeviceSpec49Reg=PE_SPEC_FEATURE_IB_FIFOs_Interrupts
DeviceSpec4Reg=_7_8_9
DeviceSpec50Reg=PE_SPEC_FEATURE_IB_ISO7816_Interrupts_Error
DeviceSpec5Reg=_None_Odd_Even
DeviceSpec6Reg=_1
DeviceSpec8Addr=4294934848
DeviceSpec8Reg=PERIPHERAL_BASE_ADDRESS
InpPortPTDSpec0Reg=GPIO
InpPortPTDSpec10Reg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
InpPortPTDSpec11Reg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
InpPortPTDSpec12Addr=4294934576
InpPortPTDSpec12Reg=PTD_D
InpPortPTDSpec13Addr=4294934577
InpPortPTDSpec13Reg=PTD_DD
InpPortPTDSpec14Addr=4294934578
InpPortPTDSpec14Reg=PTD_PV
InpPortPTDSpec15Reg=PCTLD_PUE
InpPortPTDSpec16Reg=PCTLD_PUS
InpPortPTDSpec17Reg=PCTLD_DS
InpPortPTDSpec18Reg=PCTLD_SRE
InpPortPTDSpec19Reg=PCTLD_PFE
InpPortPTDSpec1Reg=PTD_BASE_PTR
InpPortPTDSpec20Reg=PCTLD_IPE
InpPortPTDSpec21Reg=PCTLD_IES
InpPortPTDSpec22Reg=PCTLD_IC
InpPortPTDSpec23Reg=_0to7
InpPortPTDSpec2Reg=PCTLD_BASE_PTR
InpPortPTDSpec3Reg=PCTLD_IF
InpPortPTDSpec4Reg=_Disabled_Low_High_Rising_Falling
InpPortPTDSpec5Reg=PE_SPEC_FEATURE_InterruptForcesToInput
InpPortPTDSpec6Addr=4294934576
InpPortPTDSpec6Reg=PERIPHERAL_BASE_ADDRESS
InpPortPTDSpec9Reg=PE_SPEC_FEATURE_IB_PinMuxing_Common
InpPortRGPIOSpec0Reg=RGPIO
InpPortRGPIOSpec10Addr=12582914
InpPortRGPIOSpec10Reg=RGPIO_DATA
InpPortRGPIOSpec11Addr=12582916
InpPortRGPIOSpec11Reg=RGPIO_ENB
InpPortRGPIOSpec12Addr=12582918
InpPortRGPIOSpec12Reg=RGPIO_CLR
InpPortRGPIOSpec13Addr=12582922
InpPortRGPIOSpec13Reg=RGPIO_SET
InpPortRGPIOSpec14Addr=12582926
InpPortRGPIOSpec14Reg=RGPIO_TOG
InpPortRGPIOSpec15Reg=_0to15
InpPortRGPIOSpec1Reg=RGPIO_BASE_PTR
InpPortRGPIOSpec2Reg=_Disabled
InpPortRGPIOSpec3Addr=12582912
InpPortRGPIOSpec3Reg=PERIPHERAL_BASE_ADDRESS
InpPortRGPIOSpec6Reg=PE_SPEC_FEATURE_IB_PinMuxing_Common
InpPortRGPIOSpec7Reg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
InpPortRGPIOSpec8Reg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
InpPortRGPIOSpec9Addr=12582912
InpPortRGPIOSpec9Reg=RGPIO_DIR
InpPortSpec0Reg=GPIO
InpPortSpec10Reg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
InpPortSpec11Reg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
InpPortSpec12Addr=4294934576
InpPortSpec12Reg=PTD_D
InpPortSpec13Addr=4294934577
InpPortSpec13Reg=PTD_DD
InpPortSpec14Addr=4294934578
InpPortSpec14Reg=PTD_PV
InpPortSpec15Reg=PCTLD_PUE
InpPortSpec16Reg=PCTLD_PUS
InpPortSpec17Reg=PCTLD_DS
InpPortSpec18Reg=PCTLD_SRE
InpPortSpec19Reg=PCTLD_PFE
InpPortSpec1Reg=PTD_BASE_PTR
InpPortSpec20Reg=PCTLD_IPE
InpPortSpec21Reg=PCTLD_IES
InpPortSpec22Reg=PCTLD_IC
InpPortSpec23Reg=_0to7
InpPortSpec2Reg=PCTLD_BASE_PTR
InpPortSpec3Reg=PCTLD_IF
InpPortSpec4Reg=_Disabled_Low_High_Rising_Falling
InpPortSpec5Reg=PE_SPEC_FEATURE_InterruptForcesToInput
InpPortSpec6Addr=4294934576
InpPortSpec6Reg=PERIPHERAL_BASE_ADDRESS
InpPortSpec9Reg=PE_SPEC_FEATURE_IB_PinMuxing_Common
InpSpec11Reg=PORTD_BASE_PTR
InpSpec12Addr=14
InpSpec12Reg=RGPIOBitNum
InpSpec1Reg=MXC_PTDPF1
InpSpec6Reg=RGPIO_ENB
OutPortSpec0Reg=GPIO
OutPortSpec10Reg=PE_SPEC_FEATURE_IB_InterruptCtrl_ColdFirePlus
OutPortSpec11Reg=PE_SPEC_FEATURE_IB_ClockGateCtrl_Common
OutPortSpec12Addr=4294934528
OutPortSpec12Reg=PTA_D
OutPortSpec13Addr=4294934529
OutPortSpec13Reg=PTA_DD
OutPortSpec14Addr=4294934530
OutPortSpec14Reg=PTA_PV
OutPortSpec15Reg=PCTLA_PUE
OutPortSpec16Reg=PCTLA_PUS
OutPortSpec17Reg=PCTLA_DS
OutPortSpec18Reg=PCTLA_SRE
OutPortSpec19Reg=PCTLA_PFE
OutPortSpec1Reg=PTA_BASE_PTR
OutPortSpec20Reg=PCTLA_IPE
OutPortSpec21Reg=PCTLA_IES
OutPortSpec22Reg=PCTLA_IC
OutPortSpec23Reg=_0to7
OutPortSpec2Reg=PCTLA_BASE_PTR
OutPortSpec3Reg=PCTLA_IF
OutPortSpec4Reg=_Disabled_Low_High_Rising_Falling
OutPortSpec5Reg=PE_SPEC_FEATURE_InterruptForcesToInput
OutPortSpec6Addr=4294934528
OutPortSpec6Reg=PERIPHERAL_BASE_ADDRESS
OutPortSpec9Reg=PE_SPEC_FEATURE_IB_PinMuxing_Common
OutSpec11Reg=PORTA_BASE_PTR
OutSpec1Reg=MXC_PTAPF1


GLOBAL SYMBOLS (alphabet order)
-------------------------------
ADC0AsynchroClockAddr=4294936072
ADC0AsynchroClockReg=ADC0_CFG1
ADC0BusClockAddr=4294936072
ADC0BusClockReg=ADC0_CFG1
ADC0ClkSelAddr=4294936072
ADC0ClkSelReg=ADC0_CFG1
ActiveConfigIdentifier=PEcfg_51JF128VLH_INTERNAL_FLASH
ActiveConfiguration=51JF128VLH_INTERNAL_FLASH
CPUDB_CW_MCU_ID=28718
CPUDB_CW_MCU_NAME=MCF51JF128
CPUDB_DataFlashBlockCount=1
CPUDB_DataFlashEraseUnitSize=1024
CPUDB_DataFlashSize=32768
CPUDB_DataFlashStartAddress=2097152
CPUDB_DataFlashWriteUnitSize=4
CPUDB_FlexRamSize=2048
CPUDB_FlexRamStartAddress=2621440
CPUDB_LQFP64=-1
CPUDB_MCF51JF128=-1
CPUDB_PACKAGE=LQFP64
CPUDB_ProgramFlashBlockCount=1
CPUDB_ProgramFlashEraseUnitSize=1024
CPUDB_ProgramFlashSize=131072
CPUDB_ProgramFlashWriteUnitSize=4
CPU_DB_version=3.00.000
CPUendian=big
CPUfamily=ColdFirePlus
CPUproducer=Freescale
CPUrunSpeedModeNum=1
CPUsubFamily=MCF51JF
CPUtype=MCF51JF128_64
CPUvariant=MCF51JF128VLH
ClientDir_Binary=E:\Project\MQXLite\20121119\Copy of ProcessorExpert_1118\CDC_CLASS\Host\Update\USB_CDC_HOST_JF128_PEx\Sources\
ClientDir_Code=E:\Project\MQXLite\20121119\Copy of ProcessorExpert_1118\CDC_CLASS\Host\Update\USB_CDC_HOST_JF128_PEx\Generated_Code\
ClientDir_PE=E:\Freescale\CW MCU v10.3_121029\MCU\ProcessorExpert\
ClientDir_Project=E:\Project\MQXLite\20121119\Copy of ProcessorExpert_1118\CDC_CLASS\Host\Update\USB_CDC_HOST_JF128_PEx\
CommentBrackets=/**/
Compiler=CodeWarriorMCF
CompilerID=CodeWarrior MCF C Compiler
DirRel_Binary=Sources\
DirRel_BinaryToEvents=
DirRel_Code=Generated_Code\
DirRel_Docs=Documentation\
DirRel_EventToBinary=
DirRel_Events=Sources\
DirRel_ProjectSettings=Project_Settings\
EclipseProjectName=USB_CDC_HOST_JF128_PEx
InterruptTableType=ROM
Language=ANSIC
Not_for_MPC512x=
OnChipEEPROM=32768
OnChipFLASH=131072
OnChipRAM=32768
PE_DEBUG=
PE_DEVELOPMENT=
PE_ECLIPSE=
PE_GENERATING=
PE_G_CPUCFG_AutoIncludeIO_Map=yes
PE_G_CPUCFG_EntryPointFunctionName=__initialize_hardware
PE_G_CPUCFG_EntryPointFunctionReturn=
PE_G_CPUCFG_EntryPointFunctionReturnType=void
PE_G_CPUCFG_GenerateLinkerFile=yes
PE_G_CPUCFG_GenerateMainModule=yes
PE_G_CPUCFG_InitIntVectorTableSym=yes
PE_G_CPUCFG_ManageInterruptVectorTable=yes
PE_G_CPUCR_val=67108864
PE_G_CPUpinVariantMaster=MCF51JF128_64
PE_G_MisraCnfBackParams_0=
PE_G_MisraCnfParams_0=
PE_G_MisraRuleList_0=
PE_G_MisraStackIdx=-1
PE_G_NO_SETREGMACROS=
PE_G_RTOSAdap_regCompIndex=0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockReceived=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockSent=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBreak=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnError=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnIdle=(void (*)(LDD_TUserData RTOSDeviceData))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnRxActiveEdge=(void (*)(LDD_TUserData RTOSDeviceData))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnTxComplete=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Deinit=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetReceivedDataNum=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetSentDataNum=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetTxCompleteStatus=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Init=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Main=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_ReceiveBlock=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_SendBlock=
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockReception=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockTransmission=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearRTS=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearStats=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ConnectPin=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask PinMask))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Deinit=(void (*)(LDD_TDeviceData *DeviceDataPtr))&UART_Deinit
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Disable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Enable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetBreak=(bool (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetCTS=(bool (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDataWidth=(LDD_SERIAL_TDataWidth (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDriverState=(LDD_TDriverState (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetError=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TError *ErrorPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetEventMask=(LDD_TEventMask (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetLoopMode=(LDD_SERIAL_TLoopMode (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetParity=(LDD_SERIAL_TParity (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetReceivedDataNum=(uint16_t (*)(LDD_TDeviceData *DeviceDataPtr))&UART_GetReceivedDataNum
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSelectedBaudRate=(LDD_SERIAL_TBaudMode (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSentDataNum=(uint16_t (*)(LDD_TDeviceData *DeviceDataPtr))&UART_GetSentDataNum
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStats=(LDD_SERIAL_TStats (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStopBitLength=(LDD_SERIAL_TStopBitLen (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetTxCompleteStatus=(bool (*)(LDD_TDeviceData *DeviceDataPtr))&UART_GetTxCompleteStatus
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Init=(LDD_TDeviceData* (*)(LDD_TUserData *UserDataPtr))&UART_Init
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Main=(void (*)(LDD_TDeviceData *DeviceDataPtr))&UART_Main
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ReceiveBlock=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size))&UART_ReceiveBlock
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SelectBaudRate=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TBaudMode Mode))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBlock=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size))&UART_SendBlock
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBreak=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetDataWidth=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TDataWidth DataWidth))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetEventMask=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetLoopMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TLoopMode LoopMode))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetOperationMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetParity=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TParity Parity))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetRTS=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetStopBitLength=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TStopBitLen StopBitLen))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOff=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOn=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOff=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOn=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_USE_UINTXX_T=
PE_ProductVersion=10.0
PEversion=05.03
PEversionDecimal=1283
ProcessorModule=Cpu
ProcessorName=Cpu
ProjectModule=ProcessorExpert
ProjectName=ProcessorExpert
ServerDir_PE=E:\Freescale\CW MCU v10.3_121029\MCU\ProcessorExpert\
SetHighSpeedMode=
SupportedCPUfamily=
TimeStamp=2012-11-19, 12:06, # CodeGen: 18
Xtal_kHz=4000
Xtal_kHz_real=4000
virtual_ADC0_TotalConversionPrescalerAddr=4294936072
virtual_ADC0_TotalConversionPrescalerReg=ADC0_CFG1

 DEPRECATED GLOBAL SYMBOLS (alphabet order)
-------------------------------------------
ADC0AsynchroClockAddr=null
ADC0AsynchroClockReg=null
ADC0BusClockAddr=null
ADC0BusClockReg=null
ADC0ClkSelAddr=null
ADC0ClkSelReg=null
ActiveConfigIdentifier=null
ActiveConfiguration=null
CPUDB_CW_MCU_ID=null
CPUDB_CW_MCU_NAME=null
CPUDB_DataFlashBlockCount=null
CPUDB_DataFlashEraseUnitSize=null
CPUDB_DataFlashSize=null
CPUDB_DataFlashStartAddress=null
CPUDB_DataFlashWriteUnitSize=null
CPUDB_FlexRamSize=null
CPUDB_FlexRamStartAddress=null
CPUDB_LQFP64=null
CPUDB_MCF51JF128=null
CPUDB_PACKAGE=null
CPUDB_ProgramFlashBlockCount=null
CPUDB_ProgramFlashEraseUnitSize=null
CPUDB_ProgramFlashSize=null
CPUDB_ProgramFlashWriteUnitSize=null
CPU_DB_version=null
CPUendian=null
CPUfamily=null
CPUproducer=null
CPUrunSpeedModeNum=null
CPUsubFamily=null
CPUtype=null
CPUvariant=null
ClientDir_Binary=null
ClientDir_Code=null
ClientDir_PE=null
ClientDir_Project=null
CommentBrackets=null
Compiler=null
CompilerID=null
DirRel_Binary=null
DirRel_BinaryToEvents=null
DirRel_Code=null
DirRel_Docs=null
DirRel_EventToBinary=null
DirRel_Events=null
DirRel_ProjectSettings=null
EclipseProjectName=null
InterruptTableType=null
Language=null
Not_for_MPC512x=null
OnChipEEPROM=null
OnChipFLASH=null
OnChipRAM=null
PE_DEBUG=null
PE_DEVELOPMENT=null
PE_ECLIPSE=null
PE_GENERATING=null
PE_G_CPUCFG_AutoIncludeIO_Map=null
PE_G_CPUCFG_EntryPointFunctionName=null
PE_G_CPUCFG_EntryPointFunctionReturn=null
PE_G_CPUCFG_EntryPointFunctionReturnType=null
PE_G_CPUCFG_GenerateLinkerFile=null
PE_G_CPUCFG_GenerateMainModule=null
PE_G_CPUCFG_InitIntVectorTableSym=null
PE_G_CPUCFG_ManageInterruptVectorTable=null
PE_G_CPUCR_val=null
PE_G_CPUpinVariantMaster=null
PE_G_MisraCnfBackParams_0=null
PE_G_MisraCnfParams_0=null
PE_G_MisraRuleList_0=null
PE_G_MisraStackIdx=null
PE_G_NO_SETREGMACROS=null
PE_G_RTOSAdap_regCompIndex=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockReceived=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockSent=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBreak=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnError=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnIdle=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnRxActiveEdge=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnTxComplete=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Deinit=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetReceivedDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetSentDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetTxCompleteStatus=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Init=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Main=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_ReceiveBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_SendBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockReception=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockTransmission=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearRTS=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearStats=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ConnectPin=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Deinit=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Disable=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Enable=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetBreak=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetCTS=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDataWidth=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDriverState=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetError=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetEventMask=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetLoopMode=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetParity=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetReceivedDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSelectedBaudRate=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSentDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStats=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStopBitLength=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetTxCompleteStatus=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Init=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Main=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ReceiveBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SelectBaudRate=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBreak=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetDataWidth=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetEventMask=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetLoopMode=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetOperationMode=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetParity=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetRTS=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetStopBitLength=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOff=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOn=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOff=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOn=null
PE_G_USE_UINTXX_T=null
PE_ProductVersion=null
PEversion=null
PEversionDecimal=null
ProcessorModule=null
ProcessorName=null
ProjectModule=null
ProjectName=null
ServerDir_PE=null
SetHighSpeedMode=null
SupportedCPUfamily=null
TimeStamp=null
Xtal_kHz=null
Xtal_kHz_real=null
virtual_ADC0_TotalConversionPrescalerAddr=null
virtual_ADC0_TotalConversionPrescalerReg=null

 GLOBAL LISTS (alphabet order)
-------------------------------------------
ADC0AsynchroClock=[1]
ADC0AsynchroClock_Setting=[ADC0Async_FullPower_HighSpeed]
ADC0BusClock=[1]
ADC0BusClock_Setting=[1]
ADC0ClkSel=[1]
ADC0ClkSel_Setting=[ADC0BusClock]
CMTPresc=[1]
CMTPresc_Setting=[1]
CMTPrimaryPresc=[1]
CMTPrimaryPresc_Setting=[1]
COPClkSelect=[1]
COPClkSelect_Setting=[COPBusClock]
EventModuleList=[Events]
FTM0ClkSource=[1]
FTM0ClkSource_Setting=[CPUCLK]
FTM1ClkSource=[1]
FTM1ClkSource_Setting=[CPUCLK]
I2C0_LoTimeoutClkSel=[1]
I2C0_LoTimeoutClkSel_Setting=[I2C0_LoTimeout_BusClkDiv64]
I2C1_LoTimeoutClkSel=[1]
I2C1_LoTimeoutClkSel_Setting=[I2C1_LoTimeout_BusClkDiv64]
I2C2_LoTimeoutClkSel=[1]
I2C2_LoTimeoutClkSel_Setting=[I2C2_LoTimeout_BusClkDiv64]
I2C3_LoTimeoutClkSel=[1]
I2C3_LoTimeoutClkSel_Setting=[I2C3_LoTimeout_BusClkDiv64]
I2S0_ClkSel=[1]
I2S0_ClkSel_Setting=[CPUCLK]
I2S0_MclkClkSel=[1]
I2S0_MclkClkSel_Setting=[I2S0_MclkDiv]
I2S0_MclkDiv=[1]
I2S0_MclkDiv_Setting=[1]
I2S0_MclkPinSource_Setting=[I2S0_MclkDiv]
I2S0_RxClkMode=[1]
I2S0_RxClkMode_Setting=[BUSCLK]
I2S0_TxClkMode=[1]
I2S0_TxClkMode_Setting=[BUSCLK]
IRCLKSel=[1]
IRCLKSel_Setting=[IRC_32kHz]
IncludeSharedModules=[PE_Types|PE_Error|PE_Const|IO_Map]
InstructionClock=[undef]
LPTMR0_ClockSelect=[1]
LPTMR0_ClockSelect_Setting=[IRCLK]
LPTMR1_ClockSelect=[1]
LPTMR1_ClockSelect_Setting=[IRCLK]
MCGOUTSel=[1]
MCGOUTSel_Setting=[MCGFLLCLK]
MCG_FLL_MFactor=[1464]
MCG_FLL_MFactor_Setting=[1464]
MCG_FLL_RCLKSel=[1]
MCG_FLL_RCLKSel_Setting=[IRC_32kHz]
MCG_FRDIV=[1]
MCG_FRDIV_Setting=[1]
MCG_PRDIV=[1]
MCG_PRDIV_Setting=[1]
MCG_VDIV=[24]
MCG_VDIV_Setting=[24]
MTIM0ClkSource=[1]
MTIM0ClkSource_Setting=[BUSCLK]
ModuleList=[UART|usb_cdc|usb_host|USB_LDD]
OUTDIV=[2]
OUTDIV_Setting=[2]
PE_G_RTOSAdap_regCompInstanceAllocatedDevices=[UART0]
PE_G_RTOSAdap_regCompInstanceDeviceBaseAddrs=[4294934848]
PE_G_RTOSAdap_regCompInstanceIds=[0]
PE_G_RTOSAdap_regCompInstanceNames=[UART]
PE_G_RTOSAdap_regCompInstanceSharedComponentName=[UART]
PE_G_RTOSAdap_regCompInstanceTypes=[Serial_LDD]
PE_G_RTOSAdap_regCompInstance_UART_events=[OnBlockReceived|OnBlockSent|OnBreak|OnError|OnTxComplete|OnIdle|OnRxActiveEdge]
PE_G_RTOSAdap_regCompInstance_UART_methods=[Init|Deinit|Enable|Disable|SendBlock|ReceiveBlock|CancelBlockTransmission|CancelBlockReception|GetError|GetSentDataNum|GetReceivedDataNum|GetTxCompleteStatus|SetEventMask|GetEventMask|SelectBaudRate|GetSelectedBaudRate|SetParity|GetParity|SetDataWidth|GetDataWidth|SetStopBitLength|GetStopBitLength|SetLoopMode|GetLoopMode|GetStats|ClearStats|SetRTS|ClearRTS|GetCTS|SendBreak|GetBreak|TurnTxOn|TurnTxOff|TurnRxOn|TurnRxOff|ConnectPin|Main|SetOperationMode|GetDriverState]
SPI0_BaudRatePrescDiv=[1]
SPI0_BaudRatePrescDiv_Setting=[1]
SPI1_BaudRatePrescDiv=[1]
SPI1_BaudRatePrescDiv_Setting=[1]
SharedModules=[ColdFirePlus\PE_Types.drv|ColdFirePlus\PE_Error.drv|ColdFirePlus\PE_Const.drv|ColdFirePlus\IO_Map.drv]
SpeedModeList=[SpeedMode0]
SpeedModeNames=[SpeedMode0|SpeedMode1|SpeedMode2|SpeedMode3|SpeedMode4|SpeedMode5|SpeedMode6|SpeedMode7]
SystemPrescaler=[1]
SystemPrescaler_Setting=[1]
USB0_ClkSel=[1]
USB0_ClkSel_Setting=[USB0_FLL0Div]
USB0_FLL0Div=[1]
USB0_FLL0Div_Setting=[1]
USB0_FLL0Frac=[1]
USB0_FLL0Frac_Setting=[1]
USB0_PLL0Div=[1]
USB0_PLL0Div_Setting=[1]
USB0_PLL0Frac=[1]
USB0_PLL0Frac_Setting=[1]
virtual_ADC0_TotalConversionPrescaler=[1]
virtual_ADC0_TotalConversionPrescaler_Setting=[1]

{{DEVELOPMENT}} --------(((DEBUGINFO)))--------.{{DEVELOPMENT}} 

