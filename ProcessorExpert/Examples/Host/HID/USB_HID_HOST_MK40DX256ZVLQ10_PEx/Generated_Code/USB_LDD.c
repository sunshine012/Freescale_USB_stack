/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : USB_LDD.c
**     Project     : ProcessorExpert
**     Processor   : MK40DX256ZVLQ10
**     Component   : USB_LDD
**     Version     : Component 01.306, Driver 01.09, CPU db: 3.00.001
**     Compiler    : GNU C Compiler
**     Date/Time   : 2013-03-01, 15:31, # CodeGen: 3
**     Abstract    :
**         This component implements an low level USB API.
**     Settings    :
**          Component name                                 : USB_LDD
**          USB module (SIE)                               : USB0
**          Input clock frequency [MHz]                    : 48 MHz
**          Interrupt service/event                        : Enabled
**            Interrupt                                    : INT_USB0
**            Interrupt priority                           : medium priority
**          Mode                                           : HOST
**            Transceiver type                             : Internal
**              Transceiver module                         : USB0_FS
**              Transceiver weak pull-downs                : Enabled
**              USB revision                               : USB 2.0
**              Host data rates                            : 
**                Low speed                                : yes
**                Full speed                               : yes
**                High speed                               : no
**              Pin/signal setting                         : 
**                Clock pin                                : Disabled
**                USB data pins                            : 
**                  Data plus                              : 
**                    Pin                                  : USB0_DP
**                    Pin signal                           : 
**                  Data minus                             : 
**                    Pin                                  : USB0_DM
**                    Pin signal                           : 
**                VBUS pins                                : 
**                  VBUS enable                            : Disabled
**                  VBUS overcurrent                       : Disabled
**                Pullup/Pulldown pins                     : 
**                  DP pulldown                            : Enabled
**                    Pin                                  : USB0_Internal_DP_PD
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  DM pulldown                            : Enabled
**                    Pin                                  : USB0_Internal_DM_PD
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**            Host mode setting                            : 
**              Max. pipes                                 : 4
**              Max. transfers                             : 5
**              Asynchronous transfers                     : yes
**                Control transfers                        : yes
**                Bulk transfers                           : no
**              Periodic transfers                         : yes
**                Interrupt transfers                      : yes
**                Isochronous transfers                    : no
**            Initialization                               : 
**              Enabled in init. code                      : no
**              Auto initialization                        : no
**              Event mask                                 : 
**                OnHostDeviceDeattach                     : Enabled
**                OnHostResetRecovery                      : Enabled
**                OnHostResumeRecovery                     : Enabled
**                OnHostError                              : Enabled
**                OnHost1msTimer                           : Disabled
**                OnSignalChange                           : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component enabled
**            Clock configuration 2                        : This component enabled
**            Clock configuration 3                        : This component enabled
**            Clock configuration 4                        : This component enabled
**            Clock configuration 5                        : This component enabled
**            Clock configuration 6                        : This component enabled
**            Clock configuration 7                        : This component enabled
**     Contents    :
**         Init                    - LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr);
**         Deinit                  - void USB_LDD_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         SetEventMask            - LDD_TError USB_LDD_SetEventMask(LDD_TDeviceData *DeviceDataPtr,...
**         GetEventMask            - LDD_TEventMask USB_LDD_GetEventMask(LDD_TDeviceData *DeviceDataPtr);
**         Enable                  - LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable                 - LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr);
**         HostGetPortState        - LDD_USB_Host_TState USB_LDD_HostGetPortState(LDD_TDeviceData *DeviceDataPtr);
**         HostSetPortState        - LDD_TError USB_LDD_HostSetPortState(LDD_TDeviceData *DeviceDataPtr,...
**         HostGetFrameNumber      - uint16_t USB_LDD_HostGetFrameNumber(LDD_TDeviceData *DeviceDataPtr);
**         HostGetMicroFrameNumber - uint8_t USB_LDD_HostGetMicroFrameNumber(LDD_TDeviceData *DeviceDataPtr);
**         HostOpenPipe            - LDD_TError USB_LDD_HostOpenPipe(LDD_TDeviceData *DeviceDataPtr,...
**         HostClosePipe           - LDD_TError USB_LDD_HostClosePipe(LDD_TDeviceData *DeviceDataPtr,...
**         HostSendSetup           - LDD_TError USB_LDD_HostSendSetup(LDD_TDeviceData *DeviceDataPtr,...
**         HostSendData            - LDD_TError USB_LDD_HostSendData(LDD_TDeviceData *DeviceDataPtr,...
**         HostRecvData            - LDD_TError USB_LDD_HostRecvData(LDD_TDeviceData *DeviceDataPtr,...
**         HostGetTransferStatus   - LDD_USB_TTransferState USB_LDD_HostGetTransferStatus(LDD_TDeviceData...
**         HostCancelTransfer      - LDD_TError USB_LDD_HostCancelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         SetOperationMode        - LDD_TError USB_LDD_SetOperationMode(LDD_TDeviceData *DeviceDataPtr,...
**         GetDriverState          - LDD_TDriverState USB_LDD_GetDriverState(LDD_TDeviceData *DeviceDataPtr);
**
**     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE USB_LDD. */

#include "usb_host.h"
#include "USB_LDD.h"
/* {Default RTOS Adapter} No RTOS includes */
/*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */
#include "USB_PDD.h"

#define USB_LDD_AVAILABLE_EVENTS_MASK ((LDD_TEventMask)( \
          LDD_USB_ON_HOST_DEVICE_DEATTACH | \
          LDD_USB_ON_HOST_RESET_RECOVERY | \
          LDD_USB_ON_HOST_RESUME_RECOVERY | \
          LDD_USB_ON_HOST_ERROR))

#define USB_LDD_INIT_EVENTS_MASK ((LDD_TEventMask)( \
          LDD_USB_ON_HOST_DEVICE_DEATTACH | \
          LDD_USB_ON_HOST_RESET_RECOVERY | \
          LDD_USB_ON_HOST_RESUME_RECOVERY | \
          LDD_USB_ON_HOST_ERROR))

#define USB_LDD_AVAILABLE_IN_SIGNALS_MASK ((LDD_TPinMask)(0x00U))

#define USB_LDD_IN_SIGNALS_INIT_VALUE ((LDD_TPinMask)(0x00U))

/* BD Endpoint control access macros */
#define USB_LDD_BD_OWM                            0x00000080U
#define USB_LDD_BD_DATA0                          0x00000000U
#define USB_LDD_BD_DATA1                          0x00000040U
#define USB_LDD_BD_KEEP                           0x00000020U
#define USB_LDD_BD_NINC                           0x00000010U
#define USB_LDD_BD_DTS                            0x00000008U
#define USB_LDD_BD_STALL                          0x00000004U

#define USB_LDD_BD_PID_BUS_TIMEOUT                0x00000000U
#define USB_LDD_BD_PID_DATA0                      0x0000000CU
#define USB_LDD_BD_PID_DATA1                      0x0000002CU
#define USB_LDD_BD_PID_ACK                        0x00000008U
#define USB_LDD_BD_PID_STALL                      0x00000038U
#define USB_LDD_BD_PID_NACK                       0x00000028U
#define USB_LDD_BD_PID_DATA_ERROR                 0x0000003CU
#define USB_LDD_BD_PID_MASK                       0x0000003CU

#define USB_LDD_BD_LE_OWM                         0x80000000U
#define USB_LDD_BD_LE_DATA1                       0x40000000U
#define USB_LDD_BD_LE_STALL                       0x04000000U

#define USB_LDD_HOST_DEBOUNCE_INTERVAL_MS         0x64
#define USB_LDD_HOST_RESET_INTERVAL_MS            0x32
#define USB_LDD_HOST_RESET_RECOVERY_INTERVAL_MS   0x0A
#define USB_LDD_HOST_RESUME_INTERVAL_MS           0x14
#define USB_LDD_HOST_RESUME_RECOVERY_INTERVAL_MS  0x0A

#define MAX_PIPES                                 0x04u
#define MAX_TRANSFERS                             0x05u

#define LDD_USB_DIR_UNKNOWN                       0xFFu
#define USB_LDD_A_WAIT_VRISE_TIME_OUT_MS          0x64
#define USB_LDD_A_WAIT_BCON_SHORT_DEBOUCE_MS      0x01
#define USB_LDD_A_WAIT_BCON_LONG_DEBOUCE_MS       0x64
#define USB_LDD_A_WAIT_BCON_TIME_OUT_MS           0x044C
#define USB_LDD_A_IDLE_BDIS_TIME_OUT_MS           0xC8
#define USB_LDD_B_ASE0_TIME_OUT_MS                0x9B
#define USB_LDD_B_SE0_SRP_TIME_OUT_MS             0x03
#define USB_LDD_B_DATA_PLS_TIME_OUT_MS            0x07

/* OTG input variables */
#define USB_LDD_OTG_TIMEOUT                       0x80000000u
#define USB_LDD_OTG_1MS_TIMEOUT                   0x40000000u
#define USB_LDD_OTG_A_BUS_RESUME                  0x20000000u
#define USB_LDD_OTG_A_BUS_SUSPEND                 0x10000000u
#define USB_LDD_OTG_A_CONN                        0x08000000u
#define USB_LDD_OTG_A_SESSION_VALID               0x08u
#define USB_LDD_OTG_A_SRP_DET                     0x04000000u
#define USB_LDD_OTG_A_VBUS_VALID                  0x01u
#define USB_LDD_OTG_B_BUS_RESUME                  0x02000000u
#define USB_LDD_OTG_B_BUS_SUSPEND                 0x01000000u
#define USB_LDD_OTG_B_CONN                        0x00800000u
#define USB_LDD_OTG_B_SE0_SRP                     0x00400000u
#define USB_LDD_OTG_B_SESSION_VALID               0x08u
#define USB_LDD_OTG_B_SESSION_END                 0x04u
#define USB_LDD_OTG_ID                            0x80u

#define USB_LDD_OTG_VBUS_VALID                    0x01u
#define USB_LDD_OTG_SESSION_VALID                 0x08u

/* Informative variables */
#define USB_LDD_OTG_A_BUS_DROP                    0x00200000u
#define USB_LDD_OTG_A_BUS_REQ                     0x00100000u
#define USB_LDD_OTG_A_CLR_ERR                     0x00080000u
#define USB_LDD_OTG_A_SUSPEND_REQ                 0x00040000u
#define USB_LDD_OTG_B_BUS_REQ                     0x00020000u

/* Internal variables */
#define USB_LDD_TIMEOUT                           0x02u
#define USB_LDD_1MS_TIMEOUT                       0x40u
#define USB_LDD_OTG_A_SET_B_HNP_EN                0x00010000u
#define USB_LDD_OTG_B_SRP_DONE                    0x8000u
#define USB_LDD_OTG_B_HNP_EN                      0x4000u
#define USB_LDD_OTG_NOT_SE0                       0x2000u

#define USB_LDD_DEVICE_VBUS_DETECT                0x04u
#define USB_LDD_HOST_VBUS_OVERCURRENT             0x04u

#define USB_LDD_EnableTimer() USB_PDD_Enable1msInterrupt(USB0_BASE_PTR)

/* Buffer descriptor table item structure */
typedef struct USB_LDD_TBD_Struct {
  uint32_t                        CtrlReg;
  uint32_t                        BufferPtr;
} USB_LDD_TBD;

typedef enum {
  USB_LDD_PIPE_CLOSED            = 0x00u,
  USB_LDD_PIPE_IDLE              = 0x01u,
  USB_LDD_PIPE_BUSY              = 0x02u
} USB_LDD_TPipeState;

typedef enum {
  USB_LDD_TRANSFER_NONE               = 0x00u,
  USB_LDD_TRANSFER_DONE               = 0x01u,
  USB_LDD_TRANSFER_ERROR_CANCELLED    = 0x02u,
  USB_LDD_TRANSFER_ERROR_STALLED      = 0x03u,
  USB_LDD_TRANSFER_ERROR_BUS_TIMEOUT  = 0x04u,
  USB_LDD_TRANSFER_ERROR_DATA         = 0x05u,
  USB_LDD_TRANSFER_ERROR_PID          = 0x06u,
  USB_LDD_TRANSFER_ERROR_EOF          = 0x07u,
  USB_LDD_TRANSFER_ERROR_CRC16        = 0x08u,
  USB_LDD_TRANSFER_ERROR_DFN8         = 0x09u,
  USB_LDD_TRANSFER_ERROR_DMA          = 0x0Au,
  USB_LDD_TRANSFER_ERROR_BTS          = 0x0Bu,
  USB_LDD_TRANSFER_ERROR              = 0x0Fu,
  USB_LDD_TRANSFER_QUEUED             = 0x10u,
  USB_LDD_TRANSFER_PENDING            = 0x30u,
  USB_LDD_TRANSFER_DATA_QUEUED        = 0x50u,
  USB_LDD_TRANSFER_DATA_PENDING       = 0x70u,
  USB_LDD_TRANSFER_SETUP_QUEUED       = 0x90u,
  USB_LDD_TRANSFER_SETUP_PENDING      = 0xB0u,
  USB_LDD_TRANSFER_HSK_QUEUED         = 0xD0u,
  USB_LDD_TRANSFER_HSK_PENDING        = 0xF0u
} USB_LDD_TTrState;

/* Transfer descriptor (TD) structure */
typedef struct USB_LDD_TTrDescr_Struct {
  LDD_USB_Host_TTD                 Head;         /* Public part of the TD */
  USB_LDD_TTrState                 TrState;      /* Transfer state */
  uint8_t                         *tmpBufferPtr; /* Buffer address */
  struct USB_LDD_TTrDescr_Struct  *NextTrPtr;    /* Next TD address */
  uint8_t                          ErrorCounter; /* Transaction error counter */
} USB_LDD_TTrDescr;

/* Pipe descriptor (PD) structure */
typedef struct USB_LDD_TPipeDescr_Struct {
  LDD_USB_Host_TPipeDescr          Head;         /* Public part of the PD */
  struct USB_LDD_TPipeDescr_Struct *NextPipePtr; /* Next pipe address */
  USB_LDD_TPipeState               PipeState;    /* Pipe state */
  uint8_t                          NextData01;   /* DATA pid for next packet  */
  bool                             ZLT;
  USB_LDD_TTrDescr                *ActiveTrPtr;  /* Address of the first TD */
  USB_LDD_TTrDescr                *LastTrPtr;    /* Address of the first TD */
  uint8_t                          EpCtrlRegVal; /* Predefined value for EP control register */
  uint32_t                         NextFrameNum; /* Number of frame to perform next periodic. transaction */
} USB_LDD_TPipeDescr;


/* Device data structure */
typedef struct USB_LDD_TDeviceData_Struct {
  USB_LDD_TBD                      BDT[0x04];    /* Buffer descriptor array */
  LDD_USB_Host_TState              HostState;    /* Internal host engine state */
  USB_LDD_TPipeDescr               PDT[MAX_PIPES]; /* Pipe descriptor array */
  USB_LDD_TTrDescr                 TDT[MAX_TRANSFERS]; /* Transfer descriptor array */
  USB_LDD_TPipeDescr              *AsyncPipeListHeadPtr; /* Asynchronous pipes list head address */
  USB_LDD_TPipeDescr              *AsyncPipeListTailPtr; /* Asynchronous pipes list head address */
  USB_LDD_TPipeDescr              *PeriodicPipeListHeadPtr; /* Asynchronous pipes list head address */
  uint32_t                         PerTrFrameSize; /* Sum of opened per. pipes max packet sizes */
  uint32_t                         LastFrameNum; /* Last frame number */
  bool                             SofThresholdDetected; /* Sof threshold detected */
  USB_LDD_TTrDescr                *FreeTDListPtr; /* Free transfer descriptor list address */
  USB_LDD_TPipeDescr              *ActivePipePtr; /* Current device state */
  USB_LDD_TBD                     *RxBDPtr;      /* Empty Rx buffer descriptor address */
  USB_LDD_TBD                     *TxBDPtr;      /* Empty Tx buffer descriptor address */
  LDD_USB_TBusSpeed                BusSpeed;     /* Bus speed */
  LDD_TUserData                   *UserHostDataPtr; /* Host mode user device data structure */
  uint8_t                          SofThresholdValue; /* Sof threshold detected */
  bool                             ISR;          /* TRUE if ISR is in progress */
  LDD_TEventMask                   EventMask;    /* Event Mask */
  bool                             EnUser;       /* Enable/Disable device state variable */
  uint32_t                         InSignalsState; /* Input signals state variable */
  int32_t                          msCounter;    /* 1ms counter */
  LDD_TDriverOperationMode OperationMode;        /* Requested operation mode to change */
  LDD_TCallback ModeChangeCallback;              /* Operation mode callback */
  LDD_TCallbackParam *ModeChangeCallbackParamPtr; /* Operation mode callback parameter */
} USB_LDD_TDeviceData, *USB_LDD_TDeviceDataPtr;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static USB_LDD_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC __attribute__ ((aligned (512)));
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static USB_LDD_TDeviceDataPtr INT_USB0__DEFAULT_RTOS_ISRPARAM;
static void USB_LDD_StartTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout);
/*
** ===================================================================
**     Method      :  USB_LDD_UsbLock (component USB_LDD)
**
**     Description :
**         USB lock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbLock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_UsbUnlock (component USB_LDD)
**
**     Description :
**         USB unlock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbUnlock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_StartTimer (component USB_LDD)
**
**     Description :
**         Starts timer.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_StartTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout)
{
  DevDataPtr->msCounter = Timeout;                         /* Remember timeout */
  USB_LDD_EnableTimer();                                   /* Enable timer */
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostStartTransaction (component USB_LDD)
**
**     Description :
**         Starts transaction described by the TD on the head of the 
**         active pipe (DevDataPtr->ActivePipePtr->ActiveTrPtr)
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostStartTransaction(USB_LDD_TDeviceData *DevDataPtr) {
  USB_LDD_TBD                      *BDPtr;
  USB_LDD_TTrDescr                 *TrPtr;
  uint8_t                          *BufferPtr;
  uint32_t                          BDCtrlRegVal;
  uint8_t                           Token;

  TrPtr = DevDataPtr->ActivePipePtr->ActiveTrPtr;                    /* Get transfer descriptor */
  if (TrPtr->TrState == USB_LDD_TRANSFER_SETUP_QUEUED) {
   /* Setup packet */
    BDPtr               = DevDataPtr->TxBDPtr;                       /* Remember BD address */
    DevDataPtr->TxBDPtr = (USB_LDD_TBD *)((uint32_t)(DevDataPtr->TxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    BufferPtr           = (uint8_t*)TrPtr->Head.SDPPrt;              /* Remember setup data buffer address */
    BDCtrlRegVal        = 0x00080080U;                               /* Prepare BD ctrl. reg. value, Size =8, OWN = 1 DATA0 */
    Token               = (uint8_t)(LDD_USB_PID_SETUP << 0x04U);     /* Prepare Token reg. value (SETUP)*/
  } else {
    /* Data packet */
    BufferPtr           = TrPtr->tmpBufferPtr;                       /* Remember data buffer address */
    BDCtrlRegVal        = TrPtr->Head.BufferSize;                    /* Remember remaining data size */
    if (BDCtrlRegVal > DevDataPtr->ActivePipePtr->Head.MaxPacketSize) { /* Remaining data size > then Max packet size? */
      BDCtrlRegVal = DevDataPtr->ActivePipePtr->Head.MaxPacketSize;  /* Yes, send 'MaxPacketSize' length packet */
    }
    BDCtrlRegVal = (BDCtrlRegVal << 0x10) | USB_LDD_BD_OWM | DevDataPtr->ActivePipePtr->NextData01; /* Prepare BD ctrl. reg. value */
    if (DevDataPtr->ActivePipePtr->Head.EpDir == LDD_USB_DIR_OUT) {
      Token               = (uint8_t)(LDD_USB_PID_OUT << 0x04U);     /* Prepare Token reg. value (OUT)*/
      BDPtr               = DevDataPtr->TxBDPtr;                     /* Remember BD address */
      DevDataPtr->TxBDPtr = (USB_LDD_TBD *)((uint32_t)(DevDataPtr->TxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    } else {
      Token               = (uint8_t)(LDD_USB_PID_IN << 0x04U);      /* Prepare Token reg. value (IN)*/
      BDPtr               = DevDataPtr->RxBDPtr;                     /* Remember BD address */
      DevDataPtr->RxBDPtr = (USB_LDD_TBD *)((uint32_t)(DevDataPtr->RxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    }
  }
  TrPtr->TrState =  (USB_LDD_TTrState)((uint32_t)TrPtr->TrState | (uint32_t)USB_LDD_TRANSFER_PENDING); /* Update transfer state */
  BDPtr->BufferPtr = (uint32_t)BufferPtr;                            /* Set buffer address */
  BDPtr->CtrlReg = BDCtrlRegVal;                                     /* Set packet properties */
  Token = (uint8_t)(Token | DevDataPtr->ActivePipePtr->Head.EpNumber); /* Add EP address to the token reg. value */
  USB_PDD_WriteEp0CtrlReg(USB0_BASE_PTR, DevDataPtr->ActivePipePtr->EpCtrlRegVal); /* Set EP handshake and retry policy */
  USB_PDD_WriteAddressReg(USB0_BASE_PTR, DevDataPtr->ActivePipePtr->Head.DevAddress); /* Start transaction */
  USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear error flags */
  USB_PDD_WriteTokenReg(USB0_BASE_PTR, Token);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostQueueTransfer (component USB_LDD)
**
**     Description :
**         Queues transfer descriptor
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static  LDD_TError HostQueueTransfer(
  LDD_TDeviceData               *DeviceDataPtr,
  LDD_USB_Host_TPipeHandle      *PipeHndPtr,
  LDD_USB_Host_TTD              *TrDscrPtr,
  LDD_USB_Host_TTransferHandle **TrHndPtr,
  uint32_t                       TrDir
)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr = (USB_LDD_TPipeDescr*)PipeHndPtr;
  USB_LDD_TTrDescr                 *TrPtr;
  LDD_TError                        Res = ERR_OK;

  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PipePtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (TrDscrPtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((TrDir == LDD_USB_DIR_UNKNOWN) && (TrDscrPtr->SDPPrt == NULL)) {
    return ERR_PARAM_DATA;
  }
  USB_LDD_UsbLock(DeviceDataPtr);
  if (PipePtr->PipeState == USB_LDD_PIPE_CLOSED) {              /* Pipe closed? */
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_FAILED;                                          /* return with error */
  }
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) {
    Res = (LDD_TError)DevDataPtr->HostState;
  } else {
    TrPtr = DevDataPtr->FreeTDListPtr;                          /* Try to get a free TD */
    if (TrPtr != NULL) {                                        /* Found free TD? */
      DevDataPtr->FreeTDListPtr  = TrPtr->NextTrPtr;            /* Yes, dequeue it from free TD queue */
      *(LDD_USB_Host_TTD*)TrPtr  = *TrDscrPtr;                  /* Copy user transfer settings */
      TrPtr->tmpBufferPtr        = TrPtr->Head.BufferPtr;       /* Remember start of data buffer */
      TrPtr->ErrorCounter        = 0x03U;                       /* Max. 3 errors are allowed for transaction */
      TrPtr->NextTrPtr           = NULL;                        /* This is the last TD in the pipe's TD queue */
      if (PipePtr->ActiveTrPtr == NULL) {                       /* Transfer pending on this pipe? */
        PipePtr->ActiveTrPtr = TrPtr;                           /* No, put this TD on the pipe's TD queue head */
      } else {
        PipePtr->LastTrPtr->NextTrPtr = TrPtr;                  /* Tr. pending, put this TD on the pipe's TD queue tail */
      }
      PipePtr->LastTrPtr = TrPtr;                               /* Update pipe's TD queue tail pointer */
      if (TrDscrPtr->SDPPrt != NULL) {                          /* Control Transfer? */
        TrPtr->TrState      = USB_LDD_TRANSFER_SETUP_QUEUED;    /* Set transfer state */
        PipePtr->Head.EpDir = (uint8_t)(TrDscrPtr->SDPPrt->bmRequestType & (uint8_t)LDD_USB_DIR_MASK);
      } else {                                                  /* Non control transfer */
        TrPtr->TrState      = USB_LDD_TRANSFER_DATA_QUEUED;     /* Set transfer state */
        PipePtr->Head.EpDir = (uint8_t)TrDir;
      }

      if ((((uint32_t)PipePtr->Head.TransferType & 1U)) != 0x00U) { /* Periodic pipe? */
        PipePtr->NextFrameNum = 0U;                             /* Starts periodic transfer as soon as possible */
        USB_PDD_EnableSofInterrupt(USB0_BASE_PTR);
      } else {
        if (DevDataPtr->ActivePipePtr == NULL) {                /* Any transfer pending? */
          DevDataPtr->ActivePipePtr = PipePtr;                  /* No, make this pipe active */
          USB_LDD_HostStartTransaction(DevDataPtr);             /* Start transfers */
          USB_PDD_EnableTokenDoneInterrupt(USB0_BASE_PTR);
        }
      }
    } else {
      Res = ERR_QFULL;                                          /* No free transfer descriptor */
    }
    if (TrHndPtr != NULL) {                                     /* Request to return transfer handle? */
      *TrHndPtr = (LDD_USB_Host_TTransferHandle*)TrPtr;         /* Yes, put handle to the provided variable */
    }
  }
  USB_LDD_UsbUnlock(DeviceDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostTransferDone (component USB_LDD)
**
**     Description :
**         Transfer done handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostTransferDone(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TPipeDescr *PipePtr)
{
  USB_LDD_TTrDescr *TrPtr;

  /* Call user callback if required */
  TrPtr = PipePtr->ActiveTrPtr;        /* Remember current TD address */
  if (TrPtr->Head.CallbackFnPtr != NULL) {
    TrPtr->Head.CallbackFnPtr(
      DevDataPtr->UserHostDataPtr,
      TrPtr->Head.BufferPtr,
      (uint16_t)((uint32_t)TrPtr->tmpBufferPtr - (uint32_t)TrPtr->Head.BufferPtr),
      TrPtr->Head.ParamPtr,
      (LDD_USB_TTransferState)((uint32_t)(TrPtr->TrState) & (uint32_t)0x3F)
    );
  }
  /* Put TD back to the free TD list */
  PipePtr->ActiveTrPtr = TrPtr->NextTrPtr;                      /* Get next transfer descriptor for the pipe */
  TrPtr->NextTrPtr = DevDataPtr->FreeTDListPtr;                 /* Retun current TD to the free TD list */
  DevDataPtr->FreeTDListPtr = TrPtr;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostQueueFlush (component USB_LDD)
**
**     Description :
**         Removes all pending TDs from pipe's TD queue
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostQueueFlush(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TPipeDescr *PipePtr,USB_LDD_TTrState TrState)
{
  while (PipePtr->ActiveTrPtr) {       /* For all TDs in pipe's queue do: */
    PipePtr->ActiveTrPtr->TrState = TrState; /* Set requested transfer state */
    USB_LDD_HostTransferDone(DevDataPtr, PipePtr); /* Call transfer complete handler */
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_CloseAllPipes (component USB_LDD)
**
**     Description :
**         Closes all pipes and discards all pending transfers
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(USB_LDD_TDeviceData *DevDataPtr) {
  USB_LDD_TTrDescr                *TrPtr;
  uint32_t                         x;

  USB_LDD_UsbLock(DevDataPtr);
  DevDataPtr->FreeTDListPtr = &DevDataPtr->TDT[0x00]; /* Set FreeTDListPtr to the begin of TD array */
  TrPtr = DevDataPtr->FreeTDListPtr;   /* Go through the TD array and cancel all pending transfers */
  for (x = 0x00U; x < MAX_TRANSFERS; x++) {
    if (TrPtr->TrState >= USB_LDD_TRANSFER_QUEUED) { /* Pending transfer? */
      TrPtr->TrState = USB_LDD_TRANSFER_ERROR_CANCELLED; /* Call callback */
      if (TrPtr->Head.CallbackFnPtr != NULL) {
        TrPtr->Head.CallbackFnPtr(DevDataPtr->UserHostDataPtr, TrPtr->Head.BufferPtr, TrPtr->Head.BufferSize, TrPtr->Head.ParamPtr, LDD_USB_TRANSFER_ERROR_CANCELLED);
      }
    }
    TrPtr->NextTrPtr = TrPtr + 0x01;   /* Add next TD to the FreeTDListPtr list */
    TrPtr++;                           /* Take next TD item */
  }
  TrPtr->NextTrPtr = NULL;             /* Last TD in the array is the last item in the FreeTDList */
  for (x = 0x00U; x < MAX_PIPES; x++) { /* Go through the Pipe array and set pipe state to "CLOSED" */
    DevDataPtr->PDT[x].PipeState = USB_LDD_PIPE_CLOSED;
  }
  for (x = 0x00U; x < 0x04U; x++) {    /* Go through the Pipe array and set pipe state to "CLOSED" */
    DevDataPtr->BDT[x].CtrlReg = 0x00U;
  }
  USB_PDD_ResetBdtPingPong(USB0_BASE_PTR);
  USB_PDD_EnableControlEP(USB0_BASE_PTR, 0x00, PDD_DISABLE);
  DevDataPtr->AsyncPipeListHeadPtr = NULL;
  DevDataPtr->AsyncPipeListTailPtr = NULL;
  DevDataPtr->PeriodicPipeListHeadPtr = NULL;
  DevDataPtr->PerTrFrameSize = 0x00U;
  DevDataPtr->LastFrameNum = 0x00U;
  DevDataPtr->SofThresholdDetected = FALSE;
  DevDataPtr->SofThresholdValue = 0x00U;
  DevDataPtr->ActivePipePtr = NULL;
  DevDataPtr->RxBDPtr = &DevDataPtr->BDT[0x00];
  DevDataPtr->TxBDPtr = &DevDataPtr->BDT[0x02];
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostDisabledPort (component USB_LDD)
**
**     Description :
**         Sets the port to the DISABLED state and closes all pipes and 
**         discards all pending transfers. This state can be changed only 
**         by performing the bus reset(transfer to the ENABLED state), by 
**         disconnecting the device (transfer to the DISCONNECT state) or 
**         by the powering-off the bus (transfer to the POWERED_OFF 
**         state).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostDisabledPort(USB_LDD_TDeviceData *DevDataPtr) {
  /* Called from ISR if "disconnect" event is detected */
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
  USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);           /* This is necessary to correctly detect device speed */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Enable only "attach" interrupt */
  DevDataPtr->HostState = LDD_USB_HOST_PORT_DISABLED;
  USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostResetPort (component USB_LDD)
**
**     Description :
**         Sets the port to the RESET state, starts the reset signaling, 
**         and closes all pipes and discards all pending transfers. As 
**         soon as the reset interval is elapsed the reset signaling will 
**         be stopped, the port state will be change to the 
**         RESET_RECOVERING, and the reset recovery interval will begin. 
**         After the reset recovery interval is elapsed, the port state 
**         will be changed to the ENABLED state. In the ENABLED state the 
**         port can used to transfer data.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostResetPort(USB_LDD_TDeviceData *DevDataPtr) {
  do {
    USB_PDD_ClearTokenBusyFlag(USB0_BASE_PTR);
  } while (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR));
  DevDataPtr->HostState = LDD_USB_HOST_PORT_RESETING;           /* Set new state */
  USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);  /* Cancel all transfers */
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00);             /* Disable all interrupt */
  USB_PDD_StartResetSignaling(USB0_BASE_PTR, PDD_ENABLE);       /* Start reset signaling */
  USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESET_INTERVAL_MS + 1); /* Start reset signaling */
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSuspendPort (component USB_LDD)
**
**     Description :
**         Suspends port. No transaction should be pending before this 
**         method is called.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostSuspendPort(USB_LDD_TDeviceData *DevDataPtr) {
  DevDataPtr->HostState = LDD_USB_HOST_PORT_SUSPENDED;          /* Set new state */
  do {                                                          /* Wait till the token(SOF) is done */
  } while (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR));
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary not to detect false resume */
  USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);           /* This is necessary not to detect false resume */
  USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,0xFF);           /* Clear all interrupt flags */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_RESUME_INT); /* Enable "resume" interrupt */
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE);        /* Suspend transceiver */
  USB_LDD_StartTimer(DevDataPtr, 4);                             /* Enable deattach(USB 2.0 chapter 11.5.1.9) interrupt 4 ms later */
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostResumePort (component USB_LDD)
**
**     Description :
**         Resumes port.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostResumePort(USB_LDD_TDeviceData *DevDataPtr) {
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE);       /* Wake up transceiver */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Enable only "deattach" interrupt */
  if (DevDataPtr->BusSpeed == LDD_USB_LOW_SPEED) {
    USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_ENABLE); /* This is necessary not to detect false resume */
    USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_ENABLE);          /* This is necessary not to detect false resume */
  }
  USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_ENABLE);
  DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUMING;           /* Remember new state */
  USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESUME_INTERVAL_MS + 1); /* Start resume signaling */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Init (component USB_LDD)
**
**     Description :
**         Initializes USB device. Allocates memory for the device data
**         structure, interrupts, pins, etc. This method doesn't enable
**         device pull-up. Use Enable() method to enable device pull-up.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     Returns     :
**         ---             - Pointer to the dynamically allocated
**                           private structure or NULL if there was an
**                           error.
** ===================================================================
*/
LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr;

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(USB_LDD_TDeviceData));
  DevDataPtr->UserHostDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_USB0__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Interrupt vector(s) priority setting */
  /* NVICIP73: PRI73=0x80 */
  NVICIP73 = NVIC_IP_PRI73(0x80);                                                   
  /* NVICISER2: SETENA|=0x0200 */
  NVICISER2 |= NVIC_ISER_SETENA(0x0200);                                                   
  /* Clock setting */
  /* Input clock source:      PLL clock */
  /* Input clock frequency:   48 MHz */
  /* Input clock multiplier:  1 */
  /* Input clock divider:     1 */
  /* Module clock frequency:  48 MHz */
  /* SIM_SOPT2: USBSRC=1 */
  SIM_SOPT2 |= SIM_SOPT2_USBSRC_MASK;  /* Divided PllFll clock */
  /* SIM_CLKDIV2: USBDIV=0,USBFRAC=0 */
  SIM_CLKDIV2 &= (uint32_t)~(uint32_t)(
                  SIM_CLKDIV2_USBDIV(0x07) |
                  SIM_CLKDIV2_USBFRAC_MASK
                 );                    /* Div=1 - Mult=1  */
  /* Enable module clock */
  /* SIM_SCGC4: USBOTG=1 */
  SIM_SCGC4 |= SIM_SCGC4_USBOTG_MASK;                                                   
  /* Reset module */
  /* USB0_USBTRC0: USBRESET=1 */
  USB0_USBTRC0 = USB_USBTRC0_USBRESET_MASK; /* Reset module */
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Enable USB voltage regulator */
  /* SIM_SOPT1: ??=1 */
  SIM_SOPT1 |= 0x80U;                  /* Enable USB voltage regulator */
  /* USB0_USBCTRL: SUSP=1,PDE=0 */
  USB0_USBCTRL = USB_USBCTRL_SUSP_MASK; /* Enable weak pull-downs and suspend transceiver */
  /* USB0_OTGCTL: DPHIGH=0,??=0,DPLOW=1,DMLOW=1,??=0,OTGEN=1,??=0,??=0 */
  USB0_OTGCTL = USB_OTGCTL_DPLOW_MASK |
                USB_OTGCTL_DMLOW_MASK |
                USB_OTGCTL_OTGEN_MASK;                       
  /* Set BDT address */
  USB0_BDTPAGE1 = (uint8_t)((((uint32_t)DevDataPtr) >> 8) & 0xFEU);
  USB0_BDTPAGE2 = (uint8_t)((((uint32_t)DevDataPtr) >> 16) & 0xFFU);
  USB0_BDTPAGE3 = (uint8_t)((((uint32_t)DevDataPtr) >> 24) & 0xFFU);
  /* Initialize device data structure */
  DevDataPtr->HostState = LDD_USB_HOST_DISABLED;
  DevDataPtr->msCounter = -1;                               /* No timing request */
  DevDataPtr->EventMask = USB_LDD_INIT_EVENTS_MASK;
  DevDataPtr->OperationMode = DOM_NONE;                     /* No request to change the operation mode is pending */
  DevDataPtr->EnUser = FALSE;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID,DevDataPtr);
  return (LDD_TDeviceData*)(DevDataPtr);                    /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Deinit (component USB_LDD)
**
**     Description :
**         Disables and deinitializes the device and frees the device
**         data structure memory.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     : Nothing
** ===================================================================
*/
void USB_LDD_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  (void)DevDataPtr;                                        /* Parameter is not used, suppress unused argument warning */
  /* {Default RTOS Adapter} Critical section begin, general PE function is used */
  EnterCritical();
  /* Reset module */
  USB_PDD_ResetModule(USB0_BASE_PTR);
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Disable module clock */
  /* SIM_SCGC4: USBOTG=0 */
  SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);                                                   
  /* {Default RTOS Adapter} Critical section end, general PE function is used */
  ExitCritical();
  /* Restoring the interrupt vector */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID);
  /* Deallocation of the device structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
}

/*
** ===================================================================
**     Method      :  USB_LDD_SetEventMask (component USB_LDD)
**
**     Description :
**         Enables/disables event(s). The events contained within the
**         mask are enabled. Events not contained within the mask are
**         disabled. Pair method to GetEventMask().
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EventMask       - Mask of events to enable.
**     Returns     :
**         ---             - Return value:
**                           ERR_OK
**                           ERR_PARAM_MASK - Invalid mask.
**                           ERR_DISABLED - Device is disabled.
** ===================================================================
*/
LDD_TError USB_LDD_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EventMask & (LDD_TEventMask)~USB_LDD_AVAILABLE_EVENTS_MASK) {
    return ERR_PARAM_MASK;
  }
  USB_LDD_UsbLock(DevDataPtr);
  DevDataPtr->EventMask = EventMask;
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_GetEventMask (component USB_LDD)
**
**     Description :
**         Returns current events mask. Pair method to SetEventMask().
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Current event mask.
** ===================================================================
*/
LDD_TEventMask USB_LDD_GetEventMask(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  return DevDataPtr->EventMask;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Enable (component USB_LDD)
**
**     Description :
**         Enables the USB device (PHY, SIE). Enables device's DP(DM)
**         pull-up.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - 
** ===================================================================
*/
LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {
    DevDataPtr->EnUser = TRUE;
    USB_LDD_UsbLock(DevDataPtr);
    USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);   /* Disable all "Error" interrupts */
    USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear "Attach" interrupt flag */
    USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_ATTACH_INT); /* Enable "Attach" interrupt */
    DevDataPtr->msCounter = -1;                            /* No timing request */
    DevDataPtr->PerTrFrameSize = 0x00U;                    /* No bus bandwidth is allocated */
    DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Update state variable */
    USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE); /* Enable transceiver */
    USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) | (uint8_t)0x30)); /* Enable D+- pull-downs. Enable VBUS */
    USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);            /* Disable "1ms" interrupt */
    USB_PDD_EnableHost(USB0_BASE_PTR, PDD_ENABLE);         /* Enable host mode */
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Disable (component USB_LDD)
**
**     Description :
**         Disabled device's DP(DM) pull-up. Disables PHY, etc.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - 
** ===================================================================
*/
LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  DevDataPtr->OperationMode = DOM_NONE;                     /* No request to change the operation mode is pending */
  if (DevDataPtr->EnUser) {
    DevDataPtr->EnUser = FALSE;
    USB_LDD_UsbLock(DevDataPtr);
    if (DevDataPtr->HostState > LDD_USB_HOST_PORT_DISCONNECTED) {
      DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED;
      if (DevDataPtr->EventMask & LDD_USB_ON_HOST_DEVICE_DEATTACH) {
        USB_LDD_OnHostDeviceDeattach(DevDataPtr->UserHostDataPtr);
      }
    }
    DevDataPtr->HostState = LDD_USB_HOST_DISABLED;         /* Update state variable */
    DevDataPtr->msCounter = -1;                            /* No timing request */
    USB_PDD_DisableModule(USB0_BASE_PTR);                  /* Disable module */
    USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE); /* Disable transceiver */
    USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);            /* Disable "1ms" interrupt */
    USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);   /* Disable all "Error" interrupts */
    USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00U);     /* Disable all "Usb" interrupts */
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetPortState (component USB_LDD)
**
**     Description :
**         Returns port <state>.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Returned value:
**                           LDD_USB_HOST_DISABLED - Host mode is
**                           disabled (by the user or by the clock
**                           configuration).
**                           LDD_USB_HOST_DISABLED_BY_OTG - Host mode is
**                           disabled by the OTG driver.
**                           LDD_USB_HOST_PORT_POWERED_OFF - Port is
**                           powered-off.
**                           LDD_USB_HOST_PORT_DISCONNECTED -  No device
**                           is connected.
**                           LDD_USB_HOST_PORT_DISABLED - Device is
**                           connected to the port.
**                           LDD_USB_HOST_PORT_RESETING - Port generates
**                           reset signaling.
**                           LDD_USB_HOST_PORT_RESET_RECOVERING - Port
**                           waits 10 ms for reset recovery.
**                           LDD_USB_HOST_PORT_ENABLED - Device is
**                           connected, reset and ready to use.
**                           LDD_USB_HOST_PORT_SUSPENDED - Port is
**                           suspended.
**                           LDD_USB_HOST_PORT_RESUME_READY - Port is
**                           ready to generate resume signaling.
**                           LDD_USB_HOST_PORT_RESUMING - Port generates
**                           resume signaling.
**                           LDD_USB_HOST_PORT_RESUME_RECOVERING - Port
**                           waits 10 ms for resume recovery.
** ===================================================================
*/
LDD_USB_Host_TState USB_LDD_HostGetPortState(LDD_TDeviceData *DeviceDataPtr)
{
  return (((USB_LDD_TDeviceData*)DeviceDataPtr)->HostState);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSetPortState (component USB_LDD)
**
**     Description :
**         This method sets root port (bus) states. Supported commands
**         are:
**         [LDD_USB_HOST_PORT_CMD_POWER_OFF]
**         Deactivates VBUS enable signal and sets the port to the
**         POWER_OFF state, closes all pipes and discards all pending
**         transfers.
**         [LDD_USB_HOST_PORT_CMD_POWER_ON]
**         Activates VBUS enable signal and sets the port to the
**         DISCONNECTED state.
**         Port must be in the POWERED_OFF state to be power on.
**         [LDD_USB_HOST_PORT_CMD_RESET]
**         Sets the port to the RESETING state, starts the reset
**         signaling and closes all pipes and discards all pending
**         transfers. As soon as the reset interval is elapsed the
**         reset signaling will be stopped, the port state will be
**         change to the RESET_RECOVERING, and the reset recovery
**         interval will begin. After the reset recovery interval is
**         elapsed, the port state will be changed to the ENABLED state.
**         In the ENABLED state the port can used to transfer data.
**         Device must be connected (ports state > DISCONNECTED) before
**         reset can be started.
**         [LDD_USB_HOST_PORT_CMD_DISABLE]
**         Sets the port to the DISABLED state and closes all pipes and
**         discards all pending transfers. This state can be changed
**         only by performing the bus reset(transfer to the ENABLED
**         state), by disconnecting the device (transfer to the
**         DISCONNECT state) or by the powering-off the bus (transfer
**         to the POWERED_OFF state).
**         [LDD_USB_HOST_PORT_CMD_SUSPEND]
**         Suspends port (state = SUSPENDED). No transaction should be
**         pending before this method is called.
**         Port must be in the LDD_USB_HOST_PORT_ENABLED state to be
**         suspend.
**         [LDD_USB_HOST_PORT_CMD_RESUME]
**         Sets the port to the RESUMING state and starts the resume
**         signaling. After the resume interval is elapsed, the port
**         state will be changed to the ENABLED state. In the ENABLED
**         state the port can used to transfer data.
**         Port must be in the LDD_USB_HOST_PORT_RESUME_READY state
**         before resume can start.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         Cmd             - Command
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Requested operation cannot be is
**                           done in current <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostSetPortState(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPortControlCmd Cmd)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res = (LDD_TError)DevDataPtr->HostState;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if ((uint32_t)DevDataPtr->HostState < (uint32_t)LDD_USB_HOST_PORT_POWERED_OFF) { /* */
    Res = (LDD_TError)DevDataPtr->HostState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }

  if (DevDataPtr->HostState >= LDD_USB_HOST_PORT_POWERED_OFF) { /* Is host enabled? */
    switch (Cmd) {
      case LDD_USB_HOST_PORT_CMD_POWER_OFF:
        /* Deactivates VBUS enable signal, sets the port to the POWER_OFF state */
        /* closes all pipes and discards all pending transfers. */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_POWERED_OFF; /* Remember new state */
        USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
        if (DevDataPtr->OperationMode != DOM_NONE) {
          (void)USB_LDD_SetOperationMode(DevDataPtr, DevDataPtr->OperationMode, DevDataPtr->ModeChangeCallback, DevDataPtr->ModeChangeCallbackParamPtr);
        }
        Res = ERR_OK;
        break;
      case LDD_USB_HOST_PORT_CMD_POWER_ON:
        /* Activates VBUS enable signal and sets the port to the DISCONNECTED state. */
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_POWERED_OFF) { /* Is port powered-off? */
          DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Remember new state */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_RESET:
        /* See description of the HostResetPort() method */
        if (DevDataPtr->HostState > LDD_USB_HOST_PORT_DISCONNECTED) { /* Is a device connected? */
          USB_LDD_HostResetPort(DevDataPtr);               /* Yes, start reset signaling */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_DISABLE:
        /* See description of the DisablePort() method */
        USB_LDD_HostDisabledPort(DevDataPtr);              /* Disable port */
        Res = ERR_OK;
        break;
      case LDD_USB_HOST_PORT_CMD_SUSPEND:
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_ENABLED) { /* Is a device enabled? */
          /* See description of the HostResumePort() method */
          USB_LDD_HostSuspendPort(DevDataPtr);             /* Yes, suspend device */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_RESUME:
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_RESUME_READY) { /* Is the device suspended at least 3 ms? */
          /* See description of the HostResumePort() method */
          USB_LDD_HostResumePort(DevDataPtr);              /* Yes, start resume signaling */
          Res = ERR_OK;
        }
        break;
      default:
        Res = ERR_PARAM_COMMAND;                           /* Unknown command */
        break;
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return(Res);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetFrameNumber (component USB_LDD)
**
**     Description :
**         This method returns current frame number.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Frame number.
** ===================================================================
*/
uint16_t USB_LDD_HostGetFrameNumber(LDD_TDeviceData *DeviceDataPtr)
{
  uint32_t                         FrameNumber;

  (void)DeviceDataPtr;                                     /* Parameter is not used, suppress unused argument warning */
  FrameNumber = ((uint32_t)(USB_PDD_GetFrameNumberHigh(USB0_BASE_PTR)) << 0x08); /* Get current frame number */
  FrameNumber |= (uint32_t)(USB_PDD_GetFrameNumberLow(USB0_BASE_PTR));
  return ((uint16_t)FrameNumber);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetMicroFrameNumber (component USB_LDD)
**
**     Description :
**         This method returns current microframe number.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Microframe number.
** ===================================================================
*/
uint8_t USB_LDD_HostGetMicroFrameNumber(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr;                                     /* Parameter is not used, suppress unused argument warning */
  /* Not implemented for FULL speed */
  return 0x00U;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostOpenPipe (component USB_LDD)
**
**     Description :
**         Initializes pipe according to the values in the endpoint
**         descriptor and in the flags parameter. Allocate bandwidth
**         for periodic transfer types.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeInitParamsPtr - Pointer to the
**                           structure containing pipe configuration
**                           data.
**       * PipeHandlePtr   - Pointer to pipe handle
**                           variable.
**     Returns     :
**         ---             - Return value:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ID - Requested transfer is not
**                           supported by the HW .
**                           ERR_OVERFLOW - Not enough frame time for
**                           periodic transfer type.
**                           ERR_OK - OK
** ===================================================================
*/
LDD_TError USB_LDD_HostOpenPipe(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeInitParamsPtr, LDD_USB_Host_TPipeHandle **PipeHandlePtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr;
  LDD_TError                        Res = ERR_OVERFLOW;
  uint32_t                          x;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  *PipeHandlePtr = NULL;                                   /* Suppose bad params */
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) { /* Port enabled? */
    Res = (LDD_TError)DevDataPtr->HostState;               /* No, remember error code */
  } else {
    /* If periodic pipe is being opened make sure that at least 20% time frame remains for asynchronous transfers. */
    if (((uint32_t)PipeInitParamsPtr->TransferType & 1U)) { /* Periodic pipe? */
      if ((DevDataPtr->PerTrFrameSize + PipeInitParamsPtr->MaxPacketSize) > 9600U) { /* More then 80% of the frame time allocated by periodic transfers? */
        USB_LDD_UsbUnlock(DevDataPtr);                     /* Yes, return with error */
        return ERR_OVERFLOW;
      }
    }
    for (x = 0x00U; x < MAX_PIPES; x++) {                  /* Try to find empty pipe descriptor */
      PipePtr = &DevDataPtr->PDT[x];                       /* Get pipe descriptor */
      if (PipePtr->PipeState == USB_LDD_PIPE_CLOSED) {     /* Free descriptor found? */
        Res = ERR_OK;                                      /* Yes, stop the loop */
        break;
      }
    }
    if (Res == ERR_OK) {                                   /* Empty pipe descriptor found? */
      if (DevDataPtr->BusSpeed == LDD_USB_FULL_SPEED) {    /* Compute SOF threshold */
        x = ((((0x65U + ((uint32_t)PipeInitParamsPtr->MaxPacketSize * 0x08U)) * 0x07U) / 0x06U) / 0x08U);
      } else {
        x = (((0x65U + ((uint32_t)PipeInitParamsPtr->MaxPacketSize * 0x08U)) * 0x07U) / 0x06U);
      }
      if (DevDataPtr->SofThresholdValue < x) {             /* New threshold greater then current value? */
        DevDataPtr->SofThresholdValue = (uint8_t)x;        /* Yes, remember and set new threshold value */
        USB_PDD_SetSofTresholdReg(USB0_BASE_PTR, DevDataPtr->SofThresholdValue);
      }
      DevDataPtr->PerTrFrameSize += PipeInitParamsPtr->MaxPacketSize; /* Update per. transfer frame size */
      switch (PipeInitParamsPtr->TransferType) {
        case LDD_USB_CONTROL:                              /* Control pipe? */
          /* Add the pipe to the BEGIN of the async. pipe list */
          if (DevDataPtr->AsyncPipeListTailPtr == NULL) {  /* Async. list empty? */
            DevDataPtr->AsyncPipeListTailPtr = PipePtr;    /* The new pipe is also last pipe in the list */
          }
          PipePtr->NextPipePtr = DevDataPtr->AsyncPipeListHeadPtr; /* Add the pipe to the begin of the async. pipe list */
          DevDataPtr->AsyncPipeListHeadPtr = PipePtr;      /* Update head list address */
          PipePtr->EpCtrlRegVal = 0x4DU;                   /* Remember value for EP control register */
          break;
        case LDD_USB_INTERRUPT:                            /* Interrupt pipe? */
          /* Add the pipe to the begin of the periodic pipe list */
          PipePtr->NextPipePtr = DevDataPtr->PeriodicPipeListHeadPtr; /* Add the pipe to the begin of the pipe list */
          DevDataPtr->PeriodicPipeListHeadPtr = PipePtr;   /* Update head list address */
          PipePtr->EpCtrlRegVal = 0x5DU;                   /* Remember value for EP control register */
          break;
        default:
          Res = ERR_PARAM_ID;
          break;
      }
      if (Res == ERR_OK) {                                 /* Empty pipe descriptor found? */
        PipePtr->Head = *PipeInitParamsPtr;                /* Yes, copy pipe setting */
        PipePtr->PipeState = USB_LDD_PIPE_IDLE;            /* Set pipe state */
        PipePtr->ActiveTrPtr = NULL;                       /* Initialize Activ transfer pointer */
        PipePtr->LastTrPtr = NULL;                         /* Initialize Last transfer pointer */
        *PipeHandlePtr = PipePtr;                          /* Set pipe local data address as handle */
        PipePtr->NextData01 = (uint8_t)0x00U;              /* Set DATA0 as default DATA PID */
        if (DevDataPtr->BusSpeed == LDD_USB_LOW_SPEED) {   /* Directly connected Low speed device(without hub)? */
          PipePtr->Head.DevAddress |= (uint8_t)0x80U;      /* Transaction to this EP must be performed all low-speed */
          PipePtr->EpCtrlRegVal |= (uint8_t)0x80U;         /* Disable PRE_PID */
        } else if (PipePtr->Head.DevSpeed == LDD_USB_LOW_SPEED) { /* Low speed device after a hub? */
          PipePtr->Head.DevAddress |= (uint8_t)0x80U;      /* Transaction to this EP must be performed all low-speed */
        } else {
        }
      }
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostClosePipe (component USB_LDD)
**
**     Description :
**         Deinitializes EP and disables it in the HW. For control EP
**         both directions are deinitialized. All pending transfers are
**         aborted and callback functions are called, if enabled.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle
**     Returns     :
**         ---             - Return value:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_OK - OK
** ===================================================================
*/
LDD_TError USB_LDD_HostClosePipe(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr = (USB_LDD_TPipeDescr*)PipeHandlePtr;
  USB_LDD_TPipeDescr               *LeftPipePtr,*tmpPipePtr;
  uint32_t                          x,y;
  LDD_TError                        Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if ((uint32_t)DevDataPtr->HostState < (uint32_t)LDD_USB_HOST_PORT_POWERED_OFF) { /* */
    Res = (LDD_TError)DevDataPtr->HostState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  if (PipePtr->PipeState != USB_LDD_PIPE_CLOSED) {         /* Pipe opened? */
    LeftPipePtr = NULL;
    DevDataPtr->SofThresholdValue = 0U;                    /* Reset SOF threshold variable value */
    for (x = 0x00U; x < MAX_PIPES; x++) {                  /* Find ascendant pipe and compute new SOF threshold value */
      tmpPipePtr = &DevDataPtr->PDT[x];
      if (tmpPipePtr->PipeState != USB_LDD_PIPE_CLOSED) {  /* Pipe opened? */
        if (tmpPipePtr != PipePtr) {
          if (DevDataPtr->BusSpeed == LDD_USB_FULL_SPEED) { /* Compute SOF threshold */
            y = ((((0x65U + ((uint32_t)tmpPipePtr->Head.MaxPacketSize * 0x08U)) * 0x07U) / 0x06U) / 0x08U);
          } else {
            y = (((0x65U + ((uint32_t)tmpPipePtr->Head.MaxPacketSize * 0x08U)) * 0x07U) / 0x06U);
          }
          if (DevDataPtr->SofThresholdValue < y) {         /* New threshold greater then current value? */
            DevDataPtr->SofThresholdValue = (uint8_t)y;    /* Yes, remember and set new threshold value */
          }
        }
      }
      if (tmpPipePtr->NextPipePtr == PipePtr) {            /* Ascendant pipe found? */
        tmpPipePtr->NextPipePtr = PipePtr->NextPipePtr;    /* Update its' pointer to the next item */
        LeftPipePtr = tmpPipePtr;
        break;
      }
    }
    USB_PDD_SetSofTresholdReg(USB0_BASE_PTR, DevDataPtr->SofThresholdValue); /* Set new SOF threshold value? */
    if (DevDataPtr->AsyncPipeListHeadPtr == PipePtr) {     /* Is the pipe on the head of async. pipe list */
      DevDataPtr->AsyncPipeListHeadPtr = PipePtr->NextPipePtr; /* remove it from the list head */
    }
    if (DevDataPtr->AsyncPipeListTailPtr == PipePtr) {
      DevDataPtr->AsyncPipeListTailPtr = LeftPipePtr;
    }
    if (DevDataPtr->PeriodicPipeListHeadPtr == PipePtr) {
      DevDataPtr->PeriodicPipeListHeadPtr = PipePtr->NextPipePtr;
      DevDataPtr->PerTrFrameSize -= (uint32_t)PipePtr->Head.MaxPacketSize;
    }
    USB_LDD_HostQueueFlush(DevDataPtr, PipePtr, USB_LDD_TRANSFER_ERROR_CANCELLED);
    PipePtr->PipeState = USB_LDD_PIPE_CLOSED;              /* Set pipe state */
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSendSetup (component USB_LDD)
**
**     Description :
**         This method prepares control transfer. All transfer phases
**         are handled by this method.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle.
**       * TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**       * TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe descriptor pointer is NULL.
**                           ERR_PARAM_DATA - Pointer to the Setup data
**                           packet is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostSendSetup(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_UNKNOWN);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSendData (component USB_LDD)
**
**     Description :
**         This method prepares data to be sent to the device.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle.
**       * TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**       * TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostSendData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_OUT);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostRecvData (component USB_LDD)
**
**     Description :
**         This method prepares buffer for data sent by the device.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle.
**       * TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**       * TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostRecvData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_IN);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetTransferStatus (component USB_LDD)
**
**     Description :
**         This method returns transfer status.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * TransferHandlePtr - Pointer to
**                           transfer handle return by Send/Recv methods
**                           in the 'TransferDescriptorPtr' variable.
**     Returns     :
**         ---             - Transfer status.
** ===================================================================
*/
LDD_USB_TTransferState USB_LDD_HostGetTransferStatus(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TTransferHandle *TransferHandlePtr)
{
  (void)DeviceDataPtr;                                     /* Parameter is not used, suppress unused argument warning */
  return ((LDD_USB_TTransferState)((uint32_t)(((USB_LDD_TTrDescr*)TransferHandlePtr)->TrState) & 0x3FU));
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostCancelTransfer (component USB_LDD)
**
**     Description :
**         This method cancels all pending transfer requests in the
**         given EP queue. Callback function is called ( if enabled)
**         for each cancelled transfer request.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostCancelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeHandlePtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr = (USB_LDD_TPipeDescr*)PipeHandlePtr;
  LDD_TError                        Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PipePtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  USB_LDD_UsbLock(DeviceDataPtr);
  if (PipePtr->PipeState == USB_LDD_PIPE_CLOSED) {         /* Pipe closed? */
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_FAILED;                                     /* Yes, return with error */
  }
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) { /* Port enabled? */
    Res = (LDD_TError)DevDataPtr->HostState;               /* Yes, return with error */
  } else {
    USB_LDD_HostQueueFlush(DevDataPtr, PipePtr, USB_LDD_TRANSFER_ERROR_CANCELLED);
    Res = ERR_OK;                                          /* return with error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_SetOperationMode (component USB_LDD)
**
**     Description :
**         This method requests to change the component's operation
**         mode. Upon a request to change the operation mode, the
**         component will finish a pending job first and then notify a
**         caller that an operation mode has been changed. When no job
**         is pending (ERR_OK), the component changes an operation mode
**         immediately and notify a caller about this change. 
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         OperationMode   - Requested driver
**                           operation mode.
**         ModeChangeCallback - Callback to
**                           notify the upper layer once a mode has been
**                           changed.
**       * ModeChangeCallbackParamPtr 
**                           - Pointer to callback parameter to notify
**                           the upper layer once a mode has been
**                           changed.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - This component is disabled
**                           by user.
**                           ERR_PARAM_MODE - Invalid operation mode.
**                           ERR_BUSY - A job is pending.
** ===================================================================
*/
LDD_TError USB_LDD_SetOperationMode(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr)
{
  USB_LDD_TDeviceDataPtr DevDataPtr = (USB_LDD_TDeviceDataPtr)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  if (DevDataPtr->HostState > LDD_USB_HOST_PORT_POWERED_OFF) {
    DevDataPtr->OperationMode = OperationMode; /* Set requested operation mode to change */
    DevDataPtr->ModeChangeCallback = ModeChangeCallback; /* Set callback pointer to notify after mode change */
    DevDataPtr->ModeChangeCallbackParamPtr = ModeChangeCallbackParamPtr; /* Set callback parameter */
  } else {
    switch (OperationMode) {
      case DOM_RUN:
        /* SIM_SCGC4: USBOTG=1 */
        SIM_SCGC4 |= SIM_SCGC4_USBOTG_MASK;                                                   
        USB_PDD_DisableAsyncResumeInterrupt(USB0_BASE_PTR);
        break;
      case DOM_WAIT:
        /* SIM_SCGC4: USBOTG=0 */
        SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);                                                   
        USB_PDD_ClearAsyncResumeInterruptFlag(USB0_BASE_PTR);
        USB_PDD_EnableAsyncResumeInterrupt(USB0_BASE_PTR);
        break;
      case DOM_SLEEP:
        USB_PDD_DisableAsyncResumeInterrupt(USB0_BASE_PTR);
        /* SIM_SCGC4: USBOTG=0 */
        SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);                                                   
        break;
      case DOM_STOP:
        USB_PDD_DisableAsyncResumeInterrupt(USB0_BASE_PTR);
        /* SIM_SCGC4: USBOTG=0 */
        SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);                                                   
        break;
      default:
        return ERR_PARAM_MODE;         /* Invalid Operation mode parameter */
    }
    if (ModeChangeCallback != NULL) {
      ModeChangeCallback(ModeChangeCallbackParamPtr); /* Invoke a callback */
      DevDataPtr->OperationMode = DOM_NONE; /* No request to change the operation mode is pending */
      DevDataPtr->ModeChangeCallback = NULL; /* Clear the pointer to the callback  */
      DevDataPtr->ModeChangeCallbackParamPtr = NULL; /* Clear the pointer to the callback parameter */
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_GetDriverState (component USB_LDD)
**
**     Description :
**         This method returns the current driver status.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - The current driver status mask.
**                           Following status masks defined in PE_LDD.h
**                           can be used to check the current driver
**                           status.
**                           PE_LDD_DRIVER_DISABLED_IN_CLOCK_CONFIGURATIO
**                           N - 1 - Driver is disabled in the current
**                           mode; 0 - Driver is enabled in the current
**                           mode.  
**                           PE_LDD_DRIVER_DISABLED_BY_USER - 1 - Driver
**                           is disabled by the user; 0 - Driver is
**                           enabled by the user.        
**                           PE_LDD_DRIVER_BUSY - 1 - Driver is the BUSY
**                           state; 0 - Driver is in the IDLE state.
** ===================================================================
*/
LDD_TDriverState USB_LDD_GetDriverState(LDD_TDeviceData *DeviceDataPtr)
{
  LDD_TDriverState DriverState = 0x00U;
  USB_LDD_TDeviceDataPtr DevDataPtr = (USB_LDD_TDeviceDataPtr)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {           /* Driver disabled by the user? */
    DriverState |= PE_LDD_DRIVER_DISABLED_BY_USER;
  }
  if (DevDataPtr->HostState > LDD_USB_HOST_PORT_POWERED_OFF) {
    DriverState |= PE_LDD_DRIVER_BUSY;
  }
  return DriverState;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetPeriodicTransactionReadyPipe (component USB_LDD)
**
**     Description :
**         Returns pointer to the periodic pipe that has transaction 
**         ready for this frame.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static USB_LDD_TPipeDescr* USB_LDD_HostGetPeriodicTransactionReadyPipe(USB_LDD_TPipeDescr *PipePtr, uint32_t CurrentFrameNum)
{
  /* Find periodic pipe ready to start transaction in this frame */
  while (PipePtr != NULL) {                                /* Till the end of periodic list do: */
    if (PipePtr->ActiveTrPtr != NULL) {                    /* Transfer pending on selected pipe? */
      if (PipePtr->NextFrameNum <= CurrentFrameNum) {      /* Time to perform transaction? */
        PipePtr->NextFrameNum += (uint32_t)PipePtr->Head.Interval; /* Update next time */
        break;                                             /* Start transaction on the selected pipe */
      }
    }
    PipePtr = PipePtr->NextPipePtr;
  }
  return PipePtr;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetAsyncTransactionReadyPipe (component USB_LDD)
**
**     Description :
**         Returns pointer to the periodic pipe that has transaction 
**         ready for this frame.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static USB_LDD_TPipeDescr* USB_LDD_HostGetAsyncTransactionReadyPipe(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TPipeDescr *PipePtr)
{
  USB_LDD_TPipeDescr              *NextPipePtr;

  if (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR)) {
    return NULL;
  }

  if (PipePtr == NULL) {                                   /* Last pipe in the async. pipe list? */
    PipePtr = DevDataPtr->AsyncPipeListHeadPtr;            /* Yes, start from the begin of the async. list */
  }
  NextPipePtr = PipePtr;
  do {
    NextPipePtr = NextPipePtr->NextPipePtr;
    if (NextPipePtr == NULL) {                             /* Last pipe in the async. pipe list? */
      NextPipePtr = DevDataPtr->AsyncPipeListHeadPtr;      /* Yes, start from the begin of the async. list */
    }
    if (NextPipePtr == PipePtr) {                          /* Ready pipe found? */
      return NULL;                                         /* No, return NULL */
    }
    if (NextPipePtr->ActiveTrPtr != NULL) {                /* Transfer pending on selected pipe? */
      break;                                               /* Return address of this pipe */
    }
  } while (1);
  return NextPipePtr;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostMainIsr (component USB_LDD)
**
**     Description :
**         Host mode main interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostMainIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t IntStatus, uint32_t Status, uint32_t ErrorStatus)
{
  uint32_t                         BDCtrlReg;
  uint16_t                         DataSize;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TPipeDescr              *PipePtr;
  USB_LDD_TTrDescr                *TrPtr;
  uint32_t                         CurrentFrameNum;

  CurrentFrameNum = ((uint32_t)(USB_PDD_GetFrameNumberHigh(USB0_BASE_PTR)) << 0x08); /* Get current frame number */
  CurrentFrameNum |= (uint32_t)(USB_PDD_GetFrameNumberLow(USB0_BASE_PTR));
  if ((IntStatus & USB_PDD_TOK_DNE_INT) == 0x00U) {
    /* Some special interrupt detected */
    if ((IntStatus & USB_PDD_USB_RST_INT) != 0x00U) {       /* USB Deattach Signal detected? */
      /* (2,5us of SE0) */
      /* USB deattach signal detected interrupt handler */
      if ((IntStatus & USB_PDD_ATTACH_INT) == 0x00U) {
        /* Sets the port to the DISCONNECTED state and closes all pipes and discards all pending transfers. */
        /*  This state can be changed only by performing the bus reset(transfer to the ENABLED state), */
        /*  by the disconnecting the device (transfer to the DISCONNECT state) or by the powering-off */
        /* the bus (transfer to the POWERED_OFF state). */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Set new state */
        USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);      /* Disable SOF */
        USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
        USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
        USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Clear "attach" interrupt flag */
        USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Enable only "attach" interrupt */
        USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
        if (DevDataPtr->EventMask & LDD_USB_ON_HOST_DEVICE_DEATTACH) {
          USB_LDD_OnHostDeviceDeattach(DevDataPtr->UserHostDataPtr);
        }
      } else {
      }
    } else if ((IntStatus & USB_PDD_ATTACH_INT) != 0x00U) { /* Attach signal detected? */
      /* Attach signal detected interrupt handler */
      /* (2,5 us without transition and bus state != SE0 */
      if (!USB_PDD_GetSE0(USB0_BASE_PTR)) {
        /* Enables port. Disables all USB interrupts except "deattach" interrupt */
        /* and starts 100 ms debounce interval. After this interval is done it */
        /* starts the reset signaling(50 ms). After reset signaling is done it */
        /* checks the connected device speed and adds 10ms of reset recovery. As */
        /* soon as the reset recovery interval is done the port state is changed */
        /* to the "ENABLED" state and port can be used to transmit data. Called */
        /* from ISR if the "connect" event is detected. */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_DISABLED; /* Set new port state */
        USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE); /* Wake-up transceiver */
        USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Clear "deattach" interrupt flag */
        USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Enable only "deattach" interrupt */
        USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_DEBOUNCE_INTERVAL_MS + 1); /* Wait at least 100 ms before reseting the device */
      } else {
        ;
      }
    } else if ((IntStatus & USB_PDD_RESUME_INT) != 0x00U) { /* Resume received? */
      /* Resume signal interrupt handler */
      USB_LDD_HostResumePort(DevDataPtr);
    } else if ((IntStatus & USB_PDD_SOF_TOK_INT) != 0x00U) { /* SOF threshold? */
      /* SOF threshold interrupt handler */
      if (DevDataPtr->LastFrameNum > CurrentFrameNum) {    /* Frame counter overflow? */
        PipePtr = DevDataPtr->PeriodicPipeListHeadPtr;     /* Yes, update next frame number */
        while (PipePtr != NULL) {                          /* in all opened periodic pipes */
          PipePtr->NextFrameNum = PipePtr->NextFrameNum & (uint32_t)0x07FF;
          PipePtr = PipePtr->NextPipePtr;                  /* Get next pipe */
        }
      }
      DevDataPtr->LastFrameNum = CurrentFrameNum;          /* Remember current frame number */
      if (DevDataPtr->ActivePipePtr != NULL) {             /* Transaction in progress? */
        DevDataPtr->SofThresholdDetected = TRUE;           /* Yes, let the token done handler to select transaction from the periodic list */
      } else {                                             /* No, start transaction from here */
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetPeriodicTransactionReadyPipe(DevDataPtr->PeriodicPipeListHeadPtr, CurrentFrameNum);
        if (DevDataPtr->ActivePipePtr != NULL) {           /* Transaction ready? */
          USB_LDD_HostStartTransaction(DevDataPtr);        /* Start the transaction on selected pipe */
        }
      }
    } else {
      ;
    }
  } else {
    /* Only TOKE_DONE interrupt detected (no other interrupt signal active) */
    PipePtr = DevDataPtr->ActivePipePtr;
    DevDataPtr->ActivePipePtr = NULL;
    if ((uint32_t)PipePtr->Head.TransferType & (uint32_t)1U) { /* Periodic transaction done? */
      DevDataPtr->ActivePipePtr = USB_LDD_HostGetPeriodicTransactionReadyPipe(PipePtr->NextPipePtr, CurrentFrameNum); /* Find ready periodic transaction */
      if (DevDataPtr->ActivePipePtr == NULL) {             /* No periodic transaction ready?  */
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetAsyncTransactionReadyPipe(DevDataPtr, NULL); /* Find ready async. transaction */
      }
    } else {
      if (DevDataPtr->SofThresholdDetected) {              /* New frame? */
        DevDataPtr->SofThresholdDetected = FALSE;
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetPeriodicTransactionReadyPipe(DevDataPtr->PeriodicPipeListHeadPtr, CurrentFrameNum); /* Find ready periodic transaction */
        if (DevDataPtr->ActivePipePtr == NULL) {           /* No periodic transaction ready?  */
          DevDataPtr->ActivePipePtr = USB_LDD_HostGetAsyncTransactionReadyPipe(DevDataPtr, NULL); /* Find ready async. transaction */
        }
      } else {
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetAsyncTransactionReadyPipe(DevDataPtr, PipePtr); /* Find ready async. transaction */
      }
    }
    if (DevDataPtr->ActivePipePtr != NULL) {               /* Transaction ready? */
      USB_LDD_HostStartTransaction(DevDataPtr);            /* Start transaction on selected pipe */
    }
    /* Handle the last transaction */
    TrPtr     = PipePtr->ActiveTrPtr;
    BDPtr = &DevDataPtr->BDT[Status >> 0x02];
    BDCtrlReg = BDPtr->CtrlReg;
    if ((ErrorStatus & ~(uint32_t)(USB_PDD_BTO_ERR_INT)) != 0x00U) {
      TrPtr->ErrorCounter--;                               /* Decrement error counter */
      if (!TrPtr->ErrorCounter) {
        if ((ErrorStatus & USB_PDD_BTS_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_BTS;
        } else if ((ErrorStatus & USB_PDD_PID_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_PID;
        } else if ((ErrorStatus & USB_PDD_CRC5_EOF_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_EOF;
        } else if ((ErrorStatus & USB_PDD_CRC16_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_CRC16;
        } else if ((ErrorStatus & USB_PDD_DFN8_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_DFN8;
        } else if ((ErrorStatus & USB_PDD_DMA_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_DMA;
        } else {
          ;
        }
        if (DevDataPtr->EventMask & LDD_USB_ON_HOST_ERROR) {
          USB_LDD_OnHostError(DevDataPtr->UserHostDataPtr, (uint8_t)0U, (uint8_t)(TrPtr->TrState));
        }
      }
    } else {
      switch ((uint32_t)BDCtrlReg & USB_LDD_BD_PID_MASK) {
        case USB_LDD_BD_PID_ACK:                           /* Setup/OUT(Tx) packet sent and ACK packet received  */
        case USB_LDD_BD_PID_DATA0:                         /* IN(Rx) packet received and ACK sent*/
        case USB_LDD_BD_PID_DATA1:
          TrPtr->ErrorCounter = 0x03U;
          switch (TrPtr->TrState) {                        /* Check transfer state */
            case USB_LDD_TRANSFER_SETUP_PENDING:           /* Control transfer setup stage done? */
              /* Setup stage of control transfer done */
              if (TrPtr->Head.BufferSize == 0x00U) {       /* Any data stage? */
                TrPtr->TrState = USB_LDD_TRANSFER_HSK_QUEUED; /* No data stage, next phase is handshake phase */
                PipePtr->Head.EpDir = (uint8_t)(1U);       /* Handshake packet must IN direction */
              } else {
                TrPtr->TrState = USB_LDD_TRANSFER_DATA_QUEUED; /* Next phase is data phase */
              }
              PipePtr->NextData01 = (uint8_t)USB_LDD_BD_DATA1; /* Next data packet must has DATA1 PID */
              break;
            case USB_LDD_TRANSFER_DATA_PENDING:            /* Data transaction done? */
              /* Data transaction done */                  /* Toggle DATA PID */
              PipePtr->NextData01 ^= (uint8_t)USB_LDD_BD_DATA1;
              DataSize  = (uint16_t)((BDCtrlReg >> 0x10U) & 0x03FFU); /* Get transferred data size */
              TrPtr->Head.BufferSize -= DataSize;          /* Update remaining data counter */
              TrPtr->tmpBufferPtr = (uint8_t*)((uint32_t)TrPtr->tmpBufferPtr + (uint32_t)DataSize); /* Update data pointer */
              if ((TrPtr->Head.BufferSize == 0x00U) || (DataSize < PipePtr->Head.MaxPacketSize)) { /* All data transferred? */
                /* Transfer done */
                if (PipePtr->Head.TransferType == LDD_USB_CONTROL) { /* Control transfer? */
                  TrPtr->TrState = USB_LDD_TRANSFER_HSK_QUEUED; /* Next phase is handshake phase */
                  TrPtr->Head.BufferSize = 0x00U;          /* Handshake packet must be 0 size */
                  PipePtr->NextData01 = (uint8_t)USB_LDD_BD_DATA1; /* Handshake data packet must has DATA1 PID */
                  PipePtr->Head.EpDir = (uint8_t)(PipePtr->Head.EpDir ^ LDD_USB_DIR_MASK); /* Handshake packet must has opposite direction to data packet */
                } else {
                  TrPtr->TrState = USB_LDD_TRANSFER_DONE;  /* Update transfer state */
                }
              } else {
                /* Next transaction needed */
              }
              break;
            case USB_LDD_TRANSFER_HSK_PENDING:             /* Control transfer handshake stage done? */
              /* Control transfer done */
              TrPtr->TrState = USB_LDD_TRANSFER_DONE;      /* Update transfer state */
              break;
            default:
              break;
          }
          break;
        case USB_LDD_BD_PID_NACK:
          break;
        case USB_LDD_BD_PID_STALL:
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_STALLED;
          TrPtr->ErrorCounter = 0x00U;
          break;
        default:                                           /* Transfer error */
          TrPtr->ErrorCounter--;                           /* Decrement error counter */
          if (!TrPtr->ErrorCounter) {
            switch ((uint32_t)BDCtrlReg & USB_LDD_BD_PID_MASK) {
              case USB_LDD_BD_PID_BUS_TIMEOUT: /*  */
                TrPtr->TrState = USB_LDD_TRANSFER_ERROR_BUS_TIMEOUT;
                break;
              case USB_LDD_BD_PID_DATA_ERROR:
                TrPtr->TrState = USB_LDD_TRANSFER_ERROR_DATA;
                break;
              default:
                break;
            }
            if (DevDataPtr->EventMask & LDD_USB_ON_HOST_ERROR) {
              USB_LDD_OnHostError(DevDataPtr->UserHostDataPtr, (uint8_t)0U, (uint8_t)(TrPtr->TrState));
            }
          }
        break;
      }
    }
    if (TrPtr->TrState < USB_LDD_TRANSFER_QUEUED) {        /* Transfer done, stalled, canceled or error detected? */
      USB_LDD_HostTransferDone(DevDataPtr, PipePtr);       /* Call transfer complete handler */
      if (TrPtr->TrState != USB_LDD_TRANSFER_DONE) {       /* Transfer error? */
        if (PipePtr->Head.TransferType != LDD_USB_ISOCHRONOUS) {
          USB_LDD_HostQueueFlush(DevDataPtr, PipePtr, USB_LDD_TRANSFER_ERROR);
        }
      }
    }
    if (DevDataPtr->ActivePipePtr == NULL) {               /* Transaction in progress? */
      if (PipePtr->ActiveTrPtr != NULL) {                  /* No, transaction ready for current pipe ? */
        if (!((uint32_t)PipePtr->Head.TransferType & 1U)) { /* Async. pipe? */
          DevDataPtr->ActivePipePtr = PipePtr;
          USB_LDD_HostStartTransaction(DevDataPtr);        /* Start new transaction on current pipe */
        }
      } else {
      }
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostTimerDoneIsr (component USB_LDD)
**
**     Description :
**         Host mode timer done handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostTimerDoneIsr(USB_LDD_TDeviceData *DevDataPtr)
{
  switch (DevDataPtr->HostState) {
    case LDD_USB_HOST_PORT_DISABLED:
      /* Device is attached for at least 100 ms (TATTDB). Usb spec 2.0 chapter 7.17.3 */
      switch (USB_PDD_GetBusSpeed(USB0_BASE_PTR)) {
        case USB_PDD_LOW_SPEED:
          DevDataPtr->BusSpeed = LDD_USB_LOW_SPEED;
          USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_ENABLE);
          USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_ENABLE);
          break;
        case USB_PDD_FULL_SPEED:
          DevDataPtr->BusSpeed = LDD_USB_FULL_SPEED;
          USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);
          break;
        default:
          DevDataPtr->BusSpeed = LDD_USB_SPEED_UNKNOWN;
          return;
      }
      USB_LDD_HostResetPort(DevDataPtr);
      break;
    case LDD_USB_HOST_PORT_RESETING:
      /* Reset signal was asserted for at 50 ms least ms (TDRST). Usb spec 2.0 chapter 7.17.3 */
      USB_PDD_StartResetSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop reset signaling */
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_ALL_INT_FLAGS); /* Clear all interrupt flags */
      USB_PDD_EnableBusResetInterrupt(USB0_BASE_PTR);       /* Enable only "deattach" interrupt */
      USB_PDD_EnableSof(USB0_BASE_PTR, PDD_ENABLE);         /* and enable SOF */
      /* Wait at least 10 ms (TRSTRCY) for reset recovery */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_RESET_RECOVERING; /* Remember new port state */
      USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESET_RECOVERY_INTERVAL_MS + 1); /* Start reset recovery interval */
      break;
    case LDD_USB_HOST_PORT_RESET_RECOVERING:
      /* Reset recovery done, the port can now be used to transfer data */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_ENABLED;    /* Remember new port state */
      if (DevDataPtr->EventMask & LDD_USB_ON_HOST_RESET_RECOVERY) {
        USB_LDD_OnHostResetRecovery(DevDataPtr->UserHostDataPtr, DevDataPtr->BusSpeed);
      }
      break;
    case LDD_USB_HOST_PORT_SUSPENDED:
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Clear "deattache" interrupt flag */
      USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT | USB_PDD_RESUME_INT); /* Enable "deattach" and "resume" interrupts */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUME_READY; /* Remember new port state */
      break;
    case LDD_USB_HOST_PORT_RESUMING:
      if (USB_PDD_GetResumeSignalState(USB0_BASE_PTR)) {
        USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop resume signaling */
        USB_LDD_StartTimer(DevDataPtr, 1);                  /* and wait 1 ms before enabling SOF */
      } else {
        USB_PDD_EnableSof(USB0_BASE_PTR, PDD_ENABLE);       /* Enable SOF */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUME_RECOVERING; /* Remember new port state */
        USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESUME_RECOVERY_INTERVAL_MS + 1); /* Start resume recovery interval */
      }
      break;
    case LDD_USB_HOST_PORT_RESUME_RECOVERING:
      DevDataPtr->HostState = LDD_USB_HOST_PORT_ENABLED;    /* Remember new port state */
      if (DevDataPtr->EventMask & LDD_USB_ON_HOST_RESUME_RECOVERY) {
        USB_LDD_OnHostResumeRecovery(DevDataPtr->UserHostDataPtr);
      }
      break;
    default:
      break;
  }
}
/*
** ===================================================================
**     Method      :  USB_LDD_HostIsr (component USB_LDD)
**
**     Description :
**         Host interrupt service handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t InSignalsState)
{
  uint32_t                         ErrorStatus;
  uint32_t                         IntStatus;
  uint32_t                         TransactionStatus;

  if (DevDataPtr->HostState >= LDD_USB_HOST_PORT_POWERED_OFF) {
    /* 1ms interrupt handler */
    if ((InSignalsState & USB_LDD_TIMEOUT) != 0x00U) {      /* Timeout? */
      USB_LDD_HostTimerDoneIsr(DevDataPtr);
    }
    IntStatus = USB_PDD_GetUsbInterruptFlags(USB0_BASE_PTR);
    IntStatus &= USB_PDD_GetUsbInterruptMask(USB0_BASE_PTR);
    if (IntStatus) {                                       /* Any interrupt request? */
      TransactionStatus = USB_PDD_ReadStatusReg(USB0_BASE_PTR); /* Read Status register before clearing int. flags */
      ErrorStatus = USB_PDD_GetErrorsInterruptFlags(USB0_BASE_PTR); /* Read Error status register */
      if ((IntStatus & USB_PDD_TOK_DNE_INT) != 0x00U) {    /* TokenDone request? */
        USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, (uint8_t)ErrorStatus); /* Clear error flags */
      }
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, (uint8_t)IntStatus); /* Clear interrupt flags */
      USB_LDD_HostMainIsr(DevDataPtr, IntStatus, TransactionStatus, ErrorStatus); /* Call interrupt handler */
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_USB_Interrupt (component USB_LDD)
**
**     Description :
**         USB interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(USB_LDD_USB_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  USB_LDD_TDeviceDataPtr DevDataPtr = INT_USB0__DEFAULT_RTOS_ISRPARAM;
  uint32_t NewInSignalState;
  uint32_t OtgIntStatus;
  
  DevDataPtr->ISR = TRUE;
  OtgIntStatus = USB_PDD_GetOtgInterruptFlags(USB0_BASE_PTR);
  OtgIntStatus &= USB_PDD_GetOtgInterruptMask(USB0_BASE_PTR);
  USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, OtgIntStatus);
  NewInSignalState = DevDataPtr->InSignalsState;           /* Get current signal state */
  if ((OtgIntStatus & USB_PDD_1_MSEC_INT) != 0U) {         /* 1ms timer interrupt? */
    NewInSignalState |= USB_LDD_1MS_TIMEOUT;               /* Remember timeout */
    if (DevDataPtr->msCounter > 0x00) {                    /* Otg timing in progress? */
      DevDataPtr->msCounter--;                             /* Decrement 1 ms counter */
      if (DevDataPtr->msCounter == 0x00 ) {                /* Timing done? */
        NewInSignalState |= USB_LDD_TIMEOUT;               /* Remember timeout */
        USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);         /* No, disable 1 ms interrupt */
      }
    }
  } /* 1 ms interrupt */
  USB_LDD_HostIsr(DevDataPtr, NewInSignalState);           /* Call interrupt handler */
  DevDataPtr->ISR = FALSE;
}


/*lint -restore Enable MISRA rule (11.4) checking. */
/* END USB_LDD. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 10.0 [05.03]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
