Debug info from  (Device - IO_Map)  (Module - IO_Map)


{{DEVELOPMENT}} --------(((DEBUGINFO)))--------{{DEVELOPMENT}} 

 DRIVER SYMBOLS (alphabet order)
-------------------------------
CPUpinVariantMaster=MK60DZ10
Doc_Misra_Rule_1=1.1
Doc_Misra_Rule_10=8.10
Doc_Misra_Rule_10_Description=All declarations and definitions of objects or function at file scope shall have internal linkage unless external linkage is required.
Doc_Misra_Rule_10_Lint=Info 765: external 'function' could be made static [MISRA 2004 Rule 8.10]
Doc_Misra_Rule_10_Reason=Device Initialization - ISR declaration is subject of various modifications by the user and may or may not be copied to another module - static is not used.
Doc_Misra_Rule_10_Type=Required
Doc_Misra_Rule_11=10.1
Doc_Misra_Rule_11_Description=The value of an expression of integer type shall not be implicitly converted to a different underlying type.
Doc_Misra_Rule_11_Lint=Note 960: Violates MISRA 2004 Required Rule 10.1, Implicit conversion of integer to smaller type
Doc_Misra_Rule_11_Reason=
Doc_Misra_Rule_11_Type=Required
Doc_Misra_Rule_12=11.3
Doc_Misra_Rule_12_Description=A cast should not be performed between a pointer type and an integral type.
Doc_Misra_Rule_12_Lint=Note 923: cast from 'integer type' to pointer [Encompasses MISRA 2004 Rules 11.1 and 11.3], [MISRA 2004 Rule 11.3]
Doc_Misra_Rule_12_Reason=IO map is based on structures and typecasting from a peripheral base address (integer constant) to a pointer type is used to get a pointer to the given peripheral structure used to access a peripheral registers.
Doc_Misra_Rule_12_Type=Advisory
Doc_Misra_Rule_13=11.4
Doc_Misra_Rule_13_Description=A cast should be not be performed between a pointer to object type and different pointer to object type
Doc_Misra_Rule_13_Lint=Note 929: cast from pointer to pointer [MISRA 2004 Rule 11.4]
Doc_Misra_Rule_13_Reason=See detailed description for particular component
Doc_Misra_Rule_13_Type=Advisory
Doc_Misra_Rule_14=12.1
Doc_Misra_Rule_14_Description=Limited dependence should be placed on C's operator precedence rules in expressions.
Doc_Misra_Rule_14_Lint=Note 961: Violates MISRA 2004 Advisory Rule 12.1, dependence placed on C's operator precedence; operators: ',' and ','
Doc_Misra_Rule_14_Reason=
Doc_Misra_Rule_14_Type=Advisory
Doc_Misra_Rule_15=12.8
Doc_Misra_Rule_15_Description=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand.
Doc_Misra_Rule_15_Lint=Warning 572: Excessive shift value (precision 2 shifted right by 8) [MISRA 2004 Rule 12.8]
Doc_Misra_Rule_15_Reason=
Doc_Misra_Rule_15_Type=Required
Doc_Misra_Rule_16=12.10
Doc_Misra_Rule_16_Description=The comma operator shall not be used.
Doc_Misra_Rule_16_Lint=Note 960: Violates MISRA 2004 Required Rule 12.10, comma operator used
Doc_Misra_Rule_16_Reason=Comma operator is used in PDD macros.
Doc_Misra_Rule_16_Type=Required
Doc_Misra_Rule_17=12.11
Doc_Misra_Rule_17_Description=Evaluation of constant unsigned integer expressions should not lead to wrap-around.
Doc_Misra_Rule_17_Lint=Warning 648: Overflow in computing constant for operation: 'unsigned shift left' [MISRA 2004 Rule 12.11]
Doc_Misra_Rule_17_Reason=
Doc_Misra_Rule_17_Type=Advisory
Doc_Misra_Rule_18=13.7
Doc_Misra_Rule_18_Description=Boolean operations whose results are invariant shall not be permitted.
Doc_Misra_Rule_18_Lint=Warning 506: Constant value Boolean [MISRA 2004 Rules 13.7 and 14.1]
Doc_Misra_Rule_18_Reason=PDD macros define constants that can be passed as parameters to these macros.
Doc_Misra_Rule_18_Type=Required
Doc_Misra_Rule_19=14.2
Doc_Misra_Rule_19_Description=All non-null statements shall either: <br/>a) have at least one side effect however executed, <br/>or b) cause control flow to change.
Doc_Misra_Rule_19_Lint=Warning 522: Highest operation, operator ',', lacks side-effects
Doc_Misra_Rule_19_Reason=Some PDD macros have two commas in the macro implementation.
Doc_Misra_Rule_19_Type=Required
Doc_Misra_Rule_1_Description=All code shall conform to ISO 9899-1990 (C-code guideline)
Doc_Misra_Rule_1_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_1_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_1_Type=Required
Doc_Misra_Rule_2=1.4
Doc_Misra_Rule_20=14.7
Doc_Misra_Rule_20_Description=A function shall have a single point of exit at the end of the function.
Doc_Misra_Rule_20_Lint=Note 904: Return statement before end of function [MISRA 2004 Rule 14.7]
Doc_Misra_Rule_20_Reason=Use of multiple return statements simplifies the code logic.
Doc_Misra_Rule_20_Type=Required
Doc_Misra_Rule_21=18.4
Doc_Misra_Rule_21_Description=Unions shall not be used.
Doc_Misra_Rule_21_Lint=Note 960: Violates MISRA 2004 Required Rule 18.4, unions shall not be used
Doc_Misra_Rule_21_Reason=Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.
Doc_Misra_Rule_21_Type=Required
Doc_Misra_Rule_22=19.13
Doc_Misra_Rule_22_Description=The # and ## preprocessor operators should not be used.
Doc_Misra_Rule_22_Lint=Note 961: Violates MISRA 2004 Advisory Rule 19.13, '#/##' operator used
Doc_Misra_Rule_22_Reason=Preprocessor operators are used to convert bit name to bit mask in macros for accessing peripheral registers.
Doc_Misra_Rule_22_Type=Advisory
Doc_Misra_Rule_2_Description=The compiler/linker shall be checked to ensure that 31 character significance and case sensitivity are supported for external identifiers.
Doc_Misra_Rule_2_Lint=Note Warning 621: Identifier clash [MISRA 2004 Rules 1.2, 1.4 and 5.1]
Doc_Misra_Rule_2_Reason=IO map defines register access constants. The constants' names contain peripheral name, register name, bit name and suffix _MASK/_SHIFT.
Doc_Misra_Rule_2_Type=Required
Doc_Misra_Rule_3=2.1
Doc_Misra_Rule_3_Description=Assembly language shall be encapsulated and isolated.
Doc_Misra_Rule_3_Lint=Note 950: Non-ANSI reserved word or construct [MISRA 2004 Rules 1.1 and 2.2]
Doc_Misra_Rule_3_Reason=Non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt, CONVERT_TO_PAGED (RS08 only).
Doc_Misra_Rule_3_Type=Required
Doc_Misra_Rule_4=3.1
Doc_Misra_Rule_4_Description=All usage of implementation-defined behavior shall be documented.
Doc_Misra_Rule_4_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_4_Reason=Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:
Doc_Misra_Rule_4_Type=Required
Doc_Misra_Rule_5=3.2
Doc_Misra_Rule_5_Description=The character set and the corresponding encoding shall be documented.
Doc_Misra_Rule_5_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_5_Reason=Basic character set (see ISO 9899) is used in execution character set. Execution character set uses ASCII encoding (possible codes 0-255). Exception to basic character set: Term component uses NULL(0x00), CR (0x0D), LF(0x0A).
Doc_Misra_Rule_5_Type=Required
Doc_Misra_Rule_6=3.3
Doc_Misra_Rule_6_Description=The implementation of integer division in the chosen compiler should be determined, documented and taken into account.
Doc_Misra_Rule_6_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_6_Reason=The way a Compiler implements division and modulo for negative operands is determined by the hardware implementation of the target's division instructions. See documentation of CodeWarrior S12(X) Build tools for more information.
Doc_Misra_Rule_6_Type=Advisory
Doc_Misra_Rule_7=3.4
Doc_Misra_Rule_7_Description=All uses of the #pragma directives shall be documented and explained.
Doc_Misra_Rule_7_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_7_Reason=Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.
Doc_Misra_Rule_7_Type=Required
Doc_Misra_Rule_8=3.6
Doc_Misra_Rule_8_Description=All libraries used in production code shall be written to comply with the provision of this document and shall have been subject to appropriate validation.
Doc_Misra_Rule_8_Lint=MISRA Compliancy Review (part of formal technical review)
Doc_Misra_Rule_8_Reason=Only libraries included in CodeWarrior development studio are used in the generated source code.
Doc_Misra_Rule_8_Type=Required
Doc_Misra_Rule_9=6.3
Doc_Misra_Rule_9_Description=Typedef that indicates size and signedness should be used in place of basic types.
Doc_Misra_Rule_9_Lint=Info 970: Use of modifier or type 'int' outside of a typedef [MISRA Rule 6.3]
Doc_Misra_Rule_9_Reason=The type of the function is defined by tool set. ProcessorExpert definition must comply..
Doc_Misra_Rule_9_Type=Advisory
DriverAuthor=Marek Vinkler
DriverDate=29.08.2006
DriverVersion=01.00
Location_x=IO_Map.h
Doc_Misra_Rule_10_Location=[Cpu|Vectors.c]
Doc_Misra_Rule_11_Location=[PE_Types.h|SDHC_LDD]
Doc_Misra_Rule_11_Location_Reason=[Call of the library function __set_FAULTMASK(). The code violates this rule for IAR compiler only.|Cannot shift by a value resulting from a complex expression.]
Doc_Misra_Rule_12_Location=[IO_Map.h]
Doc_Misra_Rule_13_Location=[Vectors.c|Serial_LDD|SPIMaster_LDD|SPISlave_LDD|SSI_LDD|USB_LDD]
Doc_Misra_Rule_13_Location_Reason=[Need to explicitly cast pointers to the general ISR for Interrupt vector table|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointer to void type and pointer to uint8_t/uint16_t type is used in ISR (transmitting/receiving characters).|Conversion between pointers is used in StartTransaction, HostQueueTransfer and Init methods.]
Doc_Misra_Rule_14_Location=[SDHC_LDD|Ethernet_LDD]
Doc_Misra_Rule_14_Location_Reason=[Comma operator separates expressions in PDD macros.|Comma operator separates expressions in PDD macros.]
Doc_Misra_Rule_15_Location=[Ethernet_LDD|TimerUnit_LDD|Serial_LDD]
Doc_Misra_Rule_15_Location_Reason=[Macro for endianness conversion cannot be used on constants.|One of predefined constants for macro LPTMR_PDD_SetDivider has value 1.|PDD macros use shift operations that can cause MISRA violations when a constant with value less than 256 is passed as an argument.]
Doc_Misra_Rule_16_Location=[Global]
Doc_Misra_Rule_17_Location=[Ethernet_LDD]
Doc_Misra_Rule_17_Location_Reason=[Macro for endianness conversion cannot be used on constants.]
Doc_Misra_Rule_18_Location=[Global]
Doc_Misra_Rule_19_Location=[Global]
Doc_Misra_Rule_1_Location=[PE_Types.h|Cpu|Vectors.c|FLASH_LDD]
Doc_Misra_Rule_1_Location_Reason=[The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_20_Location=[Global]
Doc_Misra_Rule_21_Location=[Global|IO_Map.h]
Doc_Misra_Rule_21_Location_Reason=[Unions are used to efficiently swap bytes in a 16-bit word or 32-bit long word, to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.|Unions are used to allow access to single memory location using multiple register names, or to allow simultaneous 32-bit, 16-bit or 8-bit access to single memory location.]
Doc_Misra_Rule_22_Location=[PE_Types.h]
Doc_Misra_Rule_22_Location_Reason=[Used to convert bit name to bit mask in macros accessing registers.]
Doc_Misra_Rule_2_Location=[IO_Map.h]
Doc_Misra_Rule_3_Location=[PE_Types.h|Cpu|Vectors.c]
Doc_Misra_Rule_3_Location_Reason=[The file contains ASM language, but it is isolated in C macros.|The file contains ASM language, but it is isolated in C macros.|The component contains one of non-ANSI C reserved word or construct used as specific language extensions: @, asm, __asm, near, __near, far, interrupt, __interrupt.]
Doc_Misra_Rule_4_Location=[PE_Info|PE_Info|PE_Info|PE_Info|PE_Info|PE_Info]
Doc_Misra_Rule_4_Location_Reason=[Follows the list of implementation dependent behavior used in Processor Expert. See documentation of CodeWarrior MCU Build tools for more information on topics not specified below:|Program overloads void __init_hardware(void) function from the standard startup to provide initialization of clocks and external bus early after reset, see <a href="ResetScenario.html">Reset Scenario</a>.|Program is finished at the end of main function in the infinite loop.|Execution character set and corresponding values are documented in rule 3.2 in this table.|Volatile declarations are used to access peripheral registers (memory mapped).|Pragma directives are used and commented in the source code. See also documented rule 3.4 in this table.]
Doc_Misra_Rule_5_Location=[PE_Info]
Doc_Misra_Rule_6_Location=[PE_Info]
Doc_Misra_Rule_7_Location=[PE_Info]
Doc_Misra_Rule_7_Location_Reason=[Some components use pragma directive to determine the memory segment, where code and/or data will be used (see below). All other uses of #pragma directives are commented in the generated source code.]
Doc_Misra_Rule_8_Location=[CAU_LDD]
Doc_Misra_Rule_8_Location_Reason=[CAU component uses an external CAU library that is not MISRA compliant. CAU component's code itself is MISRA compliant.]
Doc_Misra_Rule_9_Location=[CPU|Main.c]
PE_MisraErrorCodes=[621]

 LOCAL SYMBOLS (alphabet order)
-------------------------------
DeviceModule=IO_Map
DeviceName=IO_Map
DeviceType=IO_Map
EventModules=[Events]
ModuleName=IO_Map

GLOBAL SYMBOLS (alphabet order)
-------------------------------
ADC0AsynchroClockAddr=1073983496
ADC0AsynchroClockReg=ADC0_CFG1
ADC0BusClockAddr=1073983496
ADC0BusClockReg=ADC0_CFG1
ADC0ClkSelAddr=1073983496
ADC0ClkSelReg=ADC0_CFG1
ADC1AsynchroClockAddr=1074507784
ADC1AsynchroClockReg=ADC1_CFG1
ADC1BusClockAddr=1074507784
ADC1BusClockReg=ADC1_CFG1
ADC1ClkSelAddr=1074507784
ADC1ClkSelReg=ADC1_CFG1
ActiveConfigIdentifier=PEcfg_MK60DN512ZVMD10_INTERNAL_RAM
ActiveConfiguration=MK60DN512ZVMD10_INTERNAL_RAM
CPUDB_CPU_MASTER=MK60DZ10
CPUDB_CW_MCU_ID=28695
CPUDB_CW_MCU_NAME=MK60DN512Zxxx10
CPUDB_DataFlashBlockCount=0
CPUDB_DataFlashEraseUnitSize=2048
CPUDB_DataFlashSize=0
CPUDB_DataFlashStartAddress=268435456
CPUDB_DataFlashWriteUnitSize=4
CPUDB_FlexRamSize=0
CPUDB_FlexRamStartAddress=335544320
CPUDB_MAPBGA144=-1
CPUDB_MK60DN512Zxxx10=-1
CPUDB_MK60DZ10=-1
CPUDB_PACKAGE=MAPBGA144
CPUDB_ProgramFlashBlockCount=2
CPUDB_ProgramFlashEraseUnitSize=2048
CPUDB_ProgramFlashSize=524288
CPUDB_ProgramFlashWriteUnitSize=4
CPU_DB_version=3.00.003
CPUendian=little
CPUfamily=Kinetis
CPUproducer=Freescale
CPUrunSpeedModeNum=1
CPUsubFamily=MK60
CPUtype=MK60N512MD100
CPUvariant=MK60DN512ZVMD10
ClientDir_Binary=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\HOST_STACK\USB_HID_HOST_STACK_K60_PEx\Sources\
ClientDir_Code=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\HOST_STACK\USB_HID_HOST_STACK_K60_PEx\Generated_Code\
ClientDir_PE=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\
ClientDir_Project=E:\USB_proccessor_expert_update\Test\20121119_Processor_expert\HOST_STACK\USB_HID_HOST_STACK_K60_PEx\
CommentBrackets=/**/
Compiler=CodeWarriorARM
CompilerID=CodeWarrior ARM C Compiler
DirRel_Binary=Sources\
DirRel_BinaryToEvents=
DirRel_Code=Generated_Code\
DirRel_Docs=Documentation\
DirRel_EventToBinary=
DirRel_Events=Sources\
DirRel_ProjectSettings=Project_Settings\
EclipseProjectName=USB_HID_HOST_STACK_K60_PEx
InterruptTableType=ROM
Language=ANSIC
Not_for_MPC512x=
OnChipEEPROM=0
OnChipFLASH=524288
OnChipRAM=131072
PE_DEBUG=
PE_DEVELOPMENT=
PE_ECLIPSE=
PE_GENERATING=
PE_G_CPUCFG_AutoIncludeIO_Map=yes
PE_G_CPUCFG_EntryPointFunctionName=__init_hardware
PE_G_CPUCFG_EntryPointFunctionReturn=
PE_G_CPUCFG_EntryPointFunctionReturnType=void
PE_G_CPUCFG_GenerateLinkerFile=yes
PE_G_CPUCFG_GenerateMainModule=yes
PE_G_CPUCFG_InitIntVectorTableSym=yes
PE_G_CPUCFG_ManageInterruptVectorTable=yes
PE_G_CPUpinVariantMaster=MK60DZ10
PE_G_GenBitMask=
PE_G_MisraCnfBackParams_0=
PE_G_MisraCnfParams_0= -e621
PE_G_MisraRuleList_0=1.4
PE_G_MisraStackIdx=0
PE_G_NO_SETREGMACROS=
PE_G_RTOSAdap_regCompIndex=1
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockReceived=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockSent=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBreak=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnError=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnIdle=(void (*)(LDD_TUserData RTOSDeviceData))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnRxActiveEdge=(void (*)(LDD_TUserData RTOSDeviceData))0
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnTxComplete=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Deinit=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetReceivedDataNum=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetSentDataNum=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetTxCompleteStatus=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Init=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Main=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_ReceiveBlock=
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_SendBlock=
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockReception=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockTransmission=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearRTS=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearStats=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ConnectPin=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask PinMask))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Deinit=(void (*)(LDD_TDeviceData *DeviceDataPtr))&UART_Deinit
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Disable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Enable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetBreak=(bool (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetCTS=(bool (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDataWidth=(LDD_SERIAL_TDataWidth (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDriverState=(LDD_TDriverState (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetError=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TError *ErrorPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetEventMask=(LDD_TEventMask (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetLoopMode=(LDD_SERIAL_TLoopMode (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetParity=(LDD_SERIAL_TParity (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetReceivedDataNum=(uint16_t (*)(LDD_TDeviceData *DeviceDataPtr))&UART_GetReceivedDataNum
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSelectedBaudRate=(LDD_SERIAL_TBaudMode (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSentDataNum=(uint16_t (*)(LDD_TDeviceData *DeviceDataPtr))&UART_GetSentDataNum
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStats=(LDD_SERIAL_TStats (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStopBitLength=(LDD_SERIAL_TStopBitLen (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetTxCompleteStatus=(bool (*)(LDD_TDeviceData *DeviceDataPtr))&UART_GetTxCompleteStatus
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Init=(LDD_TDeviceData* (*)(LDD_TUserData *UserDataPtr))&UART_Init
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Main=(void (*)(LDD_TDeviceData *DeviceDataPtr))&UART_Main
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ReceiveBlock=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size))&UART_ReceiveBlock
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SelectBaudRate=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TBaudMode Mode))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBlock=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size))&UART_SendBlock
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBreak=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetDataWidth=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TDataWidth DataWidth))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetEventMask=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetLoopMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TLoopMode LoopMode))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetOperationMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetParity=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TParity Parity))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetRTS=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetStopBitLength=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_SERIAL_TStopBitLen StopBitLen))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOff=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOn=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOff=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOn=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostDeviceDeattach=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostError=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostResetRecovery=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostResumeRecovery=
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDevice1msTimer=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceError=(void (*)(LDD_TUserData *UserDataPtr, uint8_t ErrorSource, uint8_t ErrorCode))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceReset=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceResume=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSetupPacket=(void (*)(LDD_TUserData *UserDataPtr, uint8_t EpNum))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSof=(void (*)(LDD_TUserData *UserDataPtr, uint16_t FrameNumber))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSpeedDetect=(void (*)(LDD_TUserData *UserDataPtr, LDD_USB_TBusSpeed CurrentSpeed))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSuspend=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHost1msTimer=(void (*)(LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostDeviceDeattach=(void (*)(LDD_TUserData *UserDataPtr))&USB_LDD_USB_LDD_OnHostDeviceDeattach
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostError=(void (*)(LDD_TUserData *UserDataPtr, uint8_t ErrorSource, uint8_t ErrorCode))&USB_LDD_USB_LDD_OnHostError
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResetRecovery=(void (*)(LDD_TUserData *UserDataPtr, LDD_USB_TBusSpeed CurrentSpeed))&USB_LDD_USB_LDD_OnHostResetRecovery
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResumeRecovery=(void (*)(LDD_TUserData *UserDataPtr))&USB_LDD_USB_LDD_OnHostResumeRecovery
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgDevice=(void (*)(LDD_TUserData *UserDataPtr, bool Enabled))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgHost=(void (*)(LDD_TUserData *UserDataPtr, bool Enabled))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgStateChange=(void (*)(LDD_TUserData *UserDataPtr, LDD_USB_Otg_TState NewState))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnSignalChange=(void (*)(LDD_TUserData *UserDataPtr, LDD_TPinMask SignalMask, LDD_TPinMask SignalValue))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Deinit=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Disable=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Enable=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_GetDriverState=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_GetEventMask=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostCancelTransfer=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostClosePipe=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetFrameNumber=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetMicroFrameNumber=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetPortState=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetTransferStatus=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostOpenPipe=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostRecvData=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostSendData=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostSendSetup=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostSetPortState=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Init=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_SetEventMask=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_SetOperationMode=
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_ConnectPin=(LDD_TError (*)(LDD_TDeviceDataPtr *DeviceData, LDD_TPinMask PinMask))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Deinit=(void (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_Deinit
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceAssertResume=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceCancelTransfer=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceDeinitEndpoint=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetTransferStatus=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetUsbStatus=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t *CmdStatusPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceInitEndpoint=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_TEpDescriptor *EpDescriptorPtr, uint8_t Flags))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceReadSetupData=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, LDD_USB_TSDP *SDPPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceRecvData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSendData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetAddress=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t Address))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetUsbStatus=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t Cmd))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceStallEndpoint=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceUnstallEndpoint=(void (*)(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Disable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_Disable
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Enable=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_Enable
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetDriverState=(LDD_TDriverState (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_GetDriverState
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetEventMask=(LDD_TEventMask (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_GetEventMask
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostCancelTransfer=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeHandlePtr))&USB_LDD_HostCancelTransfer
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostClosePipe=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr))&USB_LDD_HostClosePipe
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetFrameNumber=(uint16_t (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_HostGetFrameNumber
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetMicroFrameNumber=(uint8_t (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_HostGetMicroFrameNumber
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetPortState=(LDD_USB_Host_TState (*)(LDD_TDeviceData *DeviceDataPtr))&USB_LDD_HostGetPortState
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetTransferStatus=(LDD_USB_TTransferState (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TTransferHandle *TransferHandlePtr))&USB_LDD_HostGetTransferStatus
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostOpenPipe=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeInitParamsPtr, LDD_USB_Host_TPipeHandle **PipeHandlePtr))&USB_LDD_HostOpenPipe
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostRecvData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr))&USB_LDD_HostRecvData
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendData=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr))&USB_LDD_HostSendData
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendSetup=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr))&USB_LDD_HostSendSetup
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSetPortState=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPortControlCmd Cmd))&USB_LDD_HostSetPortState
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Init=(LDD_TDeviceData * (*)(LDD_TUserData *UserDataPtr))&USB_LDD_Init
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Main=(void (*)(LDD_TDeviceData *DeviceDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgCmd=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Otg_TCmd Cmd))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterDevice=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterHost=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TUserData *UserDataPtr))0
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetEventMask=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask))&USB_LDD_SetEventMask
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetOperationMode=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr))&USB_LDD_SetOperationMode
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetSignal=(LDD_TError (*)(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask SignalMask, LDD_TPinMask SignalValue))0
PE_G_USE_UINTXX_T=
PE_G_XLKR_ASM_COMPILER_OTHER_PARAMS=
PE_G_XLKR_C_COMPILER_OTHER_PARAMS=
PE_ProductVersion=10.0
PEversion=05.03
PEversionDecimal=1283
ProcessorModule=Cpu
ProcessorName=Cpu
ProjectModule=ProcessorExpert
ProjectName=ProcessorExpert
ServerDir_PE=D:\FreeScale\CW MCU v10.3_B121029\MCU\ProcessorExpert\
SetHighSpeedMode=
SupportedCPUfamily=
TimeStamp=2012-11-19, 17:09, # CodeGen: 37
Xtal_kHz=4000
Xtal_kHz_real=4000
ivINT_USB0=USB_LDD_USB_Interrupt
virtual_ADC0_TotalConversionPrescalerAddr=1073983496
virtual_ADC0_TotalConversionPrescalerReg=ADC0_CFG1
virtual_ADC1_TotalConversionPrescalerAddr=1074507784
virtual_ADC1_TotalConversionPrescalerReg=ADC1_CFG1

 DEPRECATED GLOBAL SYMBOLS (alphabet order)
-------------------------------------------
ADC0AsynchroClockAddr=null
ADC0AsynchroClockReg=null
ADC0BusClockAddr=null
ADC0BusClockReg=null
ADC0ClkSelAddr=null
ADC0ClkSelReg=null
ADC1AsynchroClockAddr=null
ADC1AsynchroClockReg=null
ADC1BusClockAddr=null
ADC1BusClockReg=null
ADC1ClkSelAddr=null
ADC1ClkSelReg=null
ActiveConfigIdentifier=null
ActiveConfiguration=null
CPUDB_CPU_MASTER=null
CPUDB_CW_MCU_ID=null
CPUDB_CW_MCU_NAME=null
CPUDB_DataFlashBlockCount=null
CPUDB_DataFlashEraseUnitSize=null
CPUDB_DataFlashSize=null
CPUDB_DataFlashStartAddress=null
CPUDB_DataFlashWriteUnitSize=null
CPUDB_FlexRamSize=null
CPUDB_FlexRamStartAddress=null
CPUDB_MAPBGA144=null
CPUDB_MK60DN512Zxxx10=null
CPUDB_MK60DZ10=null
CPUDB_PACKAGE=null
CPUDB_ProgramFlashBlockCount=null
CPUDB_ProgramFlashEraseUnitSize=null
CPUDB_ProgramFlashSize=null
CPUDB_ProgramFlashWriteUnitSize=null
CPU_DB_version=null
CPUendian=null
CPUfamily=null
CPUproducer=null
CPUrunSpeedModeNum=null
CPUsubFamily=null
CPUtype=null
CPUvariant=null
ClientDir_Binary=null
ClientDir_Code=null
ClientDir_PE=null
ClientDir_Project=null
CommentBrackets=null
Compiler=null
CompilerID=null
DirRel_Binary=null
DirRel_BinaryToEvents=null
DirRel_Code=null
DirRel_Docs=null
DirRel_EventToBinary=null
DirRel_Events=null
DirRel_ProjectSettings=null
EclipseProjectName=null
InterruptTableType=null
Language=null
Not_for_MPC512x=null
OnChipEEPROM=null
OnChipFLASH=null
OnChipRAM=null
PE_DEBUG=null
PE_DEVELOPMENT=null
PE_ECLIPSE=null
PE_GENERATING=null
PE_G_CPUCFG_AutoIncludeIO_Map=null
PE_G_CPUCFG_EntryPointFunctionName=null
PE_G_CPUCFG_EntryPointFunctionReturn=null
PE_G_CPUCFG_EntryPointFunctionReturnType=null
PE_G_CPUCFG_GenerateLinkerFile=null
PE_G_CPUCFG_GenerateMainModule=null
PE_G_CPUCFG_InitIntVectorTableSym=null
PE_G_CPUCFG_ManageInterruptVectorTable=null
PE_G_CPUpinVariantMaster=null
PE_G_GenBitMask=null
PE_G_MisraCnfBackParams_0=null
PE_G_MisraCnfParams_0=null
PE_G_MisraRuleList_0=null
PE_G_MisraStackIdx=null
PE_G_NO_SETREGMACROS=null
PE_G_RTOSAdap_regCompIndex=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockReceived=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBlockSent=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnBreak=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnError=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnIdle=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnRxActiveEdge=null
PE_G_RTOSAdap_regCompInstance_UART_eventPtr_OnTxComplete=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Deinit=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetReceivedDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetSentDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_GetTxCompleteStatus=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Init=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_Main=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_ReceiveBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodEnabled_SendBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockReception=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_CancelBlockTransmission=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearRTS=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ClearStats=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ConnectPin=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Deinit=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Disable=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Enable=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetBreak=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetCTS=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDataWidth=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetDriverState=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetError=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetEventMask=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetLoopMode=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetParity=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetReceivedDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSelectedBaudRate=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetSentDataNum=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStats=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetStopBitLength=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_GetTxCompleteStatus=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Init=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_Main=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_ReceiveBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SelectBaudRate=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBlock=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SendBreak=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetDataWidth=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetEventMask=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetLoopMode=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetOperationMode=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetParity=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetRTS=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_SetStopBitLength=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOff=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnRxOn=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOff=null
PE_G_RTOSAdap_regCompInstance_UART_methodPtr_TurnTxOn=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostDeviceDeattach=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostError=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostResetRecovery=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventEnabled_OnHostResumeRecovery=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDevice1msTimer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceError=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceReset=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceResume=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSetupPacket=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSof=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSpeedDetect=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnDeviceSuspend=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHost1msTimer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostDeviceDeattach=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostError=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResetRecovery=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnHostResumeRecovery=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgDevice=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgHost=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnOtgStateChange=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_eventPtr_OnSignalChange=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Deinit=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Disable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Enable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_GetDriverState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_GetEventMask=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostCancelTransfer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostClosePipe=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetFrameNumber=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetMicroFrameNumber=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetPortState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostGetTransferStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostOpenPipe=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostRecvData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostSendData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostSendSetup=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_HostSetPortState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_Init=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_SetEventMask=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodEnabled_SetOperationMode=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_ConnectPin=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Deinit=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceAssertResume=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceCancelTransfer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceDeinitEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetTransferStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceGetUsbStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceInitEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceReadSetupData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceRecvData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSendData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetAddress=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceSetUsbStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceStallEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_DeviceUnstallEndpoint=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Disable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Enable=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetDriverState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_GetEventMask=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostCancelTransfer=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostClosePipe=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetFrameNumber=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetMicroFrameNumber=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetPortState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostGetTransferStatus=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostOpenPipe=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostRecvData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendData=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSendSetup=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_HostSetPortState=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Init=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_Main=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgCmd=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterDevice=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_OtgRegisterHost=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetEventMask=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetOperationMode=null
PE_G_RTOSAdap_regCompInstance_USB_LDD_methodPtr_SetSignal=null
PE_G_USE_UINTXX_T=null
PE_G_XLKR_ASM_COMPILER_OTHER_PARAMS=null
PE_G_XLKR_C_COMPILER_OTHER_PARAMS=null
PE_ProductVersion=null
PEversion=null
PEversionDecimal=null
ProcessorModule=null
ProcessorName=null
ProjectModule=null
ProjectName=null
ServerDir_PE=null
SetHighSpeedMode=null
SupportedCPUfamily=null
TimeStamp=null
Xtal_kHz=null
Xtal_kHz_real=null
ivINT_USB0=null
virtual_ADC0_TotalConversionPrescalerAddr=null
virtual_ADC0_TotalConversionPrescalerReg=null
virtual_ADC1_TotalConversionPrescalerAddr=null
virtual_ADC1_TotalConversionPrescalerReg=null

 GLOBAL LISTS (alphabet order)
-------------------------------------------
ADC0AsynchroClock=[1]
ADC0AsynchroClock_Setting=[ADC0Async_FullPower_HighSpeed]
ADC0BusClock=[1]
ADC0BusClock_Setting=[1]
ADC0ClkSel=[1]
ADC0ClkSel_Setting=[ADC0BusClock]
ADC1AsynchroClock=[1]
ADC1AsynchroClock_Setting=[ADC1Async_FullPower_HighSpeed]
ADC1BusClock=[1]
ADC1BusClock_Setting=[1]
ADC1ClkSel=[1]
ADC1ClkSel_Setting=[ADC1BusClock]
CAN0ClkSel=[1]
CAN0ClkSel_Setting=[CAN0BusClk]
CAN1ClkSel=[1]
CAN1ClkSel_Setting=[CAN1BusClk]
CMTPresc=[1]
CMTPresc_Setting=[1]
CMTPrimaryPresc=[1]
CMTPrimaryPresc_Setting=[1]
ERCLK32KSel=[1]
ERCLK32KSel_Setting=[SYSTEM_OSC]
EWMClkSel=[1]
EWMClkSel_Setting=[LPO_1kHzSrc]
EventModuleList=[Events]
FTM0ClkSource=[1]
FTM0ClkSource_Setting=[OUTDIV2Presc]
FTM1ClkSource=[1]
FTM1ClkSource_Setting=[OUTDIV2Presc]
FTM2ClkSource=[1]
FTM2ClkSource_Setting=[OUTDIV2Presc]
I2C0_LoTimeoutClkSel=[1]
I2C0_LoTimeoutClkSel_Setting=[I2C0_LoTimeout_BusClkDiv64]
I2C1_LoTimeoutClkSel=[1]
I2C1_LoTimeoutClkSel_Setting=[I2C1_LoTimeout_BusClkDiv64]
I2S0_ClkSel=[1]
I2S0_ClkSel_Setting=[I2S0_CoreDiv]
I2S0_Rx_Div2_PSR=[1]
I2S0_Rx_Div2_PSR_Setting=[1]
I2S0_Tx_Div2_PSR=[1]
I2S0_Tx_Div2_PSR_Setting=[1]
IRCLKSel=[1]
IRCLKSel_Setting=[IRC_32kHz]
IncludeSharedModules=[PE_Types|PE_Error|PE_Const|IO_Map]
InstructionClock=[undef]
LPTMR0_ClockSelect=[1]
LPTMR0_ClockSelect_Setting=[ERCLK]
MCGOUTSel=[1]
MCGOUTSel_Setting=[MCGPLLCLK]
MCG_ERCLKSel=[1]
MCG_ERCLKSel_Setting=[SYSTEM_OSC]
MCG_FLL_MFactor=[640]
MCG_FLL_MFactor_Setting=[640]
MCG_FLL_RCLKSel=[1]
MCG_FLL_RCLKSel_Setting=[MCG_FRDIV]
MCG_FRDIV=[1024]
MCG_FRDIV_Setting=[1024]
MCG_PRDIV=[25]
MCG_PRDIV_Setting=[25]
MCG_VDIV=[24]
MCG_VDIV_Setting=[24]
ModuleList=[usb_host|USB_LDD|UART]
OUTDIV1Presc=[1]
OUTDIV1Presc_Setting=[1]
OUTDIV2Presc=[1]
OUTDIV2Presc_Setting=[1]
OUTDIV3Presc=[2]
OUTDIV3Presc_Setting=[2]
OUTDIV4Presc=[2]
OUTDIV4Presc_Setting=[2]
PE_G_LCF_DATA_ALIGN=[512]
PE_G_LCF_DATA_SECTION=[.USB_LDD_memory_section]
PE_G_RTOSAdap_regCompInstanceAllocatedDevices=[USB0|UART3]
PE_G_RTOSAdap_regCompInstanceDeviceBaseAddrs=[1074208768|1074188288]
PE_G_RTOSAdap_regCompInstanceIds=[0|1]
PE_G_RTOSAdap_regCompInstanceNames=[USB_LDD|UART]
PE_G_RTOSAdap_regCompInstanceSharedComponentName=[USB_LDD|UART]
PE_G_RTOSAdap_regCompInstanceTypes=[USB_LDD|Serial_LDD]
PE_G_RTOSAdap_regCompInstance_UART_events=[OnBlockReceived|OnBlockSent|OnBreak|OnError|OnTxComplete|OnIdle|OnRxActiveEdge]
PE_G_RTOSAdap_regCompInstance_UART_methods=[Init|Deinit|Enable|Disable|SendBlock|ReceiveBlock|CancelBlockTransmission|CancelBlockReception|GetError|GetSentDataNum|GetReceivedDataNum|GetTxCompleteStatus|SetEventMask|GetEventMask|SelectBaudRate|GetSelectedBaudRate|SetParity|GetParity|SetDataWidth|GetDataWidth|SetStopBitLength|GetStopBitLength|SetLoopMode|GetLoopMode|GetStats|ClearStats|SetRTS|ClearRTS|GetCTS|SendBreak|GetBreak|TurnTxOn|TurnTxOff|TurnRxOn|TurnRxOff|ConnectPin|Main|SetOperationMode|GetDriverState]
PE_G_RTOSAdap_regCompInstance_USB_LDD_events=[OnDeviceReset|OnDeviceSpeedDetect|OnDeviceSuspend|OnDeviceResume|OnDeviceSetupPacket|OnDeviceSof|OnDeviceError|OnDevice1msTimer|OnHostDeviceDeattach|OnHostResetRecovery|OnHostResumeRecovery|OnHostError|OnHost1msTimer|OnOtgDevice|OnOtgHost|OnOtgStateChange|OnSignalChange]
PE_G_RTOSAdap_regCompInstance_USB_LDD_methods=[Init|Deinit|SetEventMask|GetEventMask|Enable|Disable|DeviceGetUsbStatus|DeviceSetUsbStatus|DeviceSetAddress|DeviceAssertResume|DeviceInitEndpoint|DeviceDeinitEndpoint|DeviceStallEndpoint|DeviceUnstallEndpoint|DeviceReadSetupData|DeviceSendData|DeviceRecvData|DeviceGetTransferStatus|DeviceCancelTransfer|HostGetPortState|HostSetPortState|HostGetFrameNumber|HostGetMicroFrameNumber|HostOpenPipe|HostClosePipe|HostSendSetup|HostSendData|HostRecvData|HostGetTransferStatus|HostCancelTransfer|OtgRegisterDevice|OtgRegisterHost|OtgCmd|SetSignal|ConnectPin|Main|SetOperationMode|GetDriverState]
PLLFLLSel=[1]
PLLFLLSel_Setting=[MCGPLLCLK]
SDHC_ClkSel=[1]
SDHC_ClkSel_Setting=[OUTDIV1Presc]
SharedModules=[Kinetis\PE_Types.drv|Kinetis\PE_Error.drv|Kinetis\PE_Const.drv|Kinetis\IO_Map.drv]
SpeedModeList=[SpeedMode0]
SpeedModeNames=[SpeedMode0|SpeedMode1|SpeedMode2|SpeedMode3|SpeedMode4|SpeedMode5|SpeedMode6|SpeedMode7]
SystemPrescaler=[1]
SystemPrescaler_Setting=[1]
USB0_ClkSel=[1]
USB0_ClkSel_Setting=[USB0_PLLFLL0Div]
USB0_PLLFLL0Div=[1]
USB0_PLLFLL0Div_Setting=[1]
USB0_PLLFLL0Frac=[1]
USB0_PLLFLL0Frac_Setting=[1]
WDOGAddPresc=[1]
WDOGAddPresc_Setting=[1]
WDOGClkSel=[1]
WDOGClkSel_Setting=[OUTDIV2Presc]
virtual_ADC0_TotalConversionPrescaler=[1]
virtual_ADC0_TotalConversionPrescaler_Setting=[1]
virtual_ADC1_TotalConversionPrescaler=[1]
virtual_ADC1_TotalConversionPrescaler_Setting=[1]

{{DEVELOPMENT}} --------(((DEBUGINFO)))--------.{{DEVELOPMENT}} 

