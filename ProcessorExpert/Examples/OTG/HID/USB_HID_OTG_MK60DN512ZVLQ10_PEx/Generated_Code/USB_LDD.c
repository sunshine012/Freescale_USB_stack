/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : USB_LDD.c
**     Project     : ProcessorExpert
**     Processor   : MK60DN512ZVMD10
**     Component   : USB_LDD
**     Version     : Component 01.306, Driver 01.08, CPU db: 3.00.003
**     Compiler    : CodeWarrior ARM C Compiler
**     Date/Time   : 2013-02-04, 11:08, # CodeGen: 171
**     Abstract    :
**         This component implements an low level USB API.
**     Settings    :
**          Component name                                 : USB_LDD
**          USB module (SIE)                               : USB0
**          Input clock frequency [MHz]                    : 48 MHz
**          Interrupt service/event                        : Enabled
**            Interrupt                                    : INT_USB0
**            Interrupt priority                           : medium priority
**          Mode                                           : OTG
**            Transceiver type                             : Internal
**              Transceiver module                         : USB0_FS
**              Transceiver weak pull-downs                : Enabled
**              USB revision                               : USB 2.0
**              Device data rate                           : Full speed
**              Host data rates                            : 
**                Low speed                                : yes
**                Full speed                               : yes
**                High speed                               : no
**              Pin/signal setting                         : 
**                Clock pin                                : Disabled
**                USB data pins                            : 
**                  Data plus                              : 
**                    Pin                                  : USB0_DP
**                    Pin signal                           : 
**                  Data minus                             : 
**                    Pin                                  : USB0_DM
**                    Pin signal                           : 
**                Pullup/Pulldown pins                     : 
**                  DP pullup                              : Enabled
**                    Pin                                  : USB0_Internal_DP_PU
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  DM pullup                              : Disabled
**                  DP pulldown                            : Enabled
**                    Pin                                  : USB0_Internal_DP_PD
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  DM pulldown                            : Enabled
**                    Pin                                  : USB0_Internal_DM_PD
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                Otg pins                                 : 
**                  ID                                     : Enabled
**                    Pin                                  : USB0_ID_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  VBUS drive                             : Enabled
**                    Pin                                  : USB0_VBUS_DRV_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  VBUS valid                             : Enabled
**                    Pin                                  : USB0_VBUS_VALID_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  Session valid                          : Enabled
**                    Pin                                  : USB0_SESSION_VALID_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  B session end                          : Enabled
**                    Pin                                  : USB0_B_SESSION_END_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  VBUS charge                            : Enabled
**                    Pin                                  : USB0_VBUS_CHARGE_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**                  VBUS discharge                         : Enabled
**                    Pin                                  : USB0_VBUS_DISCHARGE_signal
**                    Pin signal                           : 
**                    Polarity                             : Activ high
**            Device mode setting                          : 
**              EP list                                    : 16
**                EP 0                                     : Enabled
**                  Control transfer                       : Enabled
**                    Maximum packet size                  : 8
**                    Max. queue size                      : 1
**                  Bulk OUT transfer                      : Disabled
**                  Bulk IN transfer                       : Disabled
**                  Interrupt OUT transfer                 : Disabled
**                  Interrupt IN transfer                  : Disabled
**                  Isochronous OUT  transfer              : Disabled
**                  Isochronous IN  transfer               : Disabled
**                EP 1                                     : Enabled
**                  Control transfer                       : Disabled
**                  Bulk OUT transfer                      : Disabled
**                  Bulk IN transfer                       : Disabled
**                  Interrupt OUT transfer                 : Disabled
**                  Interrupt IN transfer                  : Enabled
**                    Max. packet size                     : 8
**                    Max. queue size                      : 1
**                  Isochronous OUT  transfer              : Disabled
**                  Isochronous IN  transfer               : Disabled
**                EP 2                                     : Disabled
**                EP 3                                     : Disabled
**                EP 4                                     : Disabled
**                EP 5                                     : Disabled
**                EP 6                                     : Disabled
**                EP 7                                     : Disabled
**                EP 8                                     : Disabled
**                EP 9                                     : Disabled
**                EP 10                                    : Disabled
**                EP 11                                    : Disabled
**                EP 12                                    : Disabled
**                EP 13                                    : Disabled
**                EP 14                                    : Disabled
**                EP 15                                    : Disabled
**            Host mode setting                            : 
**              Max. pipes                                 : 3
**              Max. transfers                             : 4
**              Asynchronous transfers                     : yes
**                Control transfers                        : yes
**                Bulk transfers                           : yes
**              Periodic transfers                         : yes
**                Interrupt transfers                      : yes
**                Isochronous transfers                    : no
**            OTG mode settings                            : 
**              A wait B connect timeout                   : Disabled
**              SRP                                        : Disabled
**              HNP                                        : Disabled
**            Initialization                               : 
**              Enabled in init. code                      : no
**              Auto initialization                        : no
**              Event mask                                 : 
**                OnDeviceReset                            : Enabled
**                OnDeviceSpeedDetect                      : Enabled
**                OnDeviceSuspend                          : Enabled
**                OnDeviceResume                           : Enabled
**                OnDeviceSetupPacket                      : Enabled
**                OnDeviceSof                              : Disabled
**                OnDeviceError                            : Enabled
**                OnDevice1msTimer                         : Disabled
**                OnHostDeviceDeattach                     : Enabled
**                OnHostResetRecovery                      : Enabled
**                OnHostResumeRecovery                     : Enabled
**                OnHostError                              : Enabled
**                OnHost1msTimer                           : Disabled
**                OnOtgDevice                              : Enabled
**                OnOtgHost                                : Enabled
**                OnOtgStateChange                         : Enabled
**                OnSignalChange                           : Enabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component enabled
**            Clock configuration 2                        : This component enabled
**            Clock configuration 3                        : This component enabled
**            Clock configuration 4                        : This component enabled
**            Clock configuration 5                        : This component enabled
**            Clock configuration 6                        : This component enabled
**            Clock configuration 7                        : This component enabled
**     Contents    :
**         Init                    - LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr);
**         Deinit                  - void USB_LDD_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         SetEventMask            - LDD_TError USB_LDD_SetEventMask(LDD_TDeviceData *DeviceDataPtr,...
**         GetEventMask            - LDD_TEventMask USB_LDD_GetEventMask(LDD_TDeviceData *DeviceDataPtr);
**         Enable                  - LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable                 - LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr);
**         DeviceGetUsbStatus      - LDD_TError USB_LDD_DeviceGetUsbStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceSetUsbStatus      - LDD_TError USB_LDD_DeviceSetUsbStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceSetAddress        - void USB_LDD_DeviceSetAddress(LDD_TDeviceData *DeviceDataPtr, uint8_t Address);
**         DeviceAssertResume      - LDD_TError USB_LDD_DeviceAssertResume(LDD_TDeviceData *DeviceDataPtr);
**         DeviceInitEndpoint      - LDD_TError USB_LDD_DeviceInitEndpoint(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceDeinitEndpoint    - LDD_TError USB_LDD_DeviceDeinitEndpoint(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceStallEndpoint     - void USB_LDD_DeviceStallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceUnstallEndpoint   - void USB_LDD_DeviceUnstallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceReadSetupData     - void USB_LDD_DeviceReadSetupData(LDD_TDeviceData *DeviceDataPtr, uint8_t...
**         DeviceSendData          - LDD_TError USB_LDD_DeviceSendData(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceRecvData          - LDD_TError USB_LDD_DeviceRecvData(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceGetTransferStatus - LDD_TError USB_LDD_DeviceGetTransferStatus(LDD_TDeviceData *DeviceDataPtr,...
**         DeviceCancelTransfer    - LDD_TError USB_LDD_DeviceCancelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         HostGetPortState        - LDD_USB_Host_TState USB_LDD_HostGetPortState(LDD_TDeviceData *DeviceDataPtr);
**         HostSetPortState        - LDD_TError USB_LDD_HostSetPortState(LDD_TDeviceData *DeviceDataPtr,...
**         HostGetFrameNumber      - uint16_t USB_LDD_HostGetFrameNumber(LDD_TDeviceData *DeviceDataPtr);
**         HostGetMicroFrameNumber - uint8_t USB_LDD_HostGetMicroFrameNumber(LDD_TDeviceData *DeviceDataPtr);
**         HostOpenPipe            - LDD_TError USB_LDD_HostOpenPipe(LDD_TDeviceData *DeviceDataPtr,...
**         HostClosePipe           - LDD_TError USB_LDD_HostClosePipe(LDD_TDeviceData *DeviceDataPtr,...
**         HostSendSetup           - LDD_TError USB_LDD_HostSendSetup(LDD_TDeviceData *DeviceDataPtr,...
**         HostSendData            - LDD_TError USB_LDD_HostSendData(LDD_TDeviceData *DeviceDataPtr,...
**         HostRecvData            - LDD_TError USB_LDD_HostRecvData(LDD_TDeviceData *DeviceDataPtr,...
**         HostGetTransferStatus   - LDD_USB_TTransferState USB_LDD_HostGetTransferStatus(LDD_TDeviceData...
**         HostCancelTransfer      - LDD_TError USB_LDD_HostCancelTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         OtgRegisterDevice       - LDD_TError USB_LDD_OtgRegisterDevice(LDD_TDeviceData *DeviceDataPtr,...
**         OtgRegisterHost         - LDD_TError USB_LDD_OtgRegisterHost(LDD_TDeviceData *DeviceDataPtr,...
**         OtgCmd                  - LDD_TError USB_LDD_OtgCmd(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Otg_TCmd Cmd);
**         SetSignal               - LDD_TError USB_LDD_SetSignal(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask...
**
**     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE USB_LDD. */

#include "usb_otg.h"
#include "USB_LDD.h"
/* {Default RTOS Adapter} No RTOS includes */
/*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */
#include "USB_PDD.h"

#define USB_LDD_AVAILABLE_EVENTS_MASK ((LDD_TEventMask)( \
          LDD_USB_ON_DEVICE_RESET | \
          LDD_USB_ON_DEVICE_SPEED_DETECT | \
          LDD_USB_ON_DEVICE_SUSPEND | \
          LDD_USB_ON_DEVICE_RESUME | \
          LDD_USB_ON_DEVICE_SETUP_PACKET | \
          LDD_USB_ON_DEVICE_ERROR | \
          LDD_USB_ON_HOST_DEVICE_DEATTACH | \
          LDD_USB_ON_HOST_RESET_RECOVERY | \
          LDD_USB_ON_HOST_RESUME_RECOVERY | \
          LDD_USB_ON_HOST_ERROR | \
          LDD_USB_ON_OTG_DEVICE | \
          LDD_USB_ON_OTG_HOST | \
          LDD_USB_ON_OTG_STATE_CHANGE | \
          LDD_USB_ON_SIGNAL_CHANGE))

#define USB_LDD_INIT_EVENTS_MASK ((LDD_TEventMask)( \
          LDD_USB_ON_DEVICE_RESET | \
          LDD_USB_ON_DEVICE_SPEED_DETECT | \
          LDD_USB_ON_DEVICE_SUSPEND | \
          LDD_USB_ON_DEVICE_RESUME | \
          LDD_USB_ON_DEVICE_SETUP_PACKET | \
          LDD_USB_ON_DEVICE_ERROR | \
          LDD_USB_ON_HOST_DEVICE_DEATTACH | \
          LDD_USB_ON_HOST_RESET_RECOVERY | \
          LDD_USB_ON_HOST_RESUME_RECOVERY | \
          LDD_USB_ON_HOST_ERROR | \
          LDD_USB_ON_OTG_DEVICE | \
          LDD_USB_ON_OTG_HOST | \
          LDD_USB_ON_OTG_STATE_CHANGE | \
          LDD_USB_ON_SIGNAL_CHANGE))

#define USB_LDD_AVAILABLE_IN_SIGNALS_MASK ((LDD_TPinMask)( \
          LDD_USB_OTG_ID_PIN | \
          LDD_USB_OTG_VBUS_VALID_PIN | \
          LDD_USB_OTG_SESSION_VALID_PIN | \
          LDD_USB_OTG_B_SESSION_END_PIN))

#define USB_LDD_IN_SIGNALS_INIT_VALUE ((LDD_TPinMask)( \
          USB_LDD_OTG_ID | \
          USB_LDD_OTG_B_SESSION_END))

/* BD Endpoint control access macros */
#define USB_LDD_BD_OWM                            0x00000080U
#define USB_LDD_BD_DATA0                          0x00000000U
#define USB_LDD_BD_DATA1                          0x00000040U
#define USB_LDD_BD_KEEP                           0x00000020U
#define USB_LDD_BD_NINC                           0x00000010U
#define USB_LDD_BD_DTS                            0x00000008U
#define USB_LDD_BD_STALL                          0x00000004U

#define USB_LDD_BD_PID_BUS_TIMEOUT                0x00000000U
#define USB_LDD_BD_PID_DATA0                      0x0000000CU
#define USB_LDD_BD_PID_DATA1                      0x0000002CU
#define USB_LDD_BD_PID_ACK                        0x00000008U
#define USB_LDD_BD_PID_STALL                      0x00000038U
#define USB_LDD_BD_PID_NACK                       0x00000028U
#define USB_LDD_BD_PID_DATA_ERROR                 0x0000003CU
#define USB_LDD_BD_PID_MASK                       0x0000003CU

#define USB_LDD_BD_LE_OWM                         0x80000000U
#define USB_LDD_BD_LE_DATA1                       0x40000000U
#define USB_LDD_BD_LE_STALL                       0x04000000U

#define MAX_EP_IDX                                0x03u
#define MAX_BD_IDX                                0x07u

#define USB_LDD_DEVICE_WAKE_UP_READY_TIME         0x06 /* Number of ms the bus must be idle to force wake-up signaling */
#define USB_LDD_DEVICE_SUSPEND_DETECTION_TIME     0x03 /* Number of milliseconds from last EOP to detect IDLE */
#define USB_LDD_DEVICE_RESUME_DURATION            0x05 /* Number of milliseconds from last EOP to detect SUSPEND */
#define USB_LDD_DEVICE_RESUME_DETECTED            0x07 /* Constants specify that non IDLE state during suspend has been detected */
#define USB_LDD_HOST_DEBOUNCE_INTERVAL_MS         0x64
#define USB_LDD_HOST_RESET_INTERVAL_MS            0x32
#define USB_LDD_HOST_RESET_RECOVERY_INTERVAL_MS   0x0A
#define USB_LDD_HOST_RESUME_INTERVAL_MS           0x14
#define USB_LDD_HOST_RESUME_RECOVERY_INTERVAL_MS  0x0A

#define MAX_PIPES                                 0x03u
#define MAX_TRANSFERS                             0x04u

#define LDD_USB_DIR_UNKNOWN                       0xFFu
#define USB_LDD_A_WAIT_VRISE_TIME_OUT_MS          0x64
#define USB_LDD_A_WAIT_BCON_SHORT_DEBOUCE_MS      0x01
#define USB_LDD_A_WAIT_BCON_LONG_DEBOUCE_MS       0x64
#define USB_LDD_A_WAIT_BCON_TIME_OUT_MS           0x044C
#define USB_LDD_A_IDLE_BDIS_TIME_OUT_MS           0xC8
#define USB_LDD_B_ASE0_TIME_OUT_MS                0x9B
#define USB_LDD_B_SE0_SRP_TIME_OUT_MS             0x03
#define USB_LDD_B_DATA_PLS_TIME_OUT_MS            0x07

/* OTG input variables */
#define USB_LDD_OTG_TIMEOUT                       0x80000000u
#define USB_LDD_OTG_1MS_TIMEOUT                   0x40000000u
#define USB_LDD_OTG_A_BUS_RESUME                  0x20000000u
#define USB_LDD_OTG_A_BUS_SUSPEND                 0x10000000u
#define USB_LDD_OTG_A_CONN                        0x08000000u
#define USB_LDD_OTG_A_SESSION_VALID               0x08u
#define USB_LDD_OTG_A_SRP_DET                     0x04000000u
#define USB_LDD_OTG_A_VBUS_VALID                  0x01u
#define USB_LDD_OTG_B_BUS_RESUME                  0x02000000u
#define USB_LDD_OTG_B_BUS_SUSPEND                 0x01000000u
#define USB_LDD_OTG_B_CONN                        0x00800000u
#define USB_LDD_OTG_B_SE0_SRP                     0x00400000u
#define USB_LDD_OTG_B_SESSION_VALID               0x08u
#define USB_LDD_OTG_B_SESSION_END                 0x04u
#define USB_LDD_OTG_ID                            0x80u

#define USB_LDD_OTG_VBUS_VALID                    0x01u
#define USB_LDD_OTG_SESSION_VALID                 0x08u

/* Informative variables */
#define USB_LDD_OTG_A_BUS_DROP                    0x00200000u
#define USB_LDD_OTG_A_BUS_REQ                     0x00100000u
#define USB_LDD_OTG_A_CLR_ERR                     0x00080000u
#define USB_LDD_OTG_A_SUSPEND_REQ                 0x00040000u
#define USB_LDD_OTG_B_BUS_REQ                     0x00020000u

/* Internal variables */
#define USB_LDD_TIMEOUT                           0x02u
#define USB_LDD_1MS_TIMEOUT                       0x40u
#define USB_LDD_OTG_A_SET_B_HNP_EN                0x00010000u
#define USB_LDD_OTG_B_SRP_DONE                    0x8000u
#define USB_LDD_OTG_B_HNP_EN                      0x4000u
#define USB_LDD_OTG_NOT_SE0                       0x2000u

#define USB_LDD_DEVICE_VBUS_DETECT                0x04u
#define USB_LDD_HOST_VBUS_OVERCURRENT             0x04u

#define USB_LDD_EnableTimer() USB_PDD_Enable1msInterrupt(USB0_BASE_PTR)

/* Buffer descriptor table item structure */
typedef struct USB_LDD_TBD_Struct {
  uint32_t                        CtrlReg;
  uint32_t                        BufferPtr;
} USB_LDD_TBD;

/* Transfer descriptor structure */
typedef struct USB_LDD_TTD_Struct {
  bool                             Active;
  bool                             ZLT;
  struct USB_LDD_TTD_Struct       *pNextTD;
  uint8_t                         *BufferPtr;
  uint16_t                         RemainingData;
  LDD_USB_Device_TTD              *UserTDPtr;
} USB_LDD_TTD;

typedef enum {
  USB_LDD_EP_NOT_AVAILABLE         = 0x00U, /* Endpoint is not supported by the driver */
  USB_LDD_EP_NOT_CONFIGURED        = 0x01U, /* Endpoint is not enabled by the Host */
  USB_LDD_EP_STALLED               = 0x02U, /* Endpoint is stalled */
  USB_LDD_EP_IDLE                  = 0x04U, /* Endpoint is idle */
  USB_LDD_EP_BUSY                  = 0x08U  /* Endpoint is busy */
} USB_LDD_TePState;

typedef enum {
  USB_LDD_CONTROL_NO_DATA,
  USB_LDD_CONTROL_NO_DATA_HSK,
  USB_LDD_CONTROL_READ_DATA,
  USB_LDD_CONTROL_READ_HSK,
  USB_LDD_CONTROL_WRITE_DATA,
  USB_LDD_CONTROL_WRITE_HSK
} USB_LDD_TCtrlTransferStage;

/* Endpoint private data structure */
typedef struct USB_LDD_TEpData_Struct {
  USB_LDD_TePState                 EpState;      /* EP state */
  uint8_t                          EpNumber;     /* EP number */
  LDD_USB_TTransferType            TransferType; /* EP Transfer type */
  uint16_t                         MaxPacketSize; /* EP max. packet size */
  union {
    struct {
      uint16_t                     ReqDataSize;
      USB_LDD_TCtrlTransferStage   Stage;
    } Ctrl;
  } TT;
  bool                             ZLT;
  USB_LDD_TTD                     *TDQueuePtr;   /* Address of the TD queue */
  USB_LDD_TTD                     *pCurrentTD;   /* Address of the first TD */
  USB_LDD_TTD                     *pLastTD;      /* Address of the last TD */
  LDD_USB_TSDP                    *SDPPtr;       /* Address of the local buffer for SETUP packet */
  volatile uint8_t                *EpCtrlRegPtr; /* Address of theEP control register for this EP */
  uint32_t                         BDCtrlRegVal; /* Predefined value for EP control register */
  USB_LDD_TBD                     *BDPtr;        /* Address of the BD item for this EP */
  USB_LDD_TBD                     *LastTrBDPtr;  /* Address of the last transaction BD item for this EP */
} USB_LDD_TEpData;

typedef enum {
  USB_LDD_PIPE_CLOSED            = 0x00u,
  USB_LDD_PIPE_IDLE              = 0x01u,
  USB_LDD_PIPE_BUSY              = 0x02u
} USB_LDD_TPipeState;

typedef enum {
  USB_LDD_TRANSFER_NONE               = 0x00u,
  USB_LDD_TRANSFER_DONE               = 0x01u,
  USB_LDD_TRANSFER_ERROR_CANCELLED    = 0x02u,
  USB_LDD_TRANSFER_ERROR_STALLED      = 0x03u,
  USB_LDD_TRANSFER_ERROR_BUS_TIMEOUT  = 0x04u,
  USB_LDD_TRANSFER_ERROR_DATA         = 0x05u,
  USB_LDD_TRANSFER_ERROR_PID          = 0x06u,
  USB_LDD_TRANSFER_ERROR_EOF          = 0x07u,
  USB_LDD_TRANSFER_ERROR_CRC16        = 0x08u,
  USB_LDD_TRANSFER_ERROR_DFN8         = 0x09u,
  USB_LDD_TRANSFER_ERROR_DMA          = 0x0Au,
  USB_LDD_TRANSFER_ERROR_BTS          = 0x0Bu,
  USB_LDD_TRANSFER_ERROR              = 0x0Fu,
  USB_LDD_TRANSFER_QUEUED             = 0x10u,
  USB_LDD_TRANSFER_PENDING            = 0x30u,
  USB_LDD_TRANSFER_DATA_QUEUED        = 0x50u,
  USB_LDD_TRANSFER_DATA_PENDING       = 0x70u,
  USB_LDD_TRANSFER_SETUP_QUEUED       = 0x90u,
  USB_LDD_TRANSFER_SETUP_PENDING      = 0xB0u,
  USB_LDD_TRANSFER_HSK_QUEUED         = 0xD0u,
  USB_LDD_TRANSFER_HSK_PENDING        = 0xF0u
} USB_LDD_TTrState;

/* Transfer descriptor (TD) structure */
typedef struct USB_LDD_TTrDescr_Struct {
  LDD_USB_Host_TTD                 Head;         /* Public part of the TD */
  USB_LDD_TTrState                 TrState;      /* Transfer state */
  uint8_t                         *tmpBufferPtr; /* Buffer address */
  struct USB_LDD_TTrDescr_Struct  *NextTrPtr;    /* Next TD address */
  uint8_t                          ErrorCounter; /* Transaction error counter */
} USB_LDD_TTrDescr;

/* Pipe descriptor (PD) structure */
typedef struct USB_LDD_TPipeDescr_Struct {
  LDD_USB_Host_TPipeDescr          Head;         /* Public part of the PD */
  struct USB_LDD_TPipeDescr_Struct *NextPipePtr; /* Next pipe address */
  USB_LDD_TPipeState               PipeState;    /* Pipe state */
  uint8_t                          NextData01;   /* DATA pid for next packet  */
  bool                             ZLT;
  USB_LDD_TTrDescr                *ActiveTrPtr;  /* Address of the first TD */
  USB_LDD_TTrDescr                *LastTrPtr;    /* Address of the first TD */
  uint8_t                          EpCtrlRegVal; /* Predefined value for EP control register */
  uint32_t                         NextFrameNum; /* Number of frame to perform next periodic. transaction */
} USB_LDD_TPipeDescr;

typedef enum {
  USB_LDD_MODE_UNKNOWN = 0x00,
  USB_LDD_MODE_DEVICE,
  USB_LDD_MODE_HOST
} USB_LDD_TOtgMode;

/* Device data structure */
typedef struct USB_LDD_TDeviceData_Struct {
  USB_LDD_TBD                      BDT[MAX_BD_IDX + 0x01u]; /* BD array */
  LDD_USB_Device_TState            DeviceState;  /* Internal device engine state */
  LDD_USB_Device_TState            LastDeviceState; /* State before entering suspend mode */
  USB_LDD_TEpData                  EpData[MAX_EP_IDX + 0x01u]; /* EP data array */
  USB_LDD_TTD                      EP_0_OUT_dTD_Queue[0x01U];
  USB_LDD_TTD                      EP_0_IN_dTD_Queue[0x01U];
  uint8_t                          EP_0_Control_PacketBuffer[0x08U];
  USB_LDD_TTD                      EP_1_IN_dTD_Queue[0x01U];
  LDD_TUserData                   *UserDeviceDataPtr; /* Device mode user device data structure */
  LDD_USB_Host_TState              HostState;    /* Internal host engine state */
  USB_LDD_TPipeDescr               PDT[MAX_PIPES]; /* Pipe descriptor array */
  USB_LDD_TTrDescr                 TDT[MAX_TRANSFERS]; /* Transfer descriptor array */
  USB_LDD_TPipeDescr              *AsyncPipeListHeadPtr; /* Asynchronous pipes list head address */
  USB_LDD_TPipeDescr              *AsyncPipeListTailPtr; /* Asynchronous pipes list head address */
  USB_LDD_TPipeDescr              *PeriodicPipeListHeadPtr; /* Asynchronous pipes list head address */
  uint32_t                         PerTrFrameSize; /* Sum of opened per. pipes max packet sizes */
  uint32_t                         LastFrameNum; /* Last frame number */
  uint8_t                          SofThresholdValue; /* Sof threshold detected */
  bool                             SofThresholdDetected; /* Sof threshold detected */
  USB_LDD_TTrDescr                *FreeTDListPtr; /* Free transfer descriptor list address */
  USB_LDD_TPipeDescr              *ActivePipePtr; /* Current device state */
  USB_LDD_TBD                     *RxBDPtr;      /* Empty Rx buffer descriptor address */
  USB_LDD_TBD                     *TxBDPtr;      /* Empty Tx buffer descriptor address */
  LDD_USB_TBusSpeed                BusSpeed;     /* Bus speed */
  LDD_TUserData                   *UserHostDataPtr; /* Host mode user device data structure */
  USB_LDD_TOtgMode                 OtgMode;      /* Otg sw mode (Host/Device/Unknown)*/
  LDD_USB_Otg_TState               OtgState;     /* Internal Otg engine state */
  int32_t                          OtgMsCounter; /* 1ms counter for Otg tining */
  int32_t                          TimeOutCounter;
  int32_t                          AWaitBConDebounceInitVal;
  int32_t                          AWaitBConDebounceCounter;
  LDD_TUserData                   *UserOtgDataPtr; /* Otg user device data structure */
  bool                             ISR;          /* TRUE if ISR is in progress */
  LDD_TEventMask                   EventMask;    /* Event Mask */
  bool                             EnUser;       /* Enable/Disable device state variable */
  uint32_t                         InSignalsState; /* Input signals state variable */
  int32_t                          msCounter;    /* 1ms counter */
} USB_LDD_TDeviceData, *USB_LDD_TDeviceDataPtr;

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
/* This pragma aligns an object to 512 bytes boundary. */
#pragma define_section USB_LDD_memory_section ".USB_LDD_memory_section" far_abs RW
__declspec(USB_LDD_memory_section) static USB_LDD_TDeviceData DevDataPtr__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static USB_LDD_TDeviceDataPtr INT_USB0__DEFAULT_RTOS_ISRPARAM;
static void USB_LDD_StartTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout);
static void USB_LDD_StartOtgTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout);
static void USB_LDD_OtgStateMachine(USB_LDD_TDeviceData *DevDataPtr);
/*
** ===================================================================
**     Method      :  USB_LDD_UsbLock (component USB_LDD)
**
**     Description :
**         USB lock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbLock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_UsbUnlock (component USB_LDD)
**
**     Description :
**         USB unlock
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_UsbUnlock(USB_LDD_TDeviceData *DevDataPtr)
{
  if (!DevDataPtr->ISR) {
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_StartTimer (component USB_LDD)
**
**     Description :
**         Starts timer.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_StartTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout)
{
  DevDataPtr->msCounter = Timeout;                         /* Remember timeout */
  USB_LDD_EnableTimer();                                   /* Enable timer */
}

/*
** ===================================================================
**     Method      :  USB_LDD_StartOtgTimer (component USB_LDD)
**
**     Description :
**         Starts Otg timer.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_StartOtgTimer(USB_LDD_TDeviceData *DevDataPtr, int32_t Timeout)
{
  DevDataPtr->OtgMsCounter = Timeout;                      /* Remember timeout */
  USB_LDD_EnableTimer();                                   /* Enable timer */
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueDataPacket (component USB_LDD)
**
**     Description :
**         Prepares data packet(s) to be sent/received. Initializes all 
**         free BDT entry to transmit requested data.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceQueueDataPacket(USB_LDD_TEpData *EpDataPtr, USB_LDD_TTD *TDPtr) {
  uint16_t                         PacketSize;
  USB_LDD_TBD                     *BDPtr;

  do {
    BDPtr = EpDataPtr->BDPtr;
    if ((BDPtr->CtrlReg & USB_LDD_BD_LE_OWM) != 0x00U) { /* Is BDT entry free? */
      return;                          /* No, packet will be queued as soon as some entry is freed */
    }
    PacketSize = TDPtr->RemainingData; /* Compute max packet size */
    if (PacketSize > EpDataPtr->MaxPacketSize) { /* Remaining data size > then Max packet size? */
      PacketSize = EpDataPtr->MaxPacketSize; /* Yes, send 'MaxPacketSize' length packet */
    }
    BDPtr->BufferPtr = (uint32_t)TDPtr->BufferPtr; /* Set buffer address */
    BDPtr->CtrlReg = ((uint32_t)PacketSize << 0x10U) | EpDataPtr->BDCtrlRegVal; /* Set packet size and put this entry to the SIE */
    EpDataPtr->BDPtr = (USB_LDD_TBD *)((uint32_t)(EpDataPtr->BDPtr) ^ 0x08U); /* Switch to the next BD */
    EpDataPtr->BDCtrlRegVal ^= USB_LDD_BD_DATA1; /* Toggle data for next packet */
    TDPtr->RemainingData -= PacketSize; /* Adjust remaining data count */
    TDPtr->BufferPtr += PacketSize;    /* Adjust data pointer */
    EpDataPtr->pCurrentTD = TDPtr;     /* Mark TD as current TD */
  } while (0x00);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceReceiveSetupPacket (component USB_LDD)
**
**     Description :
**         Prepares buffer for setup packet
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceReceiveSetupPacket(USB_LDD_TEpData *EpDataPtr)
{
  USB_LDD_TTD                     *TDPtr = EpDataPtr->TDQueuePtr;

  TDPtr->Active = TRUE;
  TDPtr->ZLT = FALSE;
  TDPtr->BufferPtr = (uint8_t*)EpDataPtr->SDPPtr;
  TDPtr->RemainingData = (uint16_t)0x08U;
  USB_LDD_DeviceQueueDataPacket(EpDataPtr,TDPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceQueueTransfer (component USB_LDD)
**
**     Description :
**         Inserts Transfer descriptor to the TD queue
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceQueueTransfer(USB_LDD_TDeviceData *DevDataPtr, LDD_USB_Device_TTD *UserTDPtr, uint32_t EpDir)
{
  USB_LDD_TTD                     *NewTDPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;
  bool                             RecvSetup = FALSE;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)UserTDPtr->Head.EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState < USB_LDD_EP_IDLE) {              /* Is EP ready for transmission? */
    if (((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) != 0x00U) { /* No, is EP stalled? */
      Res = ERR_FAILED;                                    /* EP is stalled, return with error */
    } else {
      Res = ERR_NOTAVAIL;                                  /* EP is not enabled,  return with error */
    }
  } else {
    NewTDPtr = EpDataPtr->pLastTD->pNextTD;                /* Find empty TD */
    if (NewTDPtr->Active) {                                /* If TD is active or completed with error */
      Res = ERR_QFULL;                                     /* the ring queue is full, return with error */
    } else {
      NewTDPtr->BufferPtr = UserTDPtr->Head.BufferPtr;     /* Remember buffer address */
      NewTDPtr->RemainingData = UserTDPtr->Head.BufferSize; /* Remember buffer size */
      if (EpDataPtr->TransferType == LDD_USB_CONTROL) {    /* Control transfer? */
        switch (EpDataPtr->TT.Ctrl.Stage) {
          case USB_LDD_CONTROL_READ_HSK:
            /* Control read - handshake stage (Rx) */
            RecvSetup = TRUE;                              /* Be ready to receive new setup data packet after HSK is received */
            break;
          case USB_LDD_CONTROL_WRITE_DATA:
            /* Control write - data stage (Rx) */
            if (NewTDPtr->RemainingData >= EpDataPtr->TT.Ctrl.ReqDataSize) { /* Greater buffer then the data sent by the Host? */
              NewTDPtr->RemainingData = EpDataPtr->TT.Ctrl.ReqDataSize; /* Yes, receive all data send by the host */
            }
            NewTDPtr->ZLT = FALSE;                         /* No ZLT */
            break;
          case USB_LDD_CONTROL_READ_DATA:
            /* Control read - data stage (Rx) */
            if (NewTDPtr->RemainingData >= EpDataPtr->TT.Ctrl.ReqDataSize) { /* More data then the Host expects? */
              NewTDPtr->RemainingData = EpDataPtr->TT.Ctrl.ReqDataSize; /* Yes, send only requested data size */
              NewTDPtr->ZLT = FALSE;                       /* No ZLT */
            } else {
              NewTDPtr->ZLT = TRUE;                        /* Sent zero-length packet if packet size is multiple of MaxPacketSize */
            }
            break;
          case USB_LDD_CONTROL_WRITE_HSK:
          case USB_LDD_CONTROL_NO_DATA_HSK:
            /* Control write/no-data - handshake stage (Tx) */
            USB_LDD_DeviceReceiveSetupPacket(EpDataPtr-1); /* Be ready to receive setup data packet after HSK is sent */
            break;
          default:
            break;
        }
      } else {                                             /* Non-control transfer */
        if ((UserTDPtr->Head.Flags & LDD_USB_DEVICE_TRANSFER_FLAG_ZLT) != 0x00U) {
          NewTDPtr->ZLT = TRUE;                            /* Sent zero-length packet if packet size is multiple of MaxPacketSize */
        } else {
          NewTDPtr->ZLT = EpDataPtr->ZLT;                  /* Default EP ZLT */
        }
      }
      if ((UserTDPtr->Head.Flags & (uint32_t)LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM) != 0x00U) { /* Additional transfer params? */
        /* If additional transfer params are requested the user TD must not be */
        /* released until the callback is called or the transfer state        */
        /* is LDD_USB_TRANSFER_PENDING */
        NewTDPtr->UserTDPtr = UserTDPtr;                   /* Remember transfer descriptor address? */
        UserTDPtr->TransmittedDataSize = 0x00U;            /* No data transmitted yet */
        UserTDPtr->TransferState = LDD_USB_TRANSFER_PENDING; /* Transfer is pending */
      } else {
        NewTDPtr->UserTDPtr = NULL;
      }
      NewTDPtr->Active = TRUE;                             /* Set transfer size and active bit */
      EpDataPtr->pLastTD = NewTDPtr;                       /* Update last TD pointer */
      USB_LDD_DeviceQueueDataPacket(EpDataPtr,NewTDPtr);   /* Queue transfer */
      if (RecvSetup) {                                     /* Control read handshake stage? */
        USB_LDD_DeviceReceiveSetupPacket(EpDataPtr);       /* Receive new setup data packet */
      }
      Res = ERR_OK;
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return(Res);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDataPacketDone (component USB_LDD)
**
**     Description :
**         Transaction done handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceDataPacketDone(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TEpData *EpDataPtr, uint16_t PacketSize)
{
  USB_LDD_TTD                     *TDPtr;
  LDD_USB_Device_TTD              *UserTDPtr;

  TDPtr     = EpDataPtr->pCurrentTD;
  UserTDPtr = TDPtr->UserTDPtr;
  if (UserTDPtr != NULL) {                                 /* Extended transfer parameters? */
    UserTDPtr->TransmittedDataSize += (uint16_t)PacketSize; /* Yes, update transmitted data counter */
  }
  if (PacketSize < EpDataPtr->MaxPacketSize) {             /* Short(zero-length) packet transmitted? */
     TDPtr->Active = FALSE;                                /* Yes, transfer is done */
  } else {                                                 /* Max. size packet transmitted */
    if (TDPtr->RemainingData == 0x00U) {                   /* All data transmitted? */
      if (TDPtr->ZLT == FALSE) {                           /* Yes, ZLT requested (ZLT can be TRUE only for Tx)? */
        TDPtr->Active = FALSE;                             /* No, transfer is done */
      }
    }
  }
  if (TDPtr->Active == FALSE) {                            /* Transfer done? */
    if (UserTDPtr != NULL) {                               /* Yes, extended transfer parameters? */
      UserTDPtr->TransferState = LDD_USB_TRANSFER_DONE;    /* Update transfer state */
      if (UserTDPtr->CallbackFnPtr != NULL) {              /* Notification required? */
        UserTDPtr->CallbackFnPtr(DevDataPtr->UserDeviceDataPtr, UserTDPtr); /* Call notification function */
      }
    }
    if (TDPtr->Active == FALSE) {                          /* TD reused in Callback? */
      TDPtr = TDPtr->pNextTD;                              /* No, get next Transfer descriptor */
      EpDataPtr->pCurrentTD = TDPtr;
      if (TDPtr->Active == TRUE) {                         /* Next transfer ready? */
        USB_LDD_DeviceQueueDataPacket(EpDataPtr,TDPtr);    /* Queue next packet */
      }
    }
  } else {
    USB_LDD_DeviceQueueDataPacket(EpDataPtr,TDPtr);        /* Queue next packet */
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceAbortAllTransfers (component USB_LDD)
**
**     Description :
**         Cancels all pending transfers for given endpoint
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceAbortAllTransfers(LDD_TDeviceData *DeviceDataPtr, USB_LDD_TEpData *EpDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TTD                     *TDPtr;
  LDD_USB_Device_TTD              *UserTDPtr;
  uint32_t                         CtrlRegVal;

  if (EpDataPtr->EpState >USB_LDD_EP_NOT_CONFIGURED) {
    BDPtr    = (USB_LDD_TBD*)((uint32_t)EpDataPtr->BDPtr & ~(uint32_t)0x08U);
    /* Flush BD */
    /* Compute DATA0/DATA1 for next transaction */
    CtrlRegVal = BDPtr->CtrlReg;
    BDPtr->CtrlReg = 0x00U;
    BDPtr++;
    CtrlRegVal ^= BDPtr->CtrlReg;
    BDPtr->CtrlReg = 0x00U;
    if ((CtrlRegVal & USB_LDD_BD_LE_OWM) != 0x00U) {
      EpDataPtr->BDPtr = (USB_LDD_TBD *)((uint32_t)(EpDataPtr->BDPtr) ^ 0x08U);
    }
    /* Update transfer status and call user provided callback */
    TDPtr = EpDataPtr->pCurrentTD;
    do {                                                   /* For each transfer descriptor do: */
      if (TDPtr->Active) {                                 /* Active transfer descriptor? */
        UserTDPtr = TDPtr->UserTDPtr;                      /* Yes, remember extended transfer parameters address */
        if (UserTDPtr != NULL) {                           /* Extended transfer parameters? */
          UserTDPtr->TransferState = LDD_USB_TRANSFER_ERROR_CANCELLED; /* Yes, update transfer status */
          if (UserTDPtr->CallbackFnPtr != NULL) {          /* Callback required? */
            UserTDPtr->CallbackFnPtr(DevDataPtr->UserDeviceDataPtr, UserTDPtr); /* Call notification function */
          }
        }
        TDPtr->Active = FALSE;                             /* Transfer is finished */
      }
      TDPtr = TDPtr->pNextTD;                              /* Get next TD */
    } while (TDPtr != EpDataPtr->pCurrentTD);
    EpDataPtr->EpState = USB_LDD_EP_IDLE;
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDisableAllEp (component USB_LDD)
**
**     Description :
**         Initializes internal data structure and disables all endpoints.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceDisableAllEp(USB_LDD_TDeviceData *DevDataPtr)
{
  uint32_t                         x;
  USB_LDD_TBD                     *BDPtr = (USB_LDD_TBD*)(void*)DevDataPtr;
  volatile uint8_t                *EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x00);

  for (x = 0x00U; x <= MAX_BD_IDX; x++) {                  /* Clear BDT */
    BDPtr->CtrlReg = 0x00U;
    BDPtr++;
  }
  for (x = 0x00U; x <= 0x0FU; x++) {                       /* Clear all "endpoint control" registers */
    *EpCtrlRegPtr = (uint8_t)0x00U;
    EpCtrlRegPtr++;
  }
  for (x = 0x00U; x <= MAX_EP_IDX; x++) {                  /* Discard all pending transfers */
    (void)USB_LDD_DeviceAbortAllTransfers(DevDataPtr, &DevDataPtr->EpData[x]);
  }

  /* Sets endpoint data variables to the initialization values */
  DevDataPtr->EpData[0x00u].EpState      = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x00u].EpNumber     = 0x00U;
  DevDataPtr->EpData[0x00u].TDQueuePtr   = &DevDataPtr->EP_0_OUT_dTD_Queue[0];
  DevDataPtr->EpData[0x00u].EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x00U);
  DevDataPtr->EpData[0x00u].BDPtr        = &DevDataPtr->BDT[0x00U];
  DevDataPtr->EpData[0x00u].SDPPtr       = (LDD_USB_TSDP *)(DevDataPtr->EP_0_Control_PacketBuffer);
  DevDataPtr->EpData[0x01u].EpState      = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x01u].EpNumber     = 0x00U;
  DevDataPtr->EpData[0x01u].TDQueuePtr   = &DevDataPtr->EP_0_IN_dTD_Queue[0];
  DevDataPtr->EpData[0x01u].EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x00);
  DevDataPtr->EpData[0x01u].BDPtr        = &DevDataPtr->BDT[0x02u];
  DevDataPtr->EpData[0x01u].SDPPtr       = (LDD_USB_TSDP *)(DevDataPtr->EP_0_Control_PacketBuffer);
  DevDataPtr->EpData[0x02u].TransferType = LDD_USB_BULK;
  DevDataPtr->EpData[0x03u].EpState      = USB_LDD_EP_NOT_CONFIGURED;
  DevDataPtr->EpData[0x03u].EpNumber     = 0x01U;
  DevDataPtr->EpData[0x03u].TDQueuePtr   = &DevDataPtr->EP_1_IN_dTD_Queue[0];
  DevDataPtr->EpData[0x03u].EpCtrlRegPtr = USB_PDD_GetEpCtrlRegAddr(USB0_BASE_PTR, 0x01);
  DevDataPtr->EpData[0x03u].BDPtr        = &DevDataPtr->BDT[0x06u];
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceHandleEndpointUsbStatus (component USB_LDD)
**
**     Description :
**         See description of the GetUsbStatus() and SetUsbStatus() 
**         method.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static LDD_TError USB_LDD_DeviceHandleEndpointUsbStatus(USB_LDD_TDeviceData *DevDataPtr, uint16_t Id, uint16_t *CmdStatusPtr)
{
  USB_LDD_TEpData                 *EpDataPtr;
  uint8_t                          EpNum = (uint8_t)(Id & (uint32_t)0x0FU);
  uint8_t                          EpDir = (uint8_t)(Id & (uint32_t)0x80U);
  LDD_TError                       Res = ERR_OK;

  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    return Res;
  }
  if ((Id & ~(uint32_t)LDD_USB_ID_EP_MASK) == 0x00U) {     /* EP address valid? */
    EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
    if (EpDataPtr->TransferType != LDD_USB_CONTROL) {      /* Control EP? */
      if (EpDir != LDD_USB_DIR_OUT) {                      /* No, update EpDataPtr for IN direction endpoint */
        EpDataPtr++;
      }
    }
    if ((uint32_t)EpDataPtr > (uint32_t)&(DevDataPtr->EpData[MAX_EP_IDX + 0x01u])) { /* Check address of EPx data structure */
      Res = ERR_PARAM_ADDRESS;
    }
    if (EpDataPtr->EpState <= USB_LDD_EP_NOT_CONFIGURED) { /* Is EP configured? */
      Res = ERR_PARAM_ADDRESS;                             /* No, =invalid EP */
    }
    if (EpDataPtr->TransferType == LDD_USB_ISOCHRONOUS) {  /* Isochronous EP? */
      Res = ERR_FAILED;                                    /* Isochronous EP has no HALT feature */
    }
    if (Res == ERR_OK) {
      switch (*CmdStatusPtr) {
        case LDD_USB_CMD_CLR_EP_HALT_FATURE:
          USB_LDD_DeviceUnstallEndpoint((LDD_TDeviceData*)DevDataPtr, EpNum, EpDir);
          break;
        case LDD_USB_CMD_SET_EP_HALT_FATURE:
          USB_LDD_DeviceStallEndpoint((LDD_TDeviceData*)DevDataPtr, EpNum, EpDir);
          break;
        case LDD_USB_CMD_GET_EP_STATUS:
          if (((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) != 0x00U) { /* Is EP stalled? */
            *CmdStatusPtr = LDD_USB_CMD_EP_STATUS_HALT_MASK; /* Yes, set halt feature in the returned value */
          } else {
            *CmdStatusPtr = 0x00U;                         /* Yes, clear halt feature in the returned value */
          }
          break;
        default:
          Res =  ERR_PARAM_COMMAND;                        /* Unsupported command */
          break;
      }
    }
  } else {
    Res = ERR_PARAM_ADDRESS;                               /* Bad EP address */
  }
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostStartTransaction (component USB_LDD)
**
**     Description :
**         Starts transaction described by the TD on the head of the 
**         active pipe (DevDataPtr->ActivePipePtr->ActiveTrPtr)
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostStartTransaction(USB_LDD_TDeviceData *DevDataPtr) {
  USB_LDD_TBD                      *BDPtr;
  USB_LDD_TTrDescr                 *TrPtr;
  uint8_t                          *BufferPtr;
  uint32_t                          BDCtrlRegVal;
  uint8_t                           Token;

  TrPtr = DevDataPtr->ActivePipePtr->ActiveTrPtr;                    /* Get transfer descriptor */
  if (TrPtr->TrState == USB_LDD_TRANSFER_SETUP_QUEUED) {
   /* Setup packet */
    BDPtr               = DevDataPtr->TxBDPtr;                       /* Remember BD address */
    DevDataPtr->TxBDPtr = (USB_LDD_TBD *)((uint32_t)(DevDataPtr->TxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    BufferPtr           = (uint8_t*)TrPtr->Head.SDPPrt;              /* Remember setup data buffer address */
    BDCtrlRegVal        = 0x00080080U;                               /* Prepare BD ctrl. reg. value, Size =8, OWN = 1 DATA0 */
    Token               = (uint8_t)(LDD_USB_PID_SETUP << 0x04U);     /* Prepare Token reg. value (SETUP)*/
  } else {
    /* Data packet */
    BufferPtr           = TrPtr->tmpBufferPtr;                       /* Remember data buffer address */
    BDCtrlRegVal        = TrPtr->Head.BufferSize;                    /* Remember remaining data size */
    if (BDCtrlRegVal > DevDataPtr->ActivePipePtr->Head.MaxPacketSize) { /* Remaining data size > then Max packet size? */
      BDCtrlRegVal = DevDataPtr->ActivePipePtr->Head.MaxPacketSize;  /* Yes, send 'MaxPacketSize' length packet */
    }
    BDCtrlRegVal = (BDCtrlRegVal << 0x10) | USB_LDD_BD_OWM | DevDataPtr->ActivePipePtr->NextData01; /* Prepare BD ctrl. reg. value */
    if (DevDataPtr->ActivePipePtr->Head.EpDir == LDD_USB_DIR_OUT) {
      Token               = (uint8_t)(LDD_USB_PID_OUT << 0x04U);     /* Prepare Token reg. value (OUT)*/
      BDPtr               = DevDataPtr->TxBDPtr;                     /* Remember BD address */
      DevDataPtr->TxBDPtr = (USB_LDD_TBD *)((uint32_t)(DevDataPtr->TxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    } else {
      Token               = (uint8_t)(LDD_USB_PID_IN << 0x04U);      /* Prepare Token reg. value (IN)*/
      BDPtr               = DevDataPtr->RxBDPtr;                     /* Remember BD address */
      DevDataPtr->RxBDPtr = (USB_LDD_TBD *)((uint32_t)(DevDataPtr->RxBDPtr) ^ 0x08U); /* Update next BD address pointer */
    }
  }
  TrPtr->TrState =  (USB_LDD_TTrState)((uint32_t)TrPtr->TrState | (uint32_t)USB_LDD_TRANSFER_PENDING); /* Update transfer state */
  BDPtr->BufferPtr = (uint32_t)BufferPtr;                            /* Set buffer address */
  BDPtr->CtrlReg = BDCtrlRegVal;                                     /* Set packet properties */
  Token = (uint8_t)(Token | DevDataPtr->ActivePipePtr->Head.EpNumber); /* Add EP address to the token reg. value */
  USB_PDD_WriteEp0CtrlReg(USB0_BASE_PTR, DevDataPtr->ActivePipePtr->EpCtrlRegVal); /* Set EP handshake and retry policy */
  USB_PDD_WriteAddressReg(USB0_BASE_PTR, DevDataPtr->ActivePipePtr->Head.DevAddress); /* Start transaction */
  USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear error flags */
  USB_PDD_WriteTokenReg(USB0_BASE_PTR, Token);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostQueueTransfer (component USB_LDD)
**
**     Description :
**         Queues transfer descriptor
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static  LDD_TError HostQueueTransfer(
  LDD_TDeviceData               *DeviceDataPtr,
  LDD_USB_Host_TPipeHandle      *PipeHndPtr,
  LDD_USB_Host_TTD              *TrDscrPtr,
  LDD_USB_Host_TTransferHandle **TrHndPtr,
  uint32_t                       TrDir
)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr = (USB_LDD_TPipeDescr*)PipeHndPtr;
  USB_LDD_TTrDescr                 *TrPtr;
  LDD_TError                        Res = ERR_OK;

  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PipePtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (TrDscrPtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((TrDir == LDD_USB_DIR_UNKNOWN) && (TrDscrPtr->SDPPrt == NULL)) {
    return ERR_PARAM_DATA;
  }
  USB_LDD_UsbLock(DeviceDataPtr);
  if (PipePtr->PipeState == USB_LDD_PIPE_CLOSED) {              /* Pipe closed? */
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_FAILED;                                          /* return with error */
  }
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) {
    Res = (LDD_TError)DevDataPtr->HostState;
  } else {
    TrPtr = DevDataPtr->FreeTDListPtr;                          /* Try to get a free TD */
    if (TrPtr != NULL) {                                        /* Found free TD? */
      DevDataPtr->FreeTDListPtr  = TrPtr->NextTrPtr;            /* Yes, dequeue it from free TD queue */
      *(LDD_USB_Host_TTD*)TrPtr  = *TrDscrPtr;                  /* Copy user transfer settings */
      TrPtr->tmpBufferPtr        = TrPtr->Head.BufferPtr;       /* Remember start of data buffer */
      TrPtr->ErrorCounter        = 0x03U;                       /* Max. 3 errors are allowed for transaction */
      TrPtr->NextTrPtr           = NULL;                        /* This is the last TD in the pipe's TD queue */
      if (PipePtr->ActiveTrPtr == NULL) {                       /* Transfer pending on this pipe? */
        PipePtr->ActiveTrPtr = TrPtr;                           /* No, put this TD on the pipe's TD queue head */
      } else {
        PipePtr->LastTrPtr->NextTrPtr = TrPtr;                  /* Tr. pending, put this TD on the pipe's TD queue tail */
      }
      PipePtr->LastTrPtr = TrPtr;                               /* Update pipe's TD queue tail pointer */
      if (TrDscrPtr->SDPPrt != NULL) {                          /* Control Transfer? */
        TrPtr->TrState      = USB_LDD_TRANSFER_SETUP_QUEUED;    /* Set transfer state */
        PipePtr->Head.EpDir = (uint8_t)(TrDscrPtr->SDPPrt->bmRequestType & (uint8_t)LDD_USB_DIR_MASK);
      } else {                                                  /* Non control transfer */
        TrPtr->TrState      = USB_LDD_TRANSFER_DATA_QUEUED;     /* Set transfer state */
        PipePtr->Head.EpDir = (uint8_t)TrDir;
      }

      if ((((uint32_t)PipePtr->Head.TransferType & 1U)) != 0x00U) { /* Periodic pipe? */
        PipePtr->NextFrameNum = 0U;                             /* Starts periodic transfer as soon as possible */
        USB_PDD_EnableSofInterrupt(USB0_BASE_PTR);
      } else {
        if (DevDataPtr->ActivePipePtr == NULL) {                /* Any transfer pending? */
          DevDataPtr->ActivePipePtr = PipePtr;                  /* No, make this pipe active */
          USB_LDD_HostStartTransaction(DevDataPtr);             /* Start transfers */
          USB_PDD_EnableTokenDoneInterrupt(USB0_BASE_PTR);
        }
      }
    } else {
      Res = ERR_QFULL;                                          /* No free transfer descriptor */
    }
    if (TrHndPtr != NULL) {                                     /* Request to return transfer handle? */
      *TrHndPtr = (LDD_USB_Host_TTransferHandle*)TrPtr;         /* Yes, put handle to the provided variable */
    }
  }
  USB_LDD_UsbUnlock(DeviceDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostTransferDone (component USB_LDD)
**
**     Description :
**         Transfer done handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostTransferDone(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TTrDescr *TrPtr)
{
  if (TrPtr->Head.CallbackFnPtr != NULL) {
    TrPtr->Head.CallbackFnPtr(
      DevDataPtr->UserHostDataPtr,
      TrPtr->Head.BufferPtr,
      (uint16_t)((uint32_t)TrPtr->tmpBufferPtr - (uint32_t)TrPtr->Head.BufferPtr),
      TrPtr->Head.ParamPtr,
      (LDD_USB_TTransferState)((uint32_t)(TrPtr->TrState) & (uint32_t)0x3F)
    );
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_CloseAllPipes (component USB_LDD)
**
**     Description :
**         Closes all pipes and discards all pending transfers
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(USB_LDD_TDeviceData *DevDataPtr) {
  USB_LDD_TTrDescr                *TrPtr;
  uint32_t                         x;

  USB_LDD_UsbLock(DevDataPtr);
  DevDataPtr->FreeTDListPtr = &DevDataPtr->TDT[0x00]; /* Set FreeTDListPtr to the begin of TD array */
  TrPtr = DevDataPtr->FreeTDListPtr;   /* Go through the TD array and cancel all pending transfers */
  for (x = 0x00U; x < (MAX_TRANSFERS-0x01U); x++) {
    if (TrPtr->TrState >= USB_LDD_TRANSFER_QUEUED) { /* Pending transfer? */
      TrPtr->TrState = USB_LDD_TRANSFER_ERROR_CANCELLED; /* Call callback */
      if (TrPtr->Head.CallbackFnPtr != NULL) {
        TrPtr->Head.CallbackFnPtr(DevDataPtr->UserHostDataPtr, TrPtr->Head.BufferPtr, TrPtr->Head.BufferSize, TrPtr->Head.ParamPtr, LDD_USB_TRANSFER_ERROR_CANCELLED);
      }
    }
    TrPtr->NextTrPtr = TrPtr + 0x01;   /* Add next TD to the FreeTDListPtr list */
    TrPtr++;                           /* Take next TD item */
  }
  TrPtr->NextTrPtr = NULL;             /* Last TD in the array is the last item in the FreeTDList */
  for (x = 0x00U; x < MAX_PIPES; x++) { /* Go through the Pipe array and set pipe state to "CLOSED" */
    DevDataPtr->PDT[x].PipeState = USB_LDD_PIPE_CLOSED;
  }
  for (x = 0x00U; x < 0x04U; x++) {    /* Go through the Pipe array and set pipe state to "CLOSED" */
    DevDataPtr->BDT[x].CtrlReg = 0x00U;
  }
  USB_PDD_ResetBdtPingPong(USB0_BASE_PTR);
  USB_PDD_EnableControlEP(USB0_BASE_PTR, 0x00, PDD_DISABLE);
  DevDataPtr->AsyncPipeListHeadPtr = NULL;
  DevDataPtr->AsyncPipeListTailPtr = NULL;
  DevDataPtr->PeriodicPipeListHeadPtr = NULL;
  DevDataPtr->PerTrFrameSize = 0x00U;
  DevDataPtr->LastFrameNum = 0x00U;
  DevDataPtr->SofThresholdValue = 0x00U;
  DevDataPtr->SofThresholdDetected = FALSE;
  DevDataPtr->ActivePipePtr = NULL;
  DevDataPtr->RxBDPtr = &DevDataPtr->BDT[0x00];
  DevDataPtr->TxBDPtr = &DevDataPtr->BDT[0x02];
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostDisabledPort (component USB_LDD)
**
**     Description :
**         Sets the port to the DISABLED state and closes all pipes and 
**         discards all pending transfers. This state can be changed only 
**         by performing the bus reset(transfer to the ENABLED state), by 
**         disconnecting the device (transfer to the DISCONNECT state) or 
**         by the powering-off the bus (transfer to the POWERED_OFF 
**         state).
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostDisabledPort(USB_LDD_TDeviceData *DevDataPtr) {
  /* Called from ISR if "disconnect" event is detected */
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
  USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);           /* This is necessary to correctly detect device speed */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Enable only "attach" interrupt */
  DevDataPtr->HostState = LDD_USB_HOST_PORT_DISABLED;
  USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostResetPort (component USB_LDD)
**
**     Description :
**         Sets the port to the RESET state, starts the reset signaling, 
**         and closes all pipes and discards all pending transfers. As 
**         soon as the reset interval is elapsed the reset signaling will 
**         be stopped, the port state will be change to the 
**         RESET_RECOVERING, and the reset recovery interval will begin. 
**         After the reset recovery interval is elapsed, the port state 
**         will be changed to the ENABLED state. In the ENABLED state the 
**         port can used to transfer data.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostResetPort(USB_LDD_TDeviceData *DevDataPtr) {
  do {
    USB_PDD_ClearTokenBusyFlag(USB0_BASE_PTR);
  } while (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR));
  DevDataPtr->HostState = LDD_USB_HOST_PORT_RESETING;           /* Set new state */
  USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);  /* Cancel all transfers */
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00);             /* Disable all interrupt */
  USB_PDD_StartResetSignaling(USB0_BASE_PTR, PDD_ENABLE);       /* Start reset signaling */
  USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESET_INTERVAL_MS + 1); /* Start reset signaling */
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSuspendPort (component USB_LDD)
**
**     Description :
**         Suspends port. No transaction should be pending before this 
**         method is called.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostSuspendPort(USB_LDD_TDeviceData *DevDataPtr) {
  DevDataPtr->HostState = LDD_USB_HOST_PORT_SUSPENDED;          /* Set new state */
  do {                                                          /* Wait till the token(SOF) is done */
  } while (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR));
  USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);                /* Disable SOF */
  USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary not to detect false resume */
  USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);           /* This is necessary not to detect false resume */
  USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,0xFF);           /* Clear all interrupt flags */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_RESUME_INT); /* Enable "resume" interrupt */
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE);        /* Suspend transceiver */
  USB_LDD_StartTimer(DevDataPtr, 4);                             /* Enable deattach(USB 2.0 chapter 11.5.1.9) interrupt 4 ms later */
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostResumePort (component USB_LDD)
**
**     Description :
**         Resumes port.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostResumePort(USB_LDD_TDeviceData *DevDataPtr) {
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE);       /* Wake up transceiver */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Enable only "deattach" interrupt */
  if (DevDataPtr->BusSpeed == LDD_USB_LOW_SPEED) {
    USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_ENABLE); /* This is necessary not to detect false resume */
    USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_ENABLE);          /* This is necessary not to detect false resume */
  }
  USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_ENABLE);
  DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUMING;           /* Remember new state */
  USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESUME_INTERVAL_MS + 1); /* Start resume signaling */
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceEnable (component USB_LDD)
**
**     Description :
**         Starts device mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceEnable(USB_LDD_TDeviceData *DevDataPtr) {
  DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_ON;             /* Remember new device state */
  DevDataPtr->msCounter = -1;                                   /* No timing request */
  USB_LDD_DeviceDisableAllEp(DevDataPtr);
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE);       /* Enable transceiver */
  USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, USB_PDD_1_MSEC_INT); /* Clear 1ms interrupt flag */
  USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear all error interrupt flags */
  USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear all usb interrupt flags */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_SLEEP_INT | USB_PDD_USB_RST_INT); /* Enable reset and suspend interrupts */
  USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);                    /* Disable "1ms" interrupt */
  USB_PDD_EnableDevice(USB0_BASE_PTR, PDD_ENABLE);               /* Enable device mode */
  DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_ON;              /* VBUS is on, remember new state */
  USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) | (uint8_t)0x80)); /* Enable D+ pull-up.*/
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDisable (component USB_LDD)
**
**     Description :
**         Stops device mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceDisable(USB_LDD_TDeviceData *DevDataPtr) {
  DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;            /* Remember new device state */
  DevDataPtr->msCounter = -1;                                   /* No timing request */
  USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);                   /* Disable "1ms" interrupt */
  USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);          /* Disable all error interrupt */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00U);            /* Disable all usb interrupt */
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE);        /* Disable transceiver */
  USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) & (uint8_t)~(uint8_t)0x80)); /* Disable D+ pull-up */
  USB_PDD_DisableModule(USB0_BASE_PTR);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostEnable (component USB_LDD)
**
**     Description :
**         Starts host mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostEnable(USB_LDD_TDeviceData *DevDataPtr) {
  USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);          /* Disable all "Error" interrupts */
  USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear "Attach" interrupt flag */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_ATTACH_INT); /* Enable "Attach" interrupt */
  DevDataPtr->msCounter = -1;                                   /* No timing request */
  DevDataPtr->PerTrFrameSize = 0x00U;                           /* No bus bandwidth is allocated */
  DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED;       /* Update state variable */
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE);       /* Enable transceiver */
  USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
      (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN),
      (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN));
  USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, (USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) | (uint8_t)0x30)); /* Enable D+- pull-downs. Enable VBUS */
  USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);                   /* Disable "1ms" interrupt */
  USB_PDD_EnableHost(USB0_BASE_PTR, PDD_ENABLE);                /* Enable host mode */
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostDisable (component USB_LDD)
**
**     Description :
**         Stops host mode.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostDisable(USB_LDD_TDeviceData *DevDataPtr) {
  if (DevDataPtr->HostState > LDD_USB_HOST_PORT_DISCONNECTED) {
    DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED;
    if (DevDataPtr->EventMask & LDD_USB_ON_HOST_DEVICE_DEATTACH) {
      USB_LDD_OnHostDeviceDeattach(DevDataPtr->UserHostDataPtr);
    }
  }
  DevDataPtr->HostState = LDD_USB_HOST_DISABLED;                /* Update state variable */
  DevDataPtr->msCounter = -1;                                   /* No timing request */
  USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
      (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN),
      (LDD_TPinMask)(0x00));
  USB_PDD_DisableModule(USB0_BASE_PTR);                         /* Disable module */
  USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_ENABLE);        /* Disable transceiver */
  USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);                   /* Disable "1ms" interrupt */
  USB_PDD_SetErrorInterruptMask(USB0_BASE_PTR, 0x00U);          /* Disable all "Error" interrupts */
  USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00U);            /* Disable all "Usb" interrupts */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Init (component USB_LDD)
**
**     Description :
**         Initializes USB device. Allocates memory for the device data
**         structure, interrupts, pins, etc. This method doesn't enable
**         device pull-up. Use Enable() method to enable device pull-up.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     Returns     :
**         ---             - Pointer to the dynamically allocated
**                           private structure or NULL if there was an
**                           error.
** ===================================================================
*/
LDD_TDeviceData * USB_LDD_Init(LDD_TUserData *UserDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr;

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DevDataPtr = &DevDataPtr__DEFAULT_RTOS_ALLOC;
  /* {Default RTOS Adapter} Driver memory allocation: Fill the allocated memory by zero value */
  PE_FillMemory(DevDataPtr, 0U, sizeof(USB_LDD_TDeviceData));
  DevDataPtr->UserOtgDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_USB0__DEFAULT_RTOS_ISRPARAM =  DevDataPtr;
  /* Interrupt vector(s) priority setting */
  /* NVICIP73: PRI73=0x80 */
  NVICIP73 = NVIC_IP_PRI73(0x80);                                                   
  /* NVICISER2: SETENA|=0x0200 */
  NVICISER2 |= NVIC_ISER_SETENA(0x0200);                                                   
  /* Clock setting */
  /* Input clock source:      PLL clock */
  /* Input clock frequency:   48 MHz */
  /* Input clock multiplier:  1 */
  /* Input clock divider:     1 */
  /* Module clock frequency:  48 MHz */
  /* SIM_SOPT2: USBSRC=1 */
  SIM_SOPT2 |= SIM_SOPT2_USBSRC_MASK;  /* Divided PllFll clock */
  /* SIM_CLKDIV2: USBDIV=0,USBFRAC=0 */
  SIM_CLKDIV2 &= (uint32_t)~(uint32_t)(
                  SIM_CLKDIV2_USBDIV(0x07) |
                  SIM_CLKDIV2_USBFRAC_MASK
                 );                    /* Div=1 - Mult=1  */
  /* Enable module clock */
  /* SIM_SCGC4: USBOTG=1 */
  SIM_SCGC4 |= SIM_SCGC4_USBOTG_MASK;                                                   
  /* Reset module */
  /* USB0_USBTRC0: USBRESET=1 */
  USB0_USBTRC0 = USB_USBTRC0_USBRESET_MASK; /* Reset module */
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Enable USB voltage regulator */
  /* SIM_SOPT1: ??=1 */
  SIM_SOPT1 |= 0x80U;                  /* Enable USB voltage regulator */
  /* USB0_USBTRC0: ??=1 */
  USB0_USBTRC0 = 0x40U;                /* Enable internal pull-up */
  /* USB0_USBCTRL: SUSP=1,PDE=0 */
  USB0_USBCTRL = USB_USBCTRL_SUSP_MASK; /* Enable weak pull-downs and suspend transceiver */
  /* USB0_OTGCTL: DPHIGH=0,??=0,DPLOW=1,DMLOW=1,??=0,OTGEN=1,??=0,??=0 */
  USB0_OTGCTL = USB_OTGCTL_DPLOW_MASK |
                USB_OTGCTL_DMLOW_MASK |
                USB_OTGCTL_OTGEN_MASK;                       
  /* Set BDT address */
  USB0_BDTPAGE1 = (uint8_t)((((uint32_t)DevDataPtr) >> 8) & 0xFEU);
  USB0_BDTPAGE2 = (uint8_t)((((uint32_t)DevDataPtr) >> 16) & 0xFFU);
  USB0_BDTPAGE3 = (uint8_t)((((uint32_t)DevDataPtr) >> 24) & 0xFFU);
  /* Initialize device data structure */
  DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;
  DevDataPtr->HostState   = LDD_USB_HOST_DISABLED;
  DevDataPtr->OtgState    = LDD_USB_OTG_DISABLED;
  DevDataPtr->msCounter = -1;                               /* No timing request */
  DevDataPtr->EventMask = USB_LDD_INIT_EVENTS_MASK;
  USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
      (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN | LDD_USB_OTG_VBUS_CHARGE_PIN | LDD_USB_OTG_VBUS_DISCHARGE_PIN),
      (LDD_TPinMask)(0x00));
  DevDataPtr->EnUser = FALSE;
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID,DevDataPtr);
  return (LDD_TDeviceData*)(DevDataPtr);                    /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  USB_LDD_Deinit (component USB_LDD)
**
**     Description :
**         Disables and deinitializes the device and frees the device
**         data structure memory.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     : Nothing
** ===================================================================
*/
void USB_LDD_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  (void)DevDataPtr;                                        /* Parameter is not used, suppress unused argument warning */
  /* {Default RTOS Adapter} Critical section begin, general PE function is used */
  EnterCritical();
  /* Reset module */
  USB_PDD_ResetModule(USB0_BASE_PTR);
  while (USB_PDD_GetModuleResetPendingFlag(USB0_BASE_PTR)) {
    ; /* Wait for reset done */
  }
  /* Disable module clock */
  /* SIM_SCGC4: USBOTG=0 */
  SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);                                                   
  /* {Default RTOS Adapter} Critical section end, general PE function is used */
  ExitCritical();
  /* Restoring the interrupt vector */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_USB_LDD_ID);
  /* Deallocation of the device structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
}

/*
** ===================================================================
**     Method      :  USB_LDD_SetEventMask (component USB_LDD)
**
**     Description :
**         Enables/disables event(s). The events contained within the
**         mask are enabled. Events not contained within the mask are
**         disabled. Pair method to GetEventMask().
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EventMask       - Mask of events to enable.
**     Returns     :
**         ---             - Return value:
**                           ERR_OK
**                           ERR_PARAM_MASK - Invalid mask.
**                           ERR_DISABLED - Device is disabled.
** ===================================================================
*/
LDD_TError USB_LDD_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EventMask & (LDD_TEventMask)~USB_LDD_AVAILABLE_EVENTS_MASK) {
    return ERR_PARAM_MASK;
  }
  USB_LDD_UsbLock(DevDataPtr);
  DevDataPtr->EventMask = EventMask;
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_GetEventMask (component USB_LDD)
**
**     Description :
**         Returns current events mask. Pair method to SetEventMask().
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Current event mask.
** ===================================================================
*/
LDD_TEventMask USB_LDD_GetEventMask(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  return DevDataPtr->EventMask;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Enable (component USB_LDD)
**
**     Description :
**         Enables the USB device (PHY, SIE). Enables device's DP(DM)
**         pull-up.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - 
** ===================================================================
*/
LDD_TError USB_LDD_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (!DevDataPtr->EnUser) {
    DevDataPtr->EnUser = TRUE;
    USB_LDD_UsbLock(DevDataPtr);
    DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED_BY_OTG;
    DevDataPtr->HostState = LDD_USB_HOST_DISABLED_BY_OTG;
    DevDataPtr->OtgState = LDD_USB_OTG_DISABLED;
    USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, USB_PDD_ALL_INT_FLAGS); /* Clear "Otg" interrupt flag */
    USB_PDD_SetOtgInterruptMask(USB0_BASE_PTR, USB_PDD_ID_CHG_INT | USB_PDD_LINE_STATE_CHG_INT | USB_PDD_SESS_VLD_CHG_INT | USB_PDD_B_SESS_CHG_INT | USB_PDD_A_VBUS_CHG_INT);
    USB_LDD_StartOtgTimer(DevDataPtr, 2);
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_Disable (component USB_LDD)
**
**     Description :
**         Disabled device's DP(DM) pull-up. Disables PHY, etc.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - 
** ===================================================================
*/
LDD_TError USB_LDD_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  if (DevDataPtr->EnUser) {
    DevDataPtr->EnUser = FALSE;
    USB_LDD_UsbLock(DevDataPtr);
    USB_LDD_DeviceDisable(DevDataPtr);
    USB_LDD_HostDisable(DevDataPtr);
    USB_PDD_SetOtgInterruptMask(USB0_BASE_PTR, 0x00);
    DevDataPtr->DeviceState = LDD_USB_DEVICE_DISABLED;
    DevDataPtr->HostState = LDD_USB_HOST_DISABLED;
    DevDataPtr->OtgState = LDD_USB_OTG_DISABLED;
    USB_LDD_UsbUnlock(DevDataPtr);
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceGetUsbStatus (component USB_LDD)
**
**     Description :
**         Returns the status of the object (e.g. endpoint). This
**         method is intended to be used in the standard USB
**         'GetStatus' request handler.
**         The object is described by the command (CmdStatusPtr
**         parameter) and by the id (Id parameter). 
**         The supported commands are:
**         [1) LDD_USB_CMD_GET_EP_STATUS] - Fills the memory addressed
**         by the CmdStatusPtr parameter by the current endpoint XXX
**         status (where XXX = Id parameter value) .
**         Format of the returned status is defined in the USB
**         specification 2.0, figure 9.6.
**         The LDD_USB_CMD_EP_STATUS_HALT_MASK constant can be used to
**         get endpoint status from the returned value.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         Id              - Id. (E.g endpoint address for endpoint
**                           status, ...)
**                           The Id parameter value has the same format
**                           as wIndex parameter in the setup data
**                           packet - see USB specification.
**       * CmdStatusPtr    - Pointer to the uint16_t
**                           in/out variable. This variable must
**                           contains requested command before the
**                           method is called and contains requested
**                           status after the method returns.
**                           The supported command are:
**                           LDD_USB_CMD_GET_EP_STATUS
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_PARAM_ADDRESS - No such object (e.g.
**                           endpoint doesn't exists or is not enabled
**                           by the host). Note: The 'Id' parameter
**                           check is always enabled in order to
**                           simplify implementation of the standard USB
**                           GetStatus request handler.
**                           ERR_FAILED - Command not supported for
**                           current object setting (e.g. STALL feature
**                           is not supported for isochronous endpoints).
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command cannot be accomplished
**                           in XXX <device state>.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceGetUsbStatus(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t *CmdStatusPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData *)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (*CmdStatusPtr == LDD_USB_CMD_GET_EP_STATUS) {         /* EP command? */
    Res = USB_LDD_DeviceHandleEndpointUsbStatus(DevDataPtr, Id, CmdStatusPtr);
  } else {
    Res = ERR_PARAM_COMMAND;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSetUsbStatus (component USB_LDD)
**
**     Description :
**         Sets the status(feature) of the object (e.g. endpoint). This
**         method is intended to be used in the standard USB
**         ClearFeature/SetFeature request handler.
**         The object is described by the command (Cmd parameter) and
**         by the id (Id parameter). 
**         The supported commands are:
**         [LDD_USB_CMD_SET_EP_HALT_FATURE] - Sets HALT feature for
**         endpoint XXX (where XXX = Id parameter value).
**         [LDD_USB_CMD_CLR_EP_HALT_FATURE] - Clears HALT feature for
**         endpoint XXX (where XXX = Id parameter value).
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         Id              - Id. (E.g endpoint address for endpoint
**                           status, ...)
**                           The Id parameter value has the same format
**                           as wIndex parameter in the setup data
**                           packet - see USB specification.
**         Cmd             - Command. Supported commands are:
**                           LDD_USB_CMD_SET_EP_HALT_FATURE
**                           LDD_USB_CMD_CLR_EP_HALT_FATURE
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_PARAM_ADDRESS - No such object (e.g.
**                           endpoint doesn't exists or is not enabled
**                           by the host). Note: The 'Id' parameter
**                           check is always enabled in order to
**                           simplify implementation of the standard USB
**                           GetStatus request handler.
**                           ERR_FAILED - Command not supported for
**                           current object setting (e.g. STALL feature
**                           is not supported for isochronous endpoints).
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command cannot be accomplished
**                           in XXX <device state>.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceSetUsbStatus(LDD_TDeviceData *DeviceDataPtr, uint16_t Id, uint16_t Cmd)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData *)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  switch (Cmd) {
    case LDD_USB_CMD_CLR_EP_HALT_FATURE:
    case LDD_USB_CMD_SET_EP_HALT_FATURE:
       Res = USB_LDD_DeviceHandleEndpointUsbStatus(DevDataPtr, Id, &Cmd);
       break;
    default:
      Res = ERR_PARAM_COMMAND;
      break;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSetAddress (component USB_LDD)
**
**     Description :
**         Sets new device address. Address must be in range 0-127 but
**         no check is performed.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         Address         - New device address.
**     Returns     : Nothing
** ===================================================================
*/
void USB_LDD_DeviceSetAddress(LDD_TDeviceData *DeviceDataPtr, uint8_t Address)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  USB_PDD_WriteAddressReg(USB0_BASE_PTR, Address);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceAssertResume (component USB_LDD)
**
**     Description :
**         Starts Remote wake-up signaling. Remote wake up signaling is
**         stopped automatically (by the HW or explicitly by the SW).
**         [Note:] Resume signaling can be started only if device is in
**         suspend state more then 5 ms (Device state =
**         LDD_USB_DEVICE_SUSPENDED_RESUME_READY).
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - The command is not supported in
**                           XXX <device state>.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceAssertResume(LDD_TDeviceData *DeviceDataPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_SUSPENDED_RESUME_READY) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_ENABLE);
  USB_LDD_StartTimer(DevDataPtr, 0x06); /* Force resume signaling for at least 5 ms */
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceInitEndpoint (component USB_LDD)
**
**     Description :
**         Initializes endpoint according to the values in the
**         <standard Endpoint descriptor> and in the flags parameter.
**         As soon as the ERR_OK is returned the endpoint can be used
**         to transmit data. To initialize endpoint 0 you can create
**         Endpoint descriptor for EP0 or you can use the <standard
**         Device descriptor>.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * EpDescriptorPtr - Pointer to
**                           standard Endpoint descriptor structure
**                           pointer. To initialize EP0 you can use
**                           pointer to the standard Device descriptor
**                           structure.
**         Flags           - Additional EP properties. 
**                           For Bulk/Interrupt transfer types:
**                           0 = no ZLT,  1 = ZLT
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the HW.
**                           ERR_PARAM_TYPE - Requested transfer is not
**                           supported by the HW for given address and
**                           direction.
**                           ERR_PARAM_SIZE - Requested max. packet size
**                           is not supported by the HW.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - Device is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceInitEndpoint(LDD_TDeviceData *DeviceDataPtr, LDD_USB_TEpDescriptor *EpDescriptorPtr, uint8_t Flags)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  bool                             ZLT;
  uint32_t                         x,y,EpNum;
  uint32_t                         QueueSize;
  uint32_t                         EpDir;
  LDD_USB_TTransferType            EpTransferType;
  uint16_t                         EpMaxPacketSize;
  USB_LDD_TTD                     *TDPtr;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res = ERR_OK;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  if (EpDescriptorPtr->bDescriptorType == LDD_USB_DT_DEVICE) {
    EpNum           = 0U;
    EpDataPtr       = DevDataPtr->EpData; /* Get address of EPx OUT data structure */
    EpTransferType  = LDD_USB_CONTROL;
    EpMaxPacketSize = ((LDD_USB_TDevDescriptor *)(void *)EpDescriptorPtr)->bMaxPacketSize0;
  } else {
    EpNum           = ((uint32_t)EpDescriptorPtr->bEndpointAddress & 0x7FU);
    EpDataPtr       = &DevDataPtr->EpData[(uint8_t)((EpDescriptorPtr->bEndpointAddress & 0x7FU) << 0x01U)]; /* Get address of EPx OUT data structure */
    EpTransferType  = (LDD_USB_TTransferType )((EpDescriptorPtr->bmAttributes) & 0x03U);
    EpMaxPacketSize = EpDescriptorPtr->wMaxPacketSize;
  }
  if (EpTransferType == LDD_USB_CONTROL) { /* Control EP has queue size = 0 */
    QueueSize = 0x00U;
    EpDir     = LDD_USB_DIR_OUT;
    y         = 0x01U;
    ZLT       = TRUE;
  } else {
    QueueSize = (uint32_t)Flags & 0x7FU;
    ZLT       = (bool)(Flags & 0x80U);
    EpDir     = ((uint32_t)(EpDescriptorPtr->bEndpointAddress) & 0x80U);
    y         = 0x00U;
  }
  if (QueueSize == 0x00U) {
    QueueSize++;
  }
  do {
    if (EpDir != LDD_USB_DIR_OUT) {    /* EPx IN data structure is the next item */
      EpDataPtr++;
    }
    if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX]) { /* Check address of EPx data structure */
      Res = ERR_PARAM_ADDRESS;
    }
    if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
      Res = ERR_PARAM_ADDRESS;
    }
    if (Res != ERR_OK) {
      break;
    }
    TDPtr                       = EpDataPtr->TDQueuePtr;
    EpDataPtr->EpState          = USB_LDD_EP_IDLE;
    EpDataPtr->TransferType     = EpTransferType;
    EpDataPtr->MaxPacketSize    = EpMaxPacketSize;
    EpDataPtr->ZLT              = ZLT;
    EpDataPtr->pCurrentTD       = TDPtr;
    EpDataPtr->pLastTD          = TDPtr;
    EpDataPtr->BDCtrlRegVal     = USB_LDD_BD_DATA0 | USB_LDD_BD_OWM | USB_LDD_BD_DTS;
    /* Prepare TDs queue */
    for (x = 0x00U; x < QueueSize; x++) {
      TDPtr->Active = FALSE;
      TDPtr->pNextTD = (TDPtr + 0x01U); /* Join TDs */
      TDPtr++;
    }
    (--TDPtr)->pNextTD = EpDataPtr->TDQueuePtr;
    BDPtr = EpDataPtr->BDPtr;
    BDPtr->CtrlReg = 0x00U;
    (BDPtr + 0x01U)->CtrlReg = 0x00U;
    if (EpTransferType == LDD_USB_CONTROL) {
      if (EpDir == LDD_USB_DIR_IN) {   /* EPx IN data structure is the next item */
        USB_PDD_EnableControlEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      } else {
        EpDir = LDD_USB_DIR_IN;
      }
    } else if (EpTransferType == LDD_USB_ISOCHRONOUS) {
      if (EpDir == LDD_USB_DIR_IN) { /* IN(Tx) direction */
        USB_PDD_EnableIsoTxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      } else {  /* OUT(Rx) direction */
        USB_PDD_EnableIsoRxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      }
    } else {
      if (EpDir == LDD_USB_DIR_IN) { /* IN(Tx) direction? */
        USB_PDD_EnableBulkOrIntTxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      } else { /* OUT(Rx) direction */
        USB_PDD_EnableBulkOrIntRxEP(USB0_BASE_PTR, EpNum, PDD_ENABLE);
      }
    }
  } while (y--);
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceDeinitEndpoint (component USB_LDD)
**
**     Description :
**         Deinitializes EP and disables it in the HW. For control EP
**         both directions are deinitialized. All pending transfers are
**         aborted and callback functions are called, if enabled.
**         If the device is not in enabled <state> the method returns
**         ERR_USB_DEVICE_XXX error code.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EpNum           - Endpoint number.
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the HW.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state. - Device is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceDeinitEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState > USB_LDD_EP_NOT_CONFIGURED) {
    if (EpDataPtr->TransferType == LDD_USB_CONTROL) {       /* Control EP? */
      USB_PDD_EnableControlEP(USB0_BASE_PTR, EpNum, PDD_DISABLE);
      (EpDataPtr + 1)->EpState = USB_LDD_EP_NOT_CONFIGURED;
    } else {
      if (EpDir == LDD_USB_DIR_OUT) {                       /* OUT(Rx) direction */
        USB_PDD_DisableTxEP(USB0_BASE_PTR, EpNum);
      } else {
        USB_PDD_DisableRxEP(USB0_BASE_PTR, EpNum);
      }
    }
    EpDataPtr->EpState = USB_LDD_EP_NOT_CONFIGURED;
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceStallEndpoint (component USB_LDD)
**
**     Description :
**         Sets STALL feature for endpoint.
**         Note: No parameters and endpoint state are checked. The
**         <DeviceSetUsbStatus()> method provides same functionality
**         with state and parameter checking.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EpNum           - Endpoint number.
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     Returns     : Nothing
** ===================================================================
*/
void USB_LDD_DeviceStallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TBD                     *BDPtr;

  USB_LDD_UsbLock(DevDataPtr);
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
  if (EpDataPtr->TransferType == LDD_USB_CONTROL) {        /* Control EP? */
    USB_PDD_StallControlEP(USB0_BASE_PTR, EpNum, PDD_ENABLE); /* Stall EP */
    (EpDataPtr + 1)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr + 1)->EpState) | (uint32)USB_LDD_EP_STALLED);
    USB_LDD_DeviceReceiveSetupPacket(EpDataPtr);           /* Be ready to receive setup data packet */
  } else {
    if (EpDir != LDD_USB_DIR_OUT) {
      EpDataPtr++;
    }
    BDPtr = EpDataPtr->BDPtr;
    BDPtr->CtrlReg |= USB_LDD_BD_LE_STALL;                 /* UNSTALL ODD BD entry */
    (++BDPtr)->CtrlReg |= USB_LDD_BD_LE_STALL;             /* UNSTALL ODD BD entry */
  }
  EpDataPtr->EpState = (USB_LDD_TePState)((uint32_t)(EpDataPtr->EpState) | (uint32)USB_LDD_EP_STALLED);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceUnstallEndpoint (component USB_LDD)
**
**     Description :
**         Clears STALL feature for endpoint.
**         Note: No parameters and endpoint state are checked. The
**         <DeviceSetUsbStatus()> method provides same functionality
**         with state and parameter checking.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EpNum           - Endpoint number.
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     Returns     : Nothing
** ===================================================================
*/
void USB_LDD_DeviceUnstallEndpoint(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  USB_LDD_TBD                     *BDPtr;

  USB_LDD_UsbLock(DevDataPtr);
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx data structure */
  if (EpDataPtr->TransferType == LDD_USB_CONTROL) {         /* Control EP? */
    (EpDataPtr + 1)->EpState = (USB_LDD_TePState)((uint32_t)((EpDataPtr +1 )->EpState) & ~(uint32)USB_LDD_EP_STALLED);
  } else {
    if (EpDir != LDD_USB_DIR_OUT) {
      EpDataPtr++;
    }
    BDPtr = EpDataPtr->BDPtr;
    BDPtr->CtrlReg &= ~(USB_LDD_BD_LE_STALL | USB_LDD_BD_LE_DATA1); /* UNSTALL ODD BD entry, set data toggle to DATA0 */
    (++BDPtr)->CtrlReg &= ~(USB_LDD_BD_LE_STALL | USB_LDD_BD_LE_DATA1); /* UNSTALL EVEN BD entry, set data toggle to DATA0 */
  }
  EpDataPtr->EpState = (USB_LDD_TePState)((uint32_t)(EpDataPtr->EpState) & ~(uint32)USB_LDD_EP_STALLED);
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceReadSetupData (component USB_LDD)
**
**     Description :
**         Fills the given buffer with last received setup data packet
**         for given EP.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EpNum           - Endpoint number.
**       * SDPPtr          - Address of the buffer for setup data.
**     Returns     : Nothing
** ===================================================================
*/
void USB_LDD_DeviceReadSetupData(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, LDD_USB_TSDP *SDPPtr)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TEpData                 *RxEpDataPtr;
  USB_LDD_TEpData                 *TxEpDataPtr;

  USB_LDD_UsbLock(DevDataPtr);
  RxEpDataPtr = &DevDataPtr->EpData[(uint32_t)EpNum << 0x01u]; /* Get address of EPx OUT data structure */
  TxEpDataPtr = RxEpDataPtr + 0x01U;                       /* Get address of EPx IN data structure */
  BDPtr       = RxEpDataPtr->LastTrBDPtr;
  *SDPPtr = *(LDD_USB_TSDP*)BDPtr->BufferPtr;
  USB_PDD_ClearTxSuspendFlag(USB0_BASE_PTR);               /* Restore packet transmission */
  TxEpDataPtr->TT.Ctrl.ReqDataSize = SDPPtr->wLength;      /* Remember requested data size */
  RxEpDataPtr->TT.Ctrl.ReqDataSize = SDPPtr->wLength;      /* Remember requested data size */
  USB_LDD_UsbUnlock(DevDataPtr);
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceSendData (component USB_LDD)
**
**     Description :
**         This method prepares data to be sent to the HOST (transfer
**         request). The transfer request is queued into the internal
**         queue of requests for given endpoint. Some devices have HW
**         queues. On other devices the queue can be emulated by the SW
**         or no queue is implemented (property Max. queue size = 1 and
**         cannot be modified). Size of queue can be defined for each
**         endpoint at the design time. As soon as the host sends IN
**         token data from the request on the queue head are sent to
**         the HOST. This process is repeated until all data are
**         transferred or transfer is cancelled. If the transfer is
**         done the request is removed from the queue and next request
**         becomes ready for transmission, if queue not empty.
**         Each transfer is described by the <transfer descriptor (TD)>
**         structure.
**         The first item of the TD is the <Head> structure. The Head
**         structure item is required and contains these items:
**         _/[EpNum]/_ - endpoint number.
**         _/[BufferPtr]/_ - buffer address.
**         _/[BufferSize]/_ - buffer size.
**         _/[Flags]/_ - flags:
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_ZLT/_ - this flag can be used
**         to force zero-length termination(ZLT) of the transfer.
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM/_ - see below.
**         The following items of the TD are optional:
**         _/[TransmittedDataSize]/_ - this item is set by the driver
**         and contains actual number of transmitted data.
**         _/[CallbackFnPtr]/_ - pointer to the callback function
**         called (if not NULL) after the transfer is done.
**         _/[ParamPtr]/_ - parameter passed to the callback function.
**         The optional items can be used to track the status of the
**         transfer request and are used(accessed) by the driver only
**         if <LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM> flag is set to
**         '1' in the Head.Flags item. In this case the TD must be
**         accessible from the ISR and may be freed only if the
**         transfer is done (TransfereState item must be lower then
**         LDD_USB_TRANSFER_QUEUED). Pending transfer requests can be
**         cancelled by the <DeviceCancelTransfer()> method.
**         Transfer is done if all data are sent. If data size = max.
**         packet size and ZLT is enabled the zero length packet is
**         send as the last packet of the transfer.
**         [Note:]For control transfer the transmitted data size
**         truncated (if necessary) by the driver to the size requested
**         by the host (wLength item of setup data packet) and the ZLT
**         is added if needed. Note: On some MCUs (e.g. Kinetis) must
**         be the address of the data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * TransferDescriptorPtr -
**                           Pointer to the <transfer descriptor (TD)>
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_QFULL - Endpoint transfer queue is full.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceSendData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr)
{
  return(USB_LDD_DeviceQueueTransfer((USB_LDD_TDeviceData*)DeviceDataPtr, TransferDescriptorPtr, LDD_USB_DIR_IN));
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceRecvData (component USB_LDD)
**
**     Description :
**         This method prepares buffer for data sent by the HOST
**         (transfer request). The transfer request is queued into the
**         internal queue of requests for given endpoint. Some devices
**         have HW queues. On other devices the queue can be emulated
**         by the SW or no queue is implemented (property Max. queue
**         size = 1 and cannot be modified). Size of queue can be
**         defined for each endpoint at the design time. Data from the
**         HOST are stored into the provided buffer. If the transfer is
**         done the request is removed from the queue and next request
**         becomes ready for transmission, if queue not empty.
**         Each transfer is described by the <transfer descriptor (TD)>
**         structure.
**         The first item of the TD is the <Head> structure. The Head
**         structure item is required and contains these items:
**         _/[EpNum]/_ - endpoint number.
**         _/[BufferPtr]/_ - buffer address.
**         _/[BufferSize]/_ - buffer size.
**         _/[Flags]/_ - flags:
**         _/LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM/_ - see below.
**         The following items of the TD are optional:
**         _/[TransmittedDataSize]/_ - this item is set by the driver
**         and contains actual number of transmitted data.
**         _/[CallbackFnPtr]/_ - pointer to the callback function
**         called (if not NULL) after the transfer is done.
**         _/[ParamPtr]/_ - parameter passed to the callback function.
**         The optional items can be used to track the status of the
**         transfer request and are used(accessed) by the driver only
**         if <LDD_USB_DEVICE_TRANSFER_FLAG_EXT_PARAM> flag is set to
**         '1' in the Head.Flags item. In this case the TD must be
**         accessible from the ISR and may be freed only if the
**         transfer is done (TransfereState item must be lower then
**         LDD_USB_TRANSFER_QUEUED). Pending transfer requests can be
**         cancelled by the <DeviceCancelTransfer()> method.
**         Transfer is done if all requested data are received or
**         short(zero length) packet is received. Note: On some MCUs (e.
**         g. Kinetis) must be the address of the data buffer 4 bytes
**         aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * TransferDescriptorPtr -
**                           Pointer to the <transfer descriptor (TD)>
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_QFULL - Endpoint transfer queue is full.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceRecvData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Device_TTD *TransferDescriptorPtr)
{
  return(USB_LDD_DeviceQueueTransfer((USB_LDD_TDeviceData*)DeviceDataPtr, TransferDescriptorPtr, LDD_USB_DIR_OUT));
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceGetTransferStatus (component USB_LDD)
**
**     Description :
**         This method returns current status of the endpoint. If
**         endpoint is idle/busy/stalled, the
**         ERR_IDLE/ERR_BUSY/ERR_FAILED is return. Please note that
**         these error codes reports endpoint status, not error of the
**         method.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EpNum           - Endpoint number.
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
**                           ERR_NOTAVAIL - Endpoint is not <initialized>.
**                           ERR_FAILED - Endpoint is STALLed.
**                           ERR_BUSY - Endpoint transfer is
**                           transmitting data.
**                           ERR_IDLE - Endpoint is idle.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceGetTransferStatus(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  if (EpDataPtr->EpState >= USB_LDD_EP_IDLE) {
    if (EpDataPtr->pCurrentTD->Active) {
      Res = ERR_BUSY;                                      /* Endpoint is busy */
    } else {
      Res = ERR_IDLE;                                      /* Endpoint is idle */
    }
  } else if ((uint32_t)EpDataPtr->EpState & (uint32_t)USB_LDD_EP_STALLED) {
    Res = ERR_FAILED;                                      /* Endpoint is stalled */
  } else {
    Res = ERR_NOTAVAIL;                                    /* Endpoint is disabled */
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceCancelTransfer (component USB_LDD)
**
**     Description :
**         Cancels all pending transfers in the given EP queue.
**         Transfer status is updated and callback function is called
**         for each cancelled transfer request if enabled in the
**         <SendData> or <RecvData> methods.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         EpNum           - Endpoint number.
**         EpDir           - Endpoint direction, 0 = OUT(Rx), 1 for
**                           IN(Tx).
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_USB_DEVICE_XXX where XXX is name of the
**                           state - Device is not in enabled <state>.
**                           ERR_PARAM_ADDRESS - Endpoint of requested
**                           address and direction is not supported by
**                           the driver.
** ===================================================================
*/
LDD_TError USB_LDD_DeviceCancelTransfer(LDD_TDeviceData *DeviceDataPtr, uint8_t EpNum, uint8_t EpDir)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_TError                       Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->DeviceState != LDD_USB_DEVICE_ENABLED) {
    Res = (LDD_TError)DevDataPtr->DeviceState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  EpDataPtr = &DevDataPtr->EpData[((uint32_t)EpNum << 0x01U)]; /* Get address of EPx OUT data structure */
  if (EpDir != LDD_USB_DIR_OUT) {                          /* EPx IN is next item in the array */
    EpDataPtr++;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((uint32_t)EpDataPtr > (uint32_t)&DevDataPtr->EpData[MAX_EP_IDX + 0x01u]) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (EpDataPtr->EpState == USB_LDD_EP_NOT_AVAILABLE) {
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_PARAM_ADDRESS;
  }
  Res = USB_LDD_DeviceAbortAllTransfers(DevDataPtr, EpDataPtr);
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetPortState (component USB_LDD)
**
**     Description :
**         Returns port <state>.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Returned value:
**                           LDD_USB_HOST_DISABLED - Host mode is
**                           disabled (by the user or by the clock
**                           configuration).
**                           LDD_USB_HOST_DISABLED_BY_OTG - Host mode is
**                           disabled by the OTG driver.
**                           LDD_USB_HOST_PORT_POWERED_OFF - Port is
**                           powered-off.
**                           LDD_USB_HOST_PORT_DISCONNECTED -  No device
**                           is connected.
**                           LDD_USB_HOST_PORT_DISABLED - Device is
**                           connected to the port.
**                           LDD_USB_HOST_PORT_RESETING - Port generates
**                           reset signaling.
**                           LDD_USB_HOST_PORT_RESET_RECOVERING - Port
**                           waits 10 ms for reset recovery.
**                           LDD_USB_HOST_PORT_ENABLED - Device is
**                           connected, reset and ready to use.
**                           LDD_USB_HOST_PORT_SUSPENDED - Port is
**                           suspended.
**                           LDD_USB_HOST_PORT_RESUME_READY - Port is
**                           ready to generate resume signaling.
**                           LDD_USB_HOST_PORT_RESUMING - Port generates
**                           resume signaling.
**                           LDD_USB_HOST_PORT_RESUME_RECOVERING - Port
**                           waits 10 ms for resume recovery.
** ===================================================================
*/
LDD_USB_Host_TState USB_LDD_HostGetPortState(LDD_TDeviceData *DeviceDataPtr)
{
  return (((USB_LDD_TDeviceData*)DeviceDataPtr)->HostState);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSetPortState (component USB_LDD)
**
**     Description :
**         This method sets root port (bus) states. Supported commands
**         are:
**         [LDD_USB_HOST_PORT_CMD_POWER_OFF]
**         Deactivates VBUS enable signal and sets the port to the
**         POWER_OFF state, closes all pipes and discards all pending
**         transfers.
**         [LDD_USB_HOST_PORT_CMD_POWER_ON]
**         Activates VBUS enable signal and sets the port to the
**         DISCONNECTED state.
**         Port must be in the POWERED_OFF state to be power on.
**         [LDD_USB_HOST_PORT_CMD_RESET]
**         Sets the port to the RESETING state, starts the reset
**         signaling and closes all pipes and discards all pending
**         transfers. As soon as the reset interval is elapsed the
**         reset signaling will be stopped, the port state will be
**         change to the RESET_RECOVERING, and the reset recovery
**         interval will begin. After the reset recovery interval is
**         elapsed, the port state will be changed to the ENABLED state.
**         In the ENABLED state the port can used to transfer data.
**         Device must be connected (ports state > DISCONNECTED) before
**         reset can be started.
**         [LDD_USB_HOST_PORT_CMD_DISABLE]
**         Sets the port to the DISABLED state and closes all pipes and
**         discards all pending transfers. This state can be changed
**         only by performing the bus reset(transfer to the ENABLED
**         state), by disconnecting the device (transfer to the
**         DISCONNECT state) or by the powering-off the bus (transfer
**         to the POWERED_OFF state).
**         [LDD_USB_HOST_PORT_CMD_SUSPEND]
**         Suspends port (state = SUSPENDED). No transaction should be
**         pending before this method is called.
**         Port must be in the LDD_USB_HOST_PORT_ENABLED state to be
**         suspend.
**         [LDD_USB_HOST_PORT_CMD_RESUME]
**         Sets the port to the RESUMING state and starts the resume
**         signaling. After the resume interval is elapsed, the port
**         state will be changed to the ENABLED state. In the ENABLED
**         state the port can used to transfer data.
**         Port must be in the LDD_USB_HOST_PORT_RESUME_READY state
**         before resume can start.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         Cmd             - Command
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Requested operation cannot be is
**                           done in current <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostSetPortState(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPortControlCmd Cmd)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res = (LDD_TError)DevDataPtr->HostState;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if ((uint32_t)DevDataPtr->HostState < (uint32_t)LDD_USB_HOST_PORT_POWERED_OFF) { /* */
    Res = (LDD_TError)DevDataPtr->HostState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }

  if (DevDataPtr->HostState >= LDD_USB_HOST_PORT_POWERED_OFF) { /* Is host enabled? */
    switch (Cmd) {
      case LDD_USB_HOST_PORT_CMD_RESET:
        /* See description of the HostResetPort() method */
        if (DevDataPtr->HostState > LDD_USB_HOST_PORT_DISCONNECTED) { /* Is a device connected? */
          USB_LDD_HostResetPort(DevDataPtr);               /* Yes, start reset signaling */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_DISABLE:
        /* See description of the DisablePort() method */
        USB_LDD_HostDisabledPort(DevDataPtr);              /* Disable port */
        Res = ERR_OK;
        break;
      case LDD_USB_HOST_PORT_CMD_SUSPEND:
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_ENABLED) { /* Is a device enabled? */
          /* See description of the HostResumePort() method */
          USB_LDD_HostSuspendPort(DevDataPtr);             /* Yes, suspend device */
          Res = ERR_OK;
        }
        break;
      case LDD_USB_HOST_PORT_CMD_RESUME:
        if (DevDataPtr->HostState == LDD_USB_HOST_PORT_RESUME_READY) { /* Is the device suspended at least 3 ms? */
          /* See description of the HostResumePort() method */
          USB_LDD_HostResumePort(DevDataPtr);              /* Yes, start resume signaling */
          Res = ERR_OK;
        }
        break;
      default:
        Res = ERR_PARAM_COMMAND;                           /* Unknown command */
        break;
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return(Res);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetFrameNumber (component USB_LDD)
**
**     Description :
**         This method returns current frame number.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Frame number.
** ===================================================================
*/
uint16_t USB_LDD_HostGetFrameNumber(LDD_TDeviceData *DeviceDataPtr)
{
  uint32_t                         FrameNumber;

  (void)DeviceDataPtr;                                     /* Parameter is not used, suppress unused argument warning */
  FrameNumber = ((uint32_t)(USB_PDD_GetFrameNumberHigh(USB0_BASE_PTR)) << 0x08); /* Get current frame number */
  FrameNumber |= (uint32_t)(USB_PDD_GetFrameNumberLow(USB0_BASE_PTR));
  return ((uint16_t)FrameNumber);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetMicroFrameNumber (component USB_LDD)
**
**     Description :
**         This method returns current microframe number.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     Returns     :
**         ---             - Microframe number.
** ===================================================================
*/
uint8_t USB_LDD_HostGetMicroFrameNumber(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr;                                     /* Parameter is not used, suppress unused argument warning */
  /* Not implemented for FULL speed */
  return 0x00U;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostOpenPipe (component USB_LDD)
**
**     Description :
**         Initializes pipe according to the values in the endpoint
**         descriptor and in the flags parameter. Allocate bandwidth
**         for periodic transfer types.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeInitParamsPtr - Pointer to the
**                           structure containing pipe configuration
**                           data.
**       * PipeHandlePtr   - Pointer to pipe handle
**                           variable.
**     Returns     :
**         ---             - Return value:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_PARAM_ID - Requested transfer is not
**                           supported by the HW .
**                           ERR_OVERFLOW - Not enough frame time for
**                           periodic transfer type.
**                           ERR_OK - OK
** ===================================================================
*/
LDD_TError USB_LDD_HostOpenPipe(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeInitParamsPtr, LDD_USB_Host_TPipeHandle **PipeHandlePtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr;
  LDD_TError                        Res = ERR_OVERFLOW;
  uint32_t                          x;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  *PipeHandlePtr = NULL;                                   /* Suppose bad params */
  USB_LDD_UsbLock(DevDataPtr);
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) {
    Res = (LDD_TError)DevDataPtr->HostState;
  } else {
    if (((uint32_t)PipeInitParamsPtr->TransferType & 1U)) { /* Periodic pipe? */
      if ((DevDataPtr->PerTrFrameSize + PipeInitParamsPtr->MaxPacketSize) > 9600U) { /* More then 80% of the frame time? */
        USB_LDD_UsbUnlock(DevDataPtr);
        Res = ERR_OVERFLOW;
      } else {
        DevDataPtr->PerTrFrameSize += PipeInitParamsPtr->MaxPacketSize; /* Update per. transfer frame size */
      }
    }
    if (DevDataPtr->BusSpeed == LDD_USB_FULL_SPEED) {      /* Compute SOF threshold */
      x = ((((0x65U + ((uint32_t)PipeInitParamsPtr->MaxPacketSize * 0x08U)) * 0x07U) / 0x06U) / 0x08U);
    } else {
      x = (((0x65U + ((uint32_t)PipeInitParamsPtr->MaxPacketSize * 0x08U)) * 0x07U) / 0x06U);
    }
    if (DevDataPtr->SofThresholdValue < x) {
      DevDataPtr->SofThresholdValue = (uint8_t)x;
      USB_PDD_SetSofTresholdReg(USB0_BASE_PTR, DevDataPtr->SofThresholdValue);
    }
    for (x = 0x00U; x < MAX_PIPES; x++) {                  /* Try to find free pipe descriptor */
      PipePtr = &DevDataPtr->PDT[x];
      if (PipePtr->PipeState == USB_LDD_PIPE_CLOSED) {     /* Free descriptor? */
        Res = ERR_OK;                                      /* Stop the loop */
        break;
      }
    }
    if (Res == ERR_OK) {                                   /* Empty pipe descriptor found? */
      switch (PipeInitParamsPtr->TransferType) {
        case LDD_USB_CONTROL:                              /* Control pipe? */
          /* Add the pipe to the begin of the async. pipe list */
          if (DevDataPtr->AsyncPipeListTailPtr == NULL) {  /* Async. list empty? */
            DevDataPtr->AsyncPipeListTailPtr = PipePtr;    /* The new pipe is also last pipe in the list */
          }
          PipePtr->NextPipePtr = DevDataPtr->AsyncPipeListHeadPtr; /* Add the pipe to the begin of the async. pipe list */
          DevDataPtr->AsyncPipeListHeadPtr = PipePtr;      /* Update head list address */
          PipePtr->EpCtrlRegVal = 0x4DU;                   /* Remember value for EP control register */
          break;
        case LDD_USB_BULK:                                 /* Interrupt pipe? */
          /* Add the pipe to the end of the async. pipe list */
          if (DevDataPtr->AsyncPipeListTailPtr == NULL) {  /* Async. list empty? */
            DevDataPtr->AsyncPipeListHeadPtr = PipePtr;    /* The new pipe is also first pipe in the list */
          } else {
            DevDataPtr->AsyncPipeListTailPtr->NextPipePtr = PipePtr;
          }
          DevDataPtr->AsyncPipeListTailPtr = PipePtr;      /* Update tail pointer */
          PipePtr->NextPipePtr = NULL;                     /* This is the last pipe in the list */
          PipePtr->EpCtrlRegVal = 0x5DU;                   /* Remember value for EP control register */
          break;
        case LDD_USB_INTERRUPT:                            /* Interrupt pipe? */
          /* Add the pipe to the begin of the periodic pipe list */
          PipePtr->NextPipePtr = DevDataPtr->PeriodicPipeListHeadPtr; /* Add the pipe to the begin of the pipe list */
          DevDataPtr->PeriodicPipeListHeadPtr = PipePtr;   /* Update head list address */
          PipePtr->EpCtrlRegVal = 0x5DU;                   /* Remember value for EP control register */
          break;
        default:
          Res = ERR_PARAM_ID;
          break;
      }
      if (Res == ERR_OK) {                                 /* Empty pipe descriptor found? */
        PipePtr->Head = *PipeInitParamsPtr;                /* Yes, copy pipe setting */
        PipePtr->PipeState = USB_LDD_PIPE_IDLE;            /* Set pipe state */
        PipePtr->ActiveTrPtr = NULL;                       /* Initialize Activ transfer pointer */
        PipePtr->LastTrPtr = NULL;                         /* Initialize Last transfer pointer */
        *PipeHandlePtr = PipePtr;                          /* Set pipe local data address as handle */
        PipePtr->NextData01 = (uint8_t)0x00U;              /* Set DATA0 as default DATA PID */
        if (DevDataPtr->BusSpeed == LDD_USB_LOW_SPEED) {   /* Directly connected Low speed device(without hub)? */
          PipePtr->Head.DevAddress |= (uint8_t)0x80U;      /* Transaction to this EP must be performed all low-speed */
          PipePtr->EpCtrlRegVal |= (uint8_t)0x80U;         /* Disable PRE_PID */
        } else if (PipePtr->Head.DevSpeed == LDD_USB_LOW_SPEED) { /* Low speed device after a hub? */
          PipePtr->Head.DevAddress |= (uint8_t)0x80U;      /* Transaction to this EP must be performed all low-speed */
        } else {
        }
      }
    }
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostClosePipe (component USB_LDD)
**
**     Description :
**         Deinitializes EP and disables it in the HW. For control EP
**         both directions are deinitialized. All pending transfers are
**         aborted and callback functions are called, if enabled.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle
**     Returns     :
**         ---             - Return value:
**                           ERR_DISABLED - Device is disabled.
**                           ERR_OK - OK
** ===================================================================
*/
LDD_TError USB_LDD_HostClosePipe(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr = (USB_LDD_TPipeDescr*)PipeHandlePtr;
  USB_LDD_TPipeDescr               *LeftPipePtr,*tmpPipePtr;
  uint32_t                          x;
  LDD_TError                        Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  if ((uint32_t)DevDataPtr->HostState < (uint32_t)LDD_USB_HOST_PORT_POWERED_OFF) { /* */
    Res = (LDD_TError)DevDataPtr->HostState;
    USB_LDD_UsbUnlock(DevDataPtr);
    return Res;
  }
  LeftPipePtr = NULL;
  for (x = 0x00U; x < MAX_PIPES; x++) { /* Find ascendant pipe */
    tmpPipePtr = &DevDataPtr->PDT[x];
    if (tmpPipePtr->NextPipePtr == PipePtr) { /* Ascendant pipe found? */
      tmpPipePtr->NextPipePtr = PipePtr->NextPipePtr; /* Update its' pointer to the next item */
      LeftPipePtr = tmpPipePtr;
      break;
    }
  }
  if (DevDataPtr->AsyncPipeListHeadPtr == PipePtr) { /* Is the pipe on the head of async. pipe list */
    DevDataPtr->AsyncPipeListHeadPtr = PipePtr->NextPipePtr; /* remove it from the list head */
  }
  if (DevDataPtr->AsyncPipeListTailPtr == PipePtr) {
    DevDataPtr->AsyncPipeListTailPtr = LeftPipePtr;
  }
  if (DevDataPtr->PeriodicPipeListHeadPtr == PipePtr) {
    DevDataPtr->PeriodicPipeListHeadPtr = PipePtr->NextPipePtr;
    DevDataPtr->PerTrFrameSize -= (uint32_t)PipePtr->Head.MaxPacketSize;
  }

  PipePtr->PipeState = USB_LDD_PIPE_CLOSED; /* Set pipe state */
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSendSetup (component USB_LDD)
**
**     Description :
**         This method prepares control transfer. All transfer phases
**         are handled by this method.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle.
**       * TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**       * TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe descriptor pointer is NULL.
**                           ERR_PARAM_DATA - Pointer to the Setup data
**                           packet is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostSendSetup(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_UNKNOWN);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostSendData (component USB_LDD)
**
**     Description :
**         This method prepares data to be sent to the device.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle.
**       * TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**       * TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostSendData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_OUT);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostRecvData (component USB_LDD)
**
**     Description :
**         This method prepares buffer for data sent by the device.
**         Note: On some MCUs (e.g. Kinetis) must be the address of the
**         data buffer 4 bytes aligned.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle.
**       * TransferDescriptorPtr -
**                           Pointer to transfer descriptor.
**       * TransferHandlePtr - Pointer to
**                           transfer handle variable.
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostRecvData(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeHandle *PipeHandlePtr, LDD_USB_Host_TTD *TransferDescriptorPtr, LDD_USB_Host_TTransferHandle **TransferHandlePtr)
{
  return HostQueueTransfer(DeviceDataPtr, PipeHandlePtr, TransferDescriptorPtr, TransferHandlePtr, LDD_USB_DIR_IN);
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetTransferStatus (component USB_LDD)
**
**     Description :
**         This method returns transfer status.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * TransferHandlePtr - Pointer to
**                           transfer handle return by Send/Recv methods
**                           in the 'TransferDescriptorPtr' variable.
**     Returns     :
**         ---             - Transfer status.
** ===================================================================
*/
LDD_USB_TTransferState USB_LDD_HostGetTransferStatus(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TTransferHandle *TransferHandlePtr)
{
  (void)DeviceDataPtr;                                     /* Parameter is not used, suppress unused argument warning */
  return ((LDD_USB_TTransferState)((uint32_t)(((USB_LDD_TTrDescr*)TransferHandlePtr)->TrState) & 0x3FU));
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostCancelTransfer (component USB_LDD)
**
**     Description :
**         This method cancels all pending transfer requests in the
**         given EP queue. Callback function is called ( if enabled)
**         for each cancelled transfer request.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * PipeHandlePtr   - Pipe handle
**     Returns     :
**         ---             - Return value: ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_ADDRESS - Transfer descriptor
**                           pointer or Pipe handle is NULL.
**                           ERR_FAILED - Pipe is closed.
**                           ERR_USB_HOST_XXX where XXX is name of the
**                           state - Port is not in enabled <state>.
** ===================================================================
*/
LDD_TError USB_LDD_HostCancelTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Host_TPipeDescr *PipeHandlePtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  USB_LDD_TPipeDescr               *PipePtr = (USB_LDD_TPipeDescr*)PipeHandlePtr;
  USB_LDD_TTrDescr                 *TrPtr;
  LDD_TError                        Res;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  /* Input parameter test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (PipePtr == NULL) {
    return ERR_PARAM_ADDRESS;
  }
  USB_LDD_UsbLock(DeviceDataPtr);
  if (PipePtr->PipeState == USB_LDD_PIPE_CLOSED) {         /* Pipe closed? */
    USB_LDD_UsbUnlock(DevDataPtr);
    return ERR_FAILED;                                     /* Yes, return with error */
  }
  if (DevDataPtr->HostState != LDD_USB_HOST_PORT_ENABLED) { /* Port enabled? */
    Res = (LDD_TError)DevDataPtr->HostState;               /* Yes, return with error */
  } else {
    TrPtr = PipePtr->ActiveTrPtr;
    while (TrPtr != NULL) {
      if (TrPtr->TrState >= USB_LDD_TRANSFER_QUEUED) {     /* Pending transfer? */
        TrPtr->TrState = USB_LDD_TRANSFER_ERROR_CANCELLED; /* Call callback */
        if (TrPtr->Head.CallbackFnPtr != NULL) {
          TrPtr->Head.CallbackFnPtr(DevDataPtr->UserHostDataPtr, TrPtr->Head.BufferPtr, TrPtr->Head.BufferSize, TrPtr->Head.ParamPtr, LDD_USB_TRANSFER_ERROR_CANCELLED);
        }
      }
      TrPtr = TrPtr->NextTrPtr;                            /* Get next transfer descriptor */
    }
    PipePtr->ActiveTrPtr = NULL;
    Res = ERR_OK;                                          /* return with error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_OtgRegisterDevice (component USB_LDD)
**
**     Description :
**         Registers higher level driver for Device mode. As soon as
**         the Device mode is enabled by the OTG state machine the
**         OnDeviceXXX() events will be called. The UserDataPtr value
**         will be passed as the first parameter of the OnDeviceXXX()
**         event.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter to
**                           all OnDeviceXXX events.
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
** ===================================================================
*/
LDD_TError USB_LDD_OtgRegisterDevice(LDD_TDeviceData *DeviceDataPtr, LDD_TUserData *UserDataPtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  DevDataPtr->UserDeviceDataPtr = UserDataPtr;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_OtgRegisterHost (component USB_LDD)
**
**     Description :
**         Registers higher level driver for Host mode. As soon as the
**         host mode is enabled by the OTG state machine the OnHostXXX()
**         events will be called. The UserDataPtr value will be passed
**         as the first parameter of the OnHostXXX() event.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**       * UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter to
**                           all OnHostXXX events.
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
** ===================================================================
*/
LDD_TError USB_LDD_OtgRegisterHost(LDD_TDeviceData *DeviceDataPtr, LDD_TUserData *UserDataPtr)
{
  USB_LDD_TDeviceData              *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;

  DevDataPtr->UserHostDataPtr = UserDataPtr;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_OtgCmd (component USB_LDD)
**
**     Description :
**         This method sets "bus request" and "bus drop" user signal
**         states. For more information see OTG specification.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         Cmd             - Command
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_SPEED - The component does not work in
**                           the active clock configuration.
**                           ERR_DISABLED - The component is disabled.
**                           ERR_PARAM_COMMAND - Unknown command.
** ===================================================================
*/
LDD_TError USB_LDD_OtgCmd(LDD_TDeviceData *DeviceDataPtr, LDD_USB_Otg_TCmd Cmd)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  LDD_TError                       Res = ERR_OK;
  uint32_t                         NewInSignalsState;

  /* Enable test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!DevDataPtr->EnUser) {           /* Is the device disabled by user? */
    return ERR_DISABLED;               /* If yes then error */
  }
  USB_LDD_UsbLock(DevDataPtr);
  NewInSignalsState = DevDataPtr->InSignalsState;
  switch (Cmd) {
    case LDD_USB_OTG_CMD_SET_A_BUS_REQUEST:
      NewInSignalsState |= USB_LDD_OTG_A_BUS_REQ;
      break;
    case LDD_USB_OTG_CMD_CLR_A_BUS_REQUEST:
      NewInSignalsState &= ~(uint32_t)USB_LDD_OTG_A_BUS_REQ;
      break;
    case LDD_USB_OTG_CMD_SET_B_BUS_REQUEST:
      NewInSignalsState |= USB_LDD_OTG_B_BUS_REQ;
      break;
    case LDD_USB_OTG_CMD_CLR_B_BUS_REQUEST:
      NewInSignalsState &= ~(uint32_t)USB_LDD_OTG_B_BUS_REQ;
      break;
    case LDD_USB_OTG_CMD_SET_A_BUS_DROP:
      NewInSignalsState = (NewInSignalsState & ~(uint32_t)USB_LDD_OTG_A_BUS_REQ) | USB_LDD_OTG_A_BUS_DROP;
      break;
    case LDD_USB_OTG_CMD_CLR_A_BUS_DROP:
      NewInSignalsState &= ~(uint32_t)USB_LDD_OTG_A_BUS_DROP;
      break;
    case LDD_USB_OTG_CMD_CLR_A_SUSPEND_REQUEST:
      NewInSignalsState &= ~(uint32_t)USB_LDD_OTG_A_SUSPEND_REQ;
      break;
    case LDD_USB_OTG_CMD_SET_A_SUSPEND_REQUEST:
      NewInSignalsState |= USB_LDD_OTG_A_SUSPEND_REQ;
      break;
    default:
      Res = ERR_PARAM_COMMAND;                             /* Unknown command */
      break;
  }
  if (DevDataPtr->InSignalsState != NewInSignalsState) {   /* Signal changed? */
    DevDataPtr->InSignalsState = NewInSignalsState;        /* Yes, remember new signal state */
    USB_LDD_OtgStateMachine(DevDataPtr);                   /* Call state machine */
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return Res;
}

/*
** ===================================================================
**     Method      :  USB_LDD_SetSignal (component USB_LDD)
**
**     Description :
**         This method sets input signals  (VBUS detect, VBUS
**         overcurrent, ID, VBUS valid, Session valid, B session end)
**         states. 
**         The state machine use input signal to change its internal
**         state. In some implementations the signals are handled
**         internally (e.g. voltage comparators are integrated on the
**         chip) or are connected to the pin. This method can be used
**         in the case of external HW providing signals state.
**         Read only - This method is enabled only if at least one
**         "input pin" property (e.g. VBUS detect) selects "XXX_signal"
**         value and is disabled if no signal is used.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**         SignalMask      - Mask of signal to change.
**                           Possible values:
**                           LDD_USB_DEVICE_VBUS_DETECT_PIN - VBUS
**                           detect signal mask
**                           LDD_USB_HOST_VBUS_OVERCURRENT_PIN - VBUS
**                           overcurrent signal mask
**                           LDD_USB_OTG_ID_PIN - ID signal mask
**                           LDD_USB_OTG_VBUS_VALID_PIN - VBUS valid
**                           signal mask
**                           LDD_USB_OTG_SESSION_VALID_PIN - SESSION
**                           valid signal mask
**                           LDD_USB_OTG_B_SESSION_END_PIN - B SESSION
**                           end signal mask
**         SignalValue     - Requested signal value.
**     Returns     :
**         ---             - Return value:
**                           ERR_OK - OK
**                           ERR_PARAM_MASK - Signal mask is not valid.
**                           (signal is not selected in the pin
**                           configuration)
** ===================================================================
*/
LDD_TError USB_LDD_SetSignal(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask SignalMask, LDD_TPinMask SignalValue)
{
  USB_LDD_TDeviceData             *DevDataPtr = (USB_LDD_TDeviceData*)DeviceDataPtr;
  uint32_t                         NewSignalState;
  uint32_t                         NewSignalStateMask;

  /* Pin mask test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if ((SignalMask & ((LDD_TPinMask)~USB_LDD_AVAILABLE_IN_SIGNALS_MASK)) != 0x00U) {
    return ERR_PARAM_MASK;
  }
  USB_LDD_UsbLock(DevDataPtr);
  NewSignalState = 0x00U;                                  /* Initialize signal state variable */
  NewSignalStateMask = 0x00U;                              /* Initialize signal mask variable */
  if ((SignalMask & LDD_USB_OTG_ID_PIN) != 0x00U) {        /* Request to set OTG_ID signal? */
    NewSignalStateMask |= USB_LDD_OTG_ID;                  /* Update signal mask variable */
    if ((SignalValue & LDD_USB_OTG_ID_PIN) != 0x00U) {     /* Activate signal? */
      NewSignalState |= USB_LDD_OTG_ID;                    /* Update signal state variable */
    }
  }
  if ((SignalMask & LDD_USB_OTG_VBUS_VALID_PIN) != 0x00U) { /* Request to set OTG_VBUS_VALID signal? */
    NewSignalStateMask |= USB_LDD_OTG_VBUS_VALID;          /* Update signal mask variable */
    if ((SignalValue & LDD_USB_OTG_VBUS_VALID_PIN) != 0x00U) { /* Activate signal? */
      NewSignalState |= USB_LDD_OTG_VBUS_VALID;            /* Update signal state variable */
    }
  }
  if ((SignalMask & LDD_USB_OTG_SESSION_VALID_PIN) != 0x00U) { /* Request to set OTG_SESSION_VALID signal? */
    NewSignalStateMask |= USB_LDD_OTG_SESSION_VALID;       /* Update signal mask variable */
    if ((SignalValue & LDD_USB_OTG_SESSION_VALID_PIN) != 0x00U) { /* Activate signal? */
      NewSignalState |= USB_LDD_OTG_SESSION_VALID;         /* Update signal state variable */
    }
  }
  if ((SignalMask & LDD_USB_OTG_B_SESSION_END_PIN) != 0x00U) { /* Request to set OTG_B_SESSION_END signal? */
    NewSignalStateMask |= USB_LDD_OTG_B_SESSION_END;       /* Update signal mask variable */
    if ((SignalValue & LDD_USB_OTG_B_SESSION_END_PIN) != 0x00U) { /* Activate signal? */
      NewSignalState |= USB_LDD_OTG_B_SESSION_END;         /* Update signal state variable */
    }
  }
  NewSignalState = (DevDataPtr->InSignalsState & ~NewSignalStateMask) | NewSignalState;
  if (DevDataPtr->InSignalsState != NewSignalState) {
    DevDataPtr->InSignalsState = NewSignalState;
    USB_LDD_OtgStateMachine(DevDataPtr);
  }
  USB_LDD_UsbUnlock(DevDataPtr);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  USB_LDD_DeviceIsr (component USB_LDD)
**
**     Description :
**         Device mode interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_DeviceIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t InSignalsState)
{
  uint32_t                         IntStatus;
  uint32_t                         BDCtrlReg;
  uint16_t                         DataSize;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TEpData                 *EpDataPtr;
  LDD_USB_TSDP                    *SDPPtr;

  if (DevDataPtr->DeviceState >= LDD_USB_DEVICE_VBUS_OFF) { /* Device enabled and VBUS = ON? */
    if ((InSignalsState & USB_LDD_TIMEOUT) != 0x00U) {      /* Timeout? */
      switch (DevDataPtr->DeviceState) {
        case LDD_USB_DEVICE_SUSPENDED:
          /* At this time the BUS is IDLE for at least 5ms and */
          /* device can generate wake-up signaling (if enabled by the Host) */
          DevDataPtr->DeviceState = LDD_USB_DEVICE_SUSPENDED_RESUME_READY; /* Remember new port state */
          break;
        case LDD_USB_DEVICE_SUSPENDED_RESUME_READY:
          USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE);
          DevDataPtr->DeviceState = LDD_USB_DEVICE_ENABLED; /* Remember new port state */
          break;
        default:
          break;
      }
    }
    IntStatus = USB_PDD_GetUsbInterruptFlags(USB0_BASE_PTR);
    IntStatus &= USB_PDD_GetUsbInterruptMask(USB0_BASE_PTR);
    if (IntStatus == 0U) {
      return;
    }
    /* USB module error interrupt handler */
    if ((IntStatus & USB_PDD_ERROR_INT) != 0x00U) {         /* USB error detected? */
      USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, 0xFFU); /* Clear error flags */
      USB_PDD_ClearErrorInterruptFlag(USB0_BASE_PTR);       /* Clear "error" interrupt flag */
      if (DevDataPtr->EventMask & LDD_USB_ON_DEVICE_ERROR) {
        USB_LDD_OnDeviceError(DevDataPtr->UserDeviceDataPtr, 0u, USB_PDD_GetErrorsInterruptFlags(USB0_BASE_PTR));
      }
    }
    if ((IntStatus & USB_PDD_TOK_DNE_INT) != 0x00U) {
      /* TOKE_DONE interrupt detected */
      EpDataPtr = &DevDataPtr->EpData[((uint32_t)(USB_PDD_ReadStatusReg(USB0_BASE_PTR))) >> 0x03];
      BDPtr = &DevDataPtr->BDT[((uint32_t)(USB_PDD_ReadStatusReg(USB0_BASE_PTR))) >> 0x02];
      EpDataPtr->LastTrBDPtr = BDPtr;
      BDCtrlReg = BDPtr->CtrlReg;
      DataSize = (uint16_t)(((uint32_t)BDCtrlReg >> 0x10U) & 0x03FFU);
      SDPPtr = (LDD_USB_TSDP*)BDPtr->BufferPtr;
      if (USB_PDD_GetTransmitIndicator(USB0_BASE_PTR)) {    /* Tx done? */
        USB_LDD_DeviceDataPacketDone(DevDataPtr, EpDataPtr, DataSize);
      } else {                                              /* Rx done */
        if ((BDCtrlReg & USB_LDD_BD_PID_MASK) == ((uint32_t)LDD_USB_PID_SETUP << 0x02)) { /* Setup packet? */
          (void)USB_LDD_DeviceAbortAllTransfers(DevDataPtr,EpDataPtr); /* New setup command, discard all pending transactions */
          (void)USB_LDD_DeviceAbortAllTransfers(DevDataPtr,EpDataPtr + 1U); /* New setup command, discard all pending transactions */
          EpDataPtr->BDCtrlRegVal |= USB_LDD_BD_DATA1;      /* The next transaction must be always IN/OUT DATA1 */
          (EpDataPtr + 1)->BDCtrlRegVal |= USB_LDD_BD_DATA1;
          if (SDPPtr->wLength == 0x00U) {
            /* No-data control transfer */
            EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_NO_DATA; /* Rx - No data should be received */
            (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_NO_DATA_HSK; /* Tx - Handshake should be sent */
          } else if ((SDPPtr->bmRequestType & LDD_USB_DIR_IN) != 0x00U) {
            /* Control read */
            EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_READ_HSK; /* Rx - Handshake should be received */
            (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_READ_DATA; /* Tx - Data should be sent */
          } else {
            /* Control write */
            EpDataPtr->TT.Ctrl.Stage=USB_LDD_CONTROL_WRITE_DATA; /* Rx - Data should be received */
            (EpDataPtr + 1U)->TT.Ctrl.Stage=USB_LDD_CONTROL_WRITE_HSK; /* Tx - Handshake should be sent */
          }
          if (DevDataPtr->EventMask & LDD_USB_ON_DEVICE_SETUP_PACKET) {
            USB_LDD_OnDeviceSetupPacket(DevDataPtr->UserDeviceDataPtr,  (uint8_t)EpDataPtr->EpNumber);
          }
        } else {                                            /* Data packet */
          USB_LDD_DeviceDataPacketDone(DevDataPtr, EpDataPtr, DataSize);
        }
      }
      USB_PDD_ClearTokenDoneInterruptFlag(USB0_BASE_PTR);   /* Clear "token done" interrupt flag */
    } else {
      /* Some special interrupt detected and no token done is pending */
      if ((IntStatus & USB_PDD_USB_RST_INT) != 0x00U) {     /* USB Reset Signal detected? */
      /* USB Reset signal detected interrupt handler */
        /* Disable SW and HW access to all Endpoints */
        USB_LDD_DeviceDisableAllEp(DevDataPtr);
        USB_PDD_ClearBusResetInterruptFlag(USB0_BASE_PTR);  /* Clear "reset" interrupt flag */
        USB_PDD_WriteAddressReg(USB0_BASE_PTR, 0x00U);      /* Set device address to the 0 value */
        USB_PDD_ResetBdtPingPong(USB0_BASE_PTR);            /* Reset internal engine state */
        USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop wake-up signaling (if enabled) */
        if (USB_PDD_GetDpPullUpSignalState(USB0_BASE_PTR)) { /* VBUS on? */
          USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, USB_PDD_USB_RST_INT | USB_PDD_SLEEP_INT | USB_PDD_TOK_DNE_INT);
          DevDataPtr->DeviceState = LDD_USB_DEVICE_ENABLED; /* Remember new device state */
          if (DevDataPtr->EventMask & LDD_USB_ON_DEVICE_RESET) {
            USB_LDD_OnDeviceReset(DevDataPtr->UserDeviceDataPtr);
          }
          if (DevDataPtr->EventMask & LDD_USB_ON_DEVICE_SPEED_DETECT) {
            USB_LDD_OnDeviceSpeedDetect(DevDataPtr->UserDeviceDataPtr, LDD_USB_FULL_SPEED);
          }
          USB_LDD_DeviceReceiveSetupPacket(&DevDataPtr->EpData[0x00u]);
        } else {
          DevDataPtr->DeviceState = LDD_USB_DEVICE_VBUS_OFF;
        }
      } else if ((IntStatus & USB_PDD_RESUME_INT) != 0x00U) { /* Resume signaling detected? */
      /* Resume signal detected interrupt handler */
        USB_PDD_DisableResumeInterrupt(USB0_BASE_PTR);      /* Disable "resume" interrupt */
        USB_PDD_ClearResumeInterruptFlag(USB0_BASE_PTR);    /* Clear "resume" interrupt flag */
        DevDataPtr->DeviceState = DevDataPtr->LastDeviceState; /* Return to the previous state */
        if (DevDataPtr->EventMask & LDD_USB_ON_DEVICE_RESUME) {
          USB_LDD_OnDeviceResume(DevDataPtr->UserDeviceDataPtr);
        }
      } else if ((IntStatus & USB_PDD_SLEEP_INT) != 0x00U) { /* Suspend detected (Idle more then 3 ms)? */
      /* Suspend detected interrupt handler */
        USB_PDD_ClearSuspendInterruptFlag(USB0_BASE_PTR);   /* Clear "suspend" interrupt flag */
        USB_PDD_ClearResumeInterruptFlag(USB0_BASE_PTR);    /* Clear "resume" interrupt flag */
        USB_PDD_EnableResumeInterrupt(USB0_BASE_PTR);       /* Enable "resume" interrupt */
        DevDataPtr->LastDeviceState = DevDataPtr->DeviceState; /* Remember current device state */
        DevDataPtr->DeviceState = LDD_USB_DEVICE_SUSPENDED; /* Set new device state state */
        DevDataPtr->msCounter = 3;                          /* Prepare to wait at 2 ms from IDLE before forcing resume */
        USB_PDD_Enable1msInterrupt(USB0_BASE_PTR);          /* Enable 1 ms interrupt */
        if (DevDataPtr->EventMask & LDD_USB_ON_DEVICE_SUSPEND) {
          USB_LDD_OnDeviceSuspend(DevDataPtr->UserDeviceDataPtr);
        }
      } else {
        ;
      }
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetPeriodicTransactionReadyPipe (component USB_LDD)
**
**     Description :
**         Returns pointer to the periodic pipe that has transaction 
**         ready for this frame.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static USB_LDD_TPipeDescr* USB_LDD_HostGetPeriodicTransactionReadyPipe(USB_LDD_TPipeDescr *PipePtr, uint32_t CurrentFrameNum)
{
  /* Find periodic pipe ready to start transaction in this frame */
  while (PipePtr != NULL) {                                /* Till the end of periodic list do: */
    if (PipePtr->ActiveTrPtr != NULL) {                    /* Transfer pending on selected pipe? */
      if (PipePtr->NextFrameNum <= CurrentFrameNum) {      /* Time to perform transaction? */
        PipePtr->NextFrameNum += (uint32_t)PipePtr->Head.Interval; /* Update next time */
        break;                                             /* Start transaction on the selected pipe */
      }
    }
    PipePtr = PipePtr->NextPipePtr;
  }
  return PipePtr;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostGetAsyncTransactionReadyPipe (component USB_LDD)
**
**     Description :
**         Returns pointer to the periodic pipe that has transaction 
**         ready for this frame.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static USB_LDD_TPipeDescr* USB_LDD_HostGetAsyncTransactionReadyPipe(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TPipeDescr *PipePtr)
{
  USB_LDD_TPipeDescr              *NextPipePtr;

  if (USB_PDD_GetTokenBusyFlag(USB0_BASE_PTR)) {
    return NULL;
  }

  if (PipePtr == NULL) {                                   /* Last pipe in the async. pipe list? */
    PipePtr = DevDataPtr->AsyncPipeListHeadPtr;            /* Yes, start from the begin of the async. list */
  }
  NextPipePtr = PipePtr;
  do {
    NextPipePtr = NextPipePtr->NextPipePtr;
    if (NextPipePtr == NULL) {                             /* Last pipe in the async. pipe list? */
      NextPipePtr = DevDataPtr->AsyncPipeListHeadPtr;      /* Yes, start from the begin of the async. list */
    }
    if (NextPipePtr == PipePtr) {                          /* Ready pipe found? */
      return NULL;                                         /* No, return NULL */
    }
    if (NextPipePtr->ActiveTrPtr != NULL) {                /* Transfer pending on selected pipe? */
      break;                                               /* Return address of this pipe */
    }
  } while (1);
  return NextPipePtr;
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostMainIsr (component USB_LDD)
**
**     Description :
**         Host mode main interrupt handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostMainIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t IntStatus, uint32_t Status, uint32_t ErrorStatus)
{
  uint32_t                         BDCtrlReg;
  uint16_t                         DataSize;
  USB_LDD_TBD                     *BDPtr;
  USB_LDD_TPipeDescr              *PipePtr;
  USB_LDD_TTrDescr                *TrPtr;
  uint32_t                         CurrentFrameNum;

  CurrentFrameNum = ((uint32_t)(USB_PDD_GetFrameNumberHigh(USB0_BASE_PTR)) << 0x08); /* Get current frame number */
  CurrentFrameNum |= (uint32_t)(USB_PDD_GetFrameNumberLow(USB0_BASE_PTR));
  if ((IntStatus & USB_PDD_TOK_DNE_INT) == 0x00U) {
    /* Some special interrupt detected */
    if ((IntStatus & USB_PDD_USB_RST_INT) != 0x00U) {       /* USB Deattach Signal detected? */
      /* (2,5us of SE0) */
      /* USB deattach signal detected interrupt handler */
      if ((IntStatus & USB_PDD_ATTACH_INT) == 0x00U) {
        /* Sets the port to the DISCONNECTED state and closes all pipes and discards all pending transfers. */
        /*  This state can be changed only by performing the bus reset(transfer to the ENABLED state), */
        /*  by the disconnecting the device (transfer to the DISCONNECT state) or by the powering-off */
        /* the bus (transfer to the POWERED_OFF state). */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_DISCONNECTED; /* Set new state */
        USB_PDD_EnableSof(USB0_BASE_PTR, PDD_DISABLE);      /* Disable SOF */
        USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
        USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE); /* This is necessary to correctly detect device speed */
        USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Clear "attach" interrupt flag */
        USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_ATTACH_INT); /* Enable only "attach" interrupt */
        USB_LDD_HostCloseAllPipesAndDiscardAlltransfers(DevDataPtr);
        if (DevDataPtr->EventMask & LDD_USB_ON_HOST_DEVICE_DEATTACH) {
          USB_LDD_OnHostDeviceDeattach(DevDataPtr->UserHostDataPtr);
        }
      } else {
      }
    } else if ((IntStatus & USB_PDD_ATTACH_INT) != 0x00U) { /* Attach signal detected? */
      /* Attach signal detected interrupt handler */
      /* (2,5 us without transition and bus state != SE0 */
      if (!USB_PDD_GetSE0(USB0_BASE_PTR)) {
        /* Enables port. Disables all USB interrupts except "deattach" interrupt */
        /* and starts 100 ms debounce interval. After this interval is done it */
        /* starts the reset signaling(50 ms). After reset signaling is done it */
        /* checks the connected device speed and adds 10ms of reset recovery. As */
        /* soon as the reset recovery interval is done the port state is changed */
        /* to the "ENABLED" state and port can be used to transmit data. Called */
        /* from ISR if the "connect" event is detected. */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_DISABLED; /* Set new port state */
        USB_PDD_SuspendTransceiver(USB0_BASE_PTR, PDD_DISABLE); /* Wake-up transceiver */
        USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Clear "deattach" interrupt flag */
        USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Enable only "deattach" interrupt */
        USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_DEBOUNCE_INTERVAL_MS + 1); /* Wait at least 100 ms before reseting the device */
      } else {
        ;
      }
    } else if ((IntStatus & USB_PDD_RESUME_INT) != 0x00U) { /* Resume received? */
      /* Resume signal interrupt handler */
      USB_LDD_HostResumePort(DevDataPtr);
    } else if ((IntStatus & USB_PDD_SOF_TOK_INT) != 0x00U) { /* SOF threshold? */
      /* SOF threshold interrupt handler */
      if (DevDataPtr->LastFrameNum > CurrentFrameNum) {    /* Frame counter overflow? */
        PipePtr = DevDataPtr->PeriodicPipeListHeadPtr;     /* Yes, update next frame number */
        while (PipePtr != NULL) {                          /* in all opened periodic pipes */
          PipePtr->NextFrameNum = PipePtr->NextFrameNum & (uint32_t)0x07FF;
          PipePtr = PipePtr->NextPipePtr;                  /* Get next pipe */
        }
      }
      DevDataPtr->LastFrameNum = CurrentFrameNum;          /* Remember current frame number */
      if (DevDataPtr->ActivePipePtr != NULL) {             /* Transaction in progress? */
        DevDataPtr->SofThresholdDetected = TRUE;           /* Yes, let the token done handler to select transaction from the periodic list */
      } else {                                             /* No, start transaction from here */
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetPeriodicTransactionReadyPipe(DevDataPtr->PeriodicPipeListHeadPtr, CurrentFrameNum);
        if (DevDataPtr->ActivePipePtr != NULL) {           /* Transaction ready? */
          USB_LDD_HostStartTransaction(DevDataPtr);        /* Start the transaction on selected pipe */
        }
      }
    } else {
      ;
    }
  } else {
    /* Only TOKE_DONE interrupt detected (no other interrupt signal active) */
    PipePtr = DevDataPtr->ActivePipePtr;
    DevDataPtr->ActivePipePtr = NULL;
    if ((uint32_t)PipePtr->Head.TransferType & (uint32_t)1U) { /* Periodic transaction done? */
      DevDataPtr->ActivePipePtr = USB_LDD_HostGetPeriodicTransactionReadyPipe(PipePtr->NextPipePtr, CurrentFrameNum); /* Find ready periodic transaction */
      if (DevDataPtr->ActivePipePtr == NULL) {             /* No periodic transaction ready?  */
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetAsyncTransactionReadyPipe(DevDataPtr, NULL); /* Find ready async. transaction */
      }
    } else {
      if (DevDataPtr->SofThresholdDetected) {              /* New frame? */
        DevDataPtr->SofThresholdDetected = FALSE;
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetPeriodicTransactionReadyPipe(DevDataPtr->PeriodicPipeListHeadPtr, CurrentFrameNum); /* Find ready periodic transaction */
        if (DevDataPtr->ActivePipePtr == NULL) {           /* No periodic transaction ready?  */
          DevDataPtr->ActivePipePtr = USB_LDD_HostGetAsyncTransactionReadyPipe(DevDataPtr, NULL); /* Find ready async. transaction */
        }
      } else {
        DevDataPtr->ActivePipePtr = USB_LDD_HostGetAsyncTransactionReadyPipe(DevDataPtr, PipePtr); /* Find ready async. transaction */
      }
    }
    if (DevDataPtr->ActivePipePtr != NULL) {               /* Transaction ready? */
      USB_LDD_HostStartTransaction(DevDataPtr);            /* Start transaction on selected pipe */
    }
    /* Handle the last transaction */
    TrPtr     = PipePtr->ActiveTrPtr;
    BDPtr = &DevDataPtr->BDT[Status >> 0x02];
    BDCtrlReg = BDPtr->CtrlReg;
    if ((ErrorStatus & ~(uint32_t)(USB_PDD_BTO_ERR_INT)) != 0x00U) {
      TrPtr->ErrorCounter--;                               /* Decrement error counter */
      if (!TrPtr->ErrorCounter) {
        if ((ErrorStatus & USB_PDD_BTS_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_BTS;
        } else if ((ErrorStatus & USB_PDD_PID_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_PID;
        } else if ((ErrorStatus & USB_PDD_CRC5_EOF_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_EOF;
        } else if ((ErrorStatus & USB_PDD_CRC16_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_CRC16;
        } else if ((ErrorStatus & USB_PDD_DFN8_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_DFN8;
        } else if ((ErrorStatus & USB_PDD_DMA_ERR_INT) != 0x00U) {
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_DMA;
        } else {
          ;
        }
        if (DevDataPtr->EventMask & LDD_USB_ON_HOST_ERROR) {
          USB_LDD_OnHostError(DevDataPtr->UserHostDataPtr, (uint8_t)0U, (uint8_t)(TrPtr->TrState));
        }
      }
    } else {
      switch ((uint32_t)BDCtrlReg & USB_LDD_BD_PID_MASK) {
        case USB_LDD_BD_PID_ACK:                           /* Setup/OUT(Tx) packet sent and ACK packet received  */
        case USB_LDD_BD_PID_DATA0:                         /* IN(Rx) packet received and ACK sent*/
        case USB_LDD_BD_PID_DATA1:
          TrPtr->ErrorCounter = 0x03U;
          switch (TrPtr->TrState) {                        /* Check transfer state */
            case USB_LDD_TRANSFER_SETUP_PENDING:           /* Control transfer setup stage done? */
              /* Setup stage of control transfer done */
              if (TrPtr->Head.BufferSize == 0x00U) {       /* Any data stage? */
                TrPtr->TrState = USB_LDD_TRANSFER_HSK_QUEUED; /* No data stage, next phase is handshake phase */
                PipePtr->Head.EpDir = (uint8_t)(1U);       /* Handshake packet must IN direction */
              } else {
                TrPtr->TrState = USB_LDD_TRANSFER_DATA_QUEUED; /* Next phase is data phase */
              }
              PipePtr->NextData01 = (uint8_t)USB_LDD_BD_DATA1; /* Next data packet must has DATA1 PID */
              break;
            case USB_LDD_TRANSFER_DATA_PENDING:            /* Data transaction done? */
              /* Data transaction done */                  /* Toggle DATA PID */
              PipePtr->NextData01 ^= (uint8_t)USB_LDD_BD_DATA1;
              DataSize  = (uint16_t)((BDCtrlReg >> 0x10U) & 0x03FFU); /* Get transferred data size */
              TrPtr->Head.BufferSize -= DataSize;          /* Update remaining data counter */
              TrPtr->tmpBufferPtr = (uint8_t*)((uint32_t)TrPtr->tmpBufferPtr + (uint32_t)DataSize); /* Update data pointer */
              if ((TrPtr->Head.BufferSize == 0x00U) || (DataSize < PipePtr->Head.MaxPacketSize)) { /* All data transferred? */
                /* Transfer done */
                if (PipePtr->Head.TransferType == LDD_USB_CONTROL) { /* Control transfer? */
                  TrPtr->TrState = USB_LDD_TRANSFER_HSK_QUEUED; /* Next phase is handshake phase */
                  TrPtr->Head.BufferSize = 0x00U;          /* Handshake packet must be 0 size */
                  PipePtr->NextData01 = (uint8_t)USB_LDD_BD_DATA1; /* Handshake data packet must has DATA1 PID */
                  PipePtr->Head.EpDir = (uint8_t)(PipePtr->Head.EpDir ^ LDD_USB_DIR_MASK); /* Handshake packet must has opposite direction to data packet */
                } else {
                  TrPtr->TrState = USB_LDD_TRANSFER_DONE;  /* Update transfer state */
                }
              } else {
                /* Next transaction needed */
              }
              break;
            case USB_LDD_TRANSFER_HSK_PENDING:             /* Control transfer handshake stage done? */
              /* Control transfer done */
              TrPtr->TrState = USB_LDD_TRANSFER_DONE;      /* Update transfer state */
              break;
            default:
              break;
          }
          break;
        case USB_LDD_BD_PID_NACK:
          break;
        case USB_LDD_BD_PID_STALL:
          TrPtr->TrState = USB_LDD_TRANSFER_ERROR_STALLED;
          TrPtr->ErrorCounter = 0x00U;
          break;
        default:                                           /* Transfer error */
          TrPtr->ErrorCounter--;                           /* Decrement error counter */
          if (!TrPtr->ErrorCounter) {
            switch ((uint32_t)BDCtrlReg & USB_LDD_BD_PID_MASK) {
              case USB_LDD_BD_PID_BUS_TIMEOUT: /*  */
                TrPtr->TrState = USB_LDD_TRANSFER_ERROR_BUS_TIMEOUT;
                break;
              case USB_LDD_BD_PID_DATA_ERROR:
                TrPtr->TrState = USB_LDD_TRANSFER_ERROR_DATA;
                break;
              default:
                break;
            }
            if (DevDataPtr->EventMask & LDD_USB_ON_HOST_ERROR) {
              USB_LDD_OnHostError(DevDataPtr->UserHostDataPtr, (uint8_t)0U, (uint8_t)(TrPtr->TrState));
            }
          }
        break;
      }
    }
    if (TrPtr->TrState < USB_LDD_TRANSFER_QUEUED) {        /* Transfer done, stalled, canceled or error detected? */
      USB_LDD_HostTransferDone(DevDataPtr, TrPtr);         /* Call transfer complete handler */
      if (TrPtr->TrState == USB_LDD_TRANSFER_DONE) {       /* Transfer done without error? */
        PipePtr->ActiveTrPtr = TrPtr->NextTrPtr;           /* Yes, prepare next transfer for this pipe */
        TrPtr->NextTrPtr = DevDataPtr->FreeTDListPtr;      /* return TD to the free TD list */
        DevDataPtr->FreeTDListPtr = TrPtr;
      } else {                                             /* No, transfer error */
        if (PipePtr->Head.TransferType != LDD_USB_ISOCHRONOUS) {
          while (TrPtr->NextTrPtr) {
            TrPtr = TrPtr->NextTrPtr;
            TrPtr->TrState = USB_LDD_TRANSFER_ERROR;
            USB_LDD_HostTransferDone(DevDataPtr, TrPtr);   /* Call transfer complete handler */
            TrPtr->NextTrPtr = DevDataPtr->FreeTDListPtr;  /* return TD to the free TD list */
            DevDataPtr->FreeTDListPtr = TrPtr;
          }
          PipePtr->ActiveTrPtr = NULL;
        }
      }
    }
    if (DevDataPtr->ActivePipePtr == NULL) {               /* Transaction in progress? */
      if (PipePtr->ActiveTrPtr != NULL) {                  /* No, transaction ready for current pipe ? */
        if (!((uint32_t)PipePtr->Head.TransferType & 1U)) { /* Async. pipe? */
          DevDataPtr->ActivePipePtr = PipePtr;
          USB_LDD_HostStartTransaction(DevDataPtr);        /* Start new transaction on current pipe */
        }
      } else {
        DevDataPtr->ActivePipePtr = NULL;                  /* No transaction ready, stop engine */
      }
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_HostTimerDoneIsr (component USB_LDD)
**
**     Description :
**         Host mode timer done handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostTimerDoneIsr(USB_LDD_TDeviceData *DevDataPtr)
{
  switch (DevDataPtr->HostState) {
    case LDD_USB_HOST_PORT_DISABLED:
      /* Device is attached for at least 100 ms (TATTDB). Usb spec 2.0 chapter 7.17.3 */
      switch (USB_PDD_GetBusSpeed(USB0_BASE_PTR)) {
        case USB_PDD_LOW_SPEED:
          DevDataPtr->BusSpeed = LDD_USB_LOW_SPEED;
          USB_PDD_EnableDirectLowSpeedDevice(USB0_BASE_PTR, PDD_ENABLE);
          USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_ENABLE);
          break;
        case USB_PDD_FULL_SPEED:
          DevDataPtr->BusSpeed = LDD_USB_FULL_SPEED;
          USB_PDD_EnableLowSpeed(USB0_BASE_PTR, PDD_DISABLE);
          break;
        default:
          DevDataPtr->BusSpeed = LDD_USB_SPEED_UNKNOWN;
          return;
      }
      USB_LDD_HostResetPort(DevDataPtr);
      break;
    case LDD_USB_HOST_PORT_RESETING:
      /* Reset signal was asserted for at 50 ms least ms (TDRST). Usb spec 2.0 chapter 7.17.3 */
      USB_PDD_StartResetSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop reset signaling */
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_ALL_INT_FLAGS); /* Clear all interrupt flags */
      USB_PDD_EnableBusResetInterrupt(USB0_BASE_PTR);       /* Enable only "deattach" interrupt */
      USB_PDD_EnableSof(USB0_BASE_PTR, PDD_ENABLE);         /* and enable SOF */
      /* Wait at least 10 ms (TRSTRCY) for reset recovery */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_RESET_RECOVERING; /* Remember new port state */
      USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESET_RECOVERY_INTERVAL_MS + 1); /* Start reset recovery interval */
      break;
    case LDD_USB_HOST_PORT_RESET_RECOVERING:
      /* Reset recovery done, the port can now be used to transfer data */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_ENABLED;    /* Remember new port state */
      if (DevDataPtr->EventMask & LDD_USB_ON_HOST_RESET_RECOVERY) {
        USB_LDD_OnHostResetRecovery(DevDataPtr->UserHostDataPtr, DevDataPtr->BusSpeed);
      }
      break;
    case LDD_USB_HOST_PORT_SUSPENDED:
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR,USB_PDD_USB_RST_INT); /* Clear "deattache" interrupt flag */
      USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR,USB_PDD_USB_RST_INT | USB_PDD_RESUME_INT); /* Enable "deattach" and "resume" interrupts */
      DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUME_READY; /* Remember new port state */
      break;
    case LDD_USB_HOST_PORT_RESUMING:
      if (USB_PDD_GetResumeSignalState(USB0_BASE_PTR)) {
        USB_PDD_StartResumeSignaling(USB0_BASE_PTR, PDD_DISABLE); /* Stop resume signaling */
        USB_LDD_StartTimer(DevDataPtr, 1);                  /* and wait 1 ms before enabling SOF */
      } else {
        USB_PDD_EnableSof(USB0_BASE_PTR, PDD_ENABLE);       /* Enable SOF */
        DevDataPtr->HostState = LDD_USB_HOST_PORT_RESUME_RECOVERING; /* Remember new port state */
        USB_LDD_StartTimer(DevDataPtr, USB_LDD_HOST_RESUME_RECOVERY_INTERVAL_MS + 1); /* Start resume recovery interval */
      }
      break;
    case LDD_USB_HOST_PORT_RESUME_RECOVERING:
      DevDataPtr->HostState = LDD_USB_HOST_PORT_ENABLED;    /* Remember new port state */
      if (DevDataPtr->EventMask & LDD_USB_ON_HOST_RESUME_RECOVERY) {
        USB_LDD_OnHostResumeRecovery(DevDataPtr->UserHostDataPtr);
      }
      break;
    default:
      break;
  }
}
/*
** ===================================================================
**     Method      :  USB_LDD_HostIsr (component USB_LDD)
**
**     Description :
**         Host interrupt service handler.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_HostIsr(USB_LDD_TDeviceData *DevDataPtr, uint32_t InSignalsState)
{
  uint32_t                         ErrorStatus;
  uint32_t                         IntStatus;
  uint32_t                         TransactionStatus;

  if (DevDataPtr->HostState >= LDD_USB_HOST_PORT_POWERED_OFF) {
    /* 1ms interrupt handler */
    if ((InSignalsState & USB_LDD_TIMEOUT) != 0x00U) {      /* Timeout? */
      USB_LDD_HostTimerDoneIsr(DevDataPtr);
    }
    IntStatus = USB_PDD_GetUsbInterruptFlags(USB0_BASE_PTR);
    IntStatus &= USB_PDD_GetUsbInterruptMask(USB0_BASE_PTR);
    if (IntStatus) {                                       /* Any interrupt request? */
      TransactionStatus = USB_PDD_ReadStatusReg(USB0_BASE_PTR); /* Read Status register before clearing int. flags */
      ErrorStatus = USB_PDD_GetErrorsInterruptFlags(USB0_BASE_PTR); /* Read Error status register */
      if ((IntStatus & USB_PDD_TOK_DNE_INT) != 0x00U) {    /* TokenDone request? */
        USB_PDD_ClearErrorsInterruptFlags(USB0_BASE_PTR, (uint8_t)ErrorStatus); /* Clear error flags */
      }
      USB_PDD_ClearUsbInterruptFlags(USB0_BASE_PTR, (uint8_t)IntStatus); /* Clear interrupt flags */
      USB_LDD_HostMainIsr(DevDataPtr, IntStatus, TransactionStatus, ErrorStatus); /* Call interrupt handler */
    }
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_OtgSetMode (component USB_LDD)
**
**     Description :
**         Otg mode enable code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_OtgSetMode(USB_LDD_TDeviceData *DevDataPtr, USB_LDD_TOtgMode NewOtgMode)
{
  if (NewOtgMode != DevDataPtr->OtgMode) {
    switch (NewOtgMode) {
      case USB_LDD_MODE_DEVICE:                            /* New mode = Device? */
        if (DevDataPtr->OtgMode == USB_LDD_MODE_HOST) {    /* Yes, Host mode active? */
          if (DevDataPtr->EventMask & LDD_USB_ON_OTG_HOST) {
            USB_LDD_OnOtgHost(DevDataPtr->UserOtgDataPtr, FALSE);
          }
          USB_LDD_HostDisable(DevDataPtr);                 /* Yes, disable Host mode */
        }
        USB_LDD_DeviceEnable(DevDataPtr);                  /* Enable Device mode */
        if (DevDataPtr->EventMask & LDD_USB_ON_OTG_DEVICE) {
          USB_LDD_OnOtgDevice(DevDataPtr->UserOtgDataPtr, TRUE);
        }
        break;
      case USB_LDD_MODE_HOST:                              /* New mode = Host? */
        if (DevDataPtr->OtgMode == USB_LDD_MODE_DEVICE) {  /* Yes, Device mode active? */
          USB_LDD_DeviceDisable(DevDataPtr);               /* Yes, disable Device mode */
          if (DevDataPtr->EventMask & LDD_USB_ON_OTG_DEVICE) {
            USB_LDD_OnOtgDevice(DevDataPtr->UserOtgDataPtr, FALSE);
          }
        }
        USB_LDD_HostEnable(DevDataPtr);                    /* Enable Host mode */
        if (DevDataPtr->EventMask & LDD_USB_ON_OTG_HOST) {
          USB_LDD_OnOtgHost(DevDataPtr->UserOtgDataPtr, TRUE);
        }
        break;
      default:                                             /* Disable both mode */
        if (DevDataPtr->OtgMode == USB_LDD_MODE_DEVICE) {
          if (DevDataPtr->EventMask & LDD_USB_ON_OTG_DEVICE) {
            USB_LDD_OnOtgDevice(DevDataPtr->UserOtgDataPtr, FALSE);
          }
          USB_LDD_DeviceDisable(DevDataPtr);
        } else {
          if (DevDataPtr->EventMask & LDD_USB_ON_OTG_HOST) {
            USB_LDD_OnOtgHost(DevDataPtr->UserOtgDataPtr, FALSE);
          }
          USB_LDD_HostDisable(DevDataPtr);
        }
        break;
    } /* case */
    DevDataPtr->OtgMode = NewOtgMode;                      /* Remember new mode */
  }
}
/*
** ===================================================================
**     Method      :  USB_LDD_EnterNewState (component USB_LDD)
**
**     Description :
**         Enters new state.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_EnterNewState(USB_LDD_TDeviceData *DevDataPtr, LDD_USB_Otg_TState NewState)
{
  if (DevDataPtr->OtgState == NewState) {
    /* No stage change */
    return;
  }
  DevDataPtr->OtgMsCounter = 0x00;                         /* Suppose no timing (disable timer) */
  switch (NewState) {

    case LDD_USB_OTG_A_IDLE:
      USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
          (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN | LDD_USB_OTG_VBUS_CHARGE_PIN),
          (LDD_TPinMask)(0x00));
      USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, ((USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) & (uint8_t)~(uint8_t)0xB0) | (uint8_t)0x30)); /* Disable VBUS */
      USB_LDD_OtgSetMode(DevDataPtr, USB_LDD_MODE_UNKNOWN); /* Enable host mode */
      break;

    case LDD_USB_OTG_A_WAIT_VRISE:
      /* Power on VBUS and start waiting for VBUS to become valid. */
      USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
          (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN),
          (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN));
      USB_LDD_StartOtgTimer(DevDataPtr, USB_LDD_A_WAIT_VRISE_TIME_OUT_MS); /* Enable timer */
      break;

    case LDD_USB_OTG_A_WAIT_VFALL:
      /* Power off VBUS and start waiting for VBUS to fall down */
      DevDataPtr->InSignalsState &= ~(uint32_t)(USB_LDD_OTG_A_SRP_DET); /* Clear SRP detect flag */
      USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
          (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN),
          (LDD_TPinMask)(0x00));
      USB_LDD_OtgSetMode(DevDataPtr, USB_LDD_MODE_UNKNOWN); /* Enable host mode */
      USB_LDD_StartOtgTimer(DevDataPtr, 2);                /* Enable timer to detect B-disconnect */
      break;

    case LDD_USB_OTG_A_WAIT_BCON:
      /* Start waiting for B device connect */
      DevDataPtr->AWaitBConDebounceCounter = DevDataPtr->AWaitBConDebounceInitVal; /* Set debounce interval */
      USB_LDD_StartOtgTimer(DevDataPtr, 0x01);             /* Enable timer */
      break;

    case LDD_USB_OTG_A_VBUS_ERROR:
      /* VBUS error */
      USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
          (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN),
          (LDD_TPinMask)(0x00));
      USB_LDD_OtgSetMode(DevDataPtr, USB_LDD_MODE_UNKNOWN); /* Disable host mode */
      break;

    case LDD_USB_OTG_A_HOST:
      USB_LDD_OtgSetMode(DevDataPtr, USB_LDD_MODE_HOST);   /* Enable host mode */
      break;

    case LDD_USB_OTG_A_SUSPEND:
      DevDataPtr->InSignalsState &= ~(uint32_t)(USB_LDD_OTG_B_BUS_RESUME); /* Clear B_BUS_RESUME flag */
      break;

    case LDD_USB_OTG_B_IDLE:
      USB_PDD_SetUsbInterruptMask(USB0_BASE_PTR, 0x00U);
      USB_LDD_OnSignalChange(DevDataPtr->UserOtgDataPtr,
          (LDD_TPinMask)(LDD_USB_OTG_VBUS_ENABLE_PIN),
          (LDD_TPinMask)(0x00));
      USB_PDD_WriteOtgControlReg(USB0_BASE_PTR, ((USB_PDD_ReadOtgControlReg(USB0_BASE_PTR) & (uint8_t)~(uint8_t)0xB0) | (uint8_t)0x10)); /* Disable VBUS */
      USB_LDD_OtgSetMode(DevDataPtr, USB_LDD_MODE_UNKNOWN); /* Disable both modes */
      break;

    case LDD_USB_OTG_B_PERIPHERAL:
      DevDataPtr->InSignalsState &= ~(uint32_t)(USB_LDD_OTG_A_BUS_SUSPEND); /* Clear A_BusSuspend flag */
      USB_LDD_OtgSetMode(DevDataPtr, USB_LDD_MODE_DEVICE); /* Enable device mode */
      break;

    default:
      break;
  }
  DevDataPtr->OtgState = NewState;
  if (DevDataPtr->EventMask & LDD_USB_ON_OTG_STATE_CHANGE) {
    USB_LDD_OnOtgStateChange(DevDataPtr->UserOtgDataPtr, DevDataPtr->OtgState);
  }
}

/*
** ===================================================================
**     Method      :  USB_LDD_OtgStateMachine (component USB_LDD)
**
**     Description :
**         Otg state machine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void USB_LDD_OtgStateMachine(USB_LDD_TDeviceData *DevDataPtr)
{
  LDD_USB_Otg_TState OldOtgState;
  uint32_t InSignalsState;

  do {
    OldOtgState = DevDataPtr->OtgState;
    InSignalsState = DevDataPtr->InSignalsState;

    switch (DevDataPtr->OtgState) {

      case LDD_USB_OTG_DISABLED:
        if ((InSignalsState & USB_LDD_OTG_TIMEOUT) != 0x00U) { /* Timeout? */
          if ((InSignalsState & USB_LDD_OTG_ID) != 0x00U) { /* ID != Host? */
            DevDataPtr->InSignalsState |= USB_LDD_OTG_B_BUS_REQ; /* Power on, B_BusReq = true */
            USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_B_IDLE); /* Yes, B device or no cable connected, new state = B_IDLE */
          } else {                                         /* ID == Host */
            DevDataPtr->InSignalsState |= USB_LDD_OTG_A_BUS_REQ; /* Power on, A_BusReq = true */
            USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_IDLE); /* New state = A_IDLE */
          }
        }
        break;

      case LDD_USB_OTG_A_IDLE:
        if ((InSignalsState & USB_LDD_OTG_ID) != 0x00U) {  /* ID != Host? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_B_IDLE); /* Yes, new state = B_IDLE */
        } else if (((InSignalsState & USB_LDD_OTG_A_BUS_DROP) == 0U) && \
          ((InSignalsState & USB_LDD_OTG_A_BUS_REQ) !=0U)) { /* ~A_BusDrop & A_BusReq */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_VRISE); /* Yes, new state = A_WAIT_VRISE */
        } else {                                           /* No state change, device is IDLE */
          ; /* No state change */
        }
        break;

      case LDD_USB_OTG_A_WAIT_VRISE:
        if ((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_A_BUS_DROP | \
            USB_LDD_OTG_A_VBUS_VALID | USB_LDD_OTG_TIMEOUT)) != 0x00U) { /* ID | A_BusDrop | A_BusValid | Timeout? */
          DevDataPtr->AWaitBConDebounceInitVal = USB_LDD_A_WAIT_BCON_LONG_DEBOUCE_MS; /* Yes, set long debouce interval */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_BCON); /* New state = A_WAIT_VRISE */
        }
        break;

      case LDD_USB_OTG_A_WAIT_BCON:
        if ((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_A_BUS_DROP)) != 0x00U) { /* ID | A_BusDrop? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_VFALL); /* Yes, new state = A_WAIT_VFALL */
        } else if ((InSignalsState & USB_LDD_OTG_A_VBUS_VALID) == 0x00U) { /* ~AVbusVld? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_VBUS_ERROR); /* Yes, new state = A_VBUS_ERROR */
        } else if ((InSignalsState & USB_LDD_OTG_TIMEOUT) != 0x00U) { /* 1 ms timeout? */
          if ((InSignalsState & USB_LDD_OTG_B_CONN) != 0x00U) { /* B device connected? */
            DevDataPtr->AWaitBConDebounceCounter--;        /* Yes, decrement debounce interval counter */
          } else {
            DevDataPtr->AWaitBConDebounceCounter = DevDataPtr->AWaitBConDebounceInitVal; /* No, restart debounce counter */
          }
          if (DevDataPtr->AWaitBConDebounceCounter == 0x00) { /* B_CONN debounce interval done? */
            USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_HOST); /* Yes, new state = A_HOST */
          } else {
            USB_LDD_StartOtgTimer(DevDataPtr, 0x01);       /* Enable timer */
          }
        } else {
          ; /* No state change */
        }
        break;

      case LDD_USB_OTG_A_VBUS_ERROR:
        if ((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_A_BUS_DROP | USB_LDD_OTG_A_CLR_ERR)) != 0x00U) { /* ID | A_BusDrop | A_ClrErr? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_VFALL); /* Yes, new state = A_WAIT_VFALL */
        }
        break;

      case LDD_USB_OTG_A_HOST:
        if (((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_A_BUS_DROP)) != 0x00U) || \
            ((InSignalsState & USB_LDD_OTG_B_CONN) == 0x00U)) { /* ID | A_BusDrop | ~B_Conn? */
          DevDataPtr->AWaitBConDebounceInitVal = USB_LDD_A_WAIT_BCON_SHORT_DEBOUCE_MS; /* Yes, set short debouce interval */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_BCON); /* New state = A_WAIT_BCON */
        } else if ((InSignalsState & USB_LDD_OTG_A_VBUS_VALID) == 0x00U) { /* ~A_VbusVld ?*/
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_VBUS_ERROR); /* Yes, new state = A_VBUS_ERROR */
        } else if (((InSignalsState & USB_LDD_OTG_A_BUS_REQ) == 0x00U) || \
            ((InSignalsState & USB_LDD_OTG_A_SUSPEND_REQ) != 0x00U)) { /* ~A_BusReq | A_SuspendReq? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_SUSPEND); /* Yes, new state = A_SUSPEND */
        } else {
          ; /* No state change */
        }
        break;

      case LDD_USB_OTG_A_SUSPEND:
        if ((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_A_BUS_DROP)) != 0x00U) { /* ID | A_BusDrop ? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_VFALL); /* Yes, new state = A_WAIT_VFALL */
        } else if ((InSignalsState & USB_LDD_OTG_A_VBUS_VALID) == 0x00U) { /* ~A_VbusVld? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_VBUS_ERROR); /* Yes, new state = A_VBUS_ERROR */
        } else if ((InSignalsState & (USB_LDD_OTG_A_BUS_REQ | USB_LDD_OTG_B_BUS_RESUME)) != 0x00U) { /* A_BusReq | B_BusResume? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_HOST); /* Yes, new state = A_HOST */
        } else if ((InSignalsState & (USB_LDD_OTG_B_CONN | USB_LDD_OTG_A_SET_B_HNP_EN)) == 0x00U) { /* ~B_Conn & ~A_SetHnpEn? */
          DevDataPtr->AWaitBConDebounceInitVal = USB_LDD_A_WAIT_BCON_SHORT_DEBOUCE_MS; /* Yes, set short debouce interval */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_WAIT_BCON); /* New state = A_WAIT_BCON */
        } else {
          ; /* No state change */
        }
        break;

      case LDD_USB_OTG_A_WAIT_VFALL:
        if (((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_A_BUS_REQ)) != 0x00U) || \
            ((InSignalsState & (USB_LDD_OTG_A_SESSION_VALID | USB_LDD_OTG_B_CONN)) == 0x00U)) { /*  ID | A_BusReq | (~A_SessionValid & ~B_CON)? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_IDLE); /* New state = A_IDLE */
        }
        break;

      case LDD_USB_OTG_B_IDLE:
        if ((InSignalsState & USB_LDD_OTG_ID) == 0x00U) {  /* ~ID? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_A_IDLE); /* Yes, new state = A_IDLE */
        } else if ((InSignalsState & USB_LDD_OTG_B_SESSION_VALID) != 0x00U) { /* B_SessVld? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_B_PERIPHERAL); /* Yes, new state = B_PERIPHERAL */
        } else {
          ; /* No state change */
        }
        break;

      case LDD_USB_OTG_B_PERIPHERAL:
        if ((InSignalsState & (USB_LDD_OTG_ID | USB_LDD_OTG_B_SESSION_VALID)) != \
            (USB_LDD_OTG_ID | USB_LDD_OTG_B_SESSION_VALID)) { /* ~ID | ~B_SessVld? */
          USB_LDD_EnterNewState(DevDataPtr, LDD_USB_OTG_B_IDLE); /* Yes, new state = B_IDLE */
        } else {
          ; /* No state change */
        }
        break;

      default:
        break;
    }
    DevDataPtr->InSignalsState &= ~(uint32_t)(USB_LDD_OTG_1MS_TIMEOUT | USB_LDD_OTG_TIMEOUT); /* Clear timeout flag */
  } while ((DevDataPtr->OtgState != OldOtgState) || (DevDataPtr->InSignalsState != InSignalsState));
}
/*
** ===================================================================
**     Method      :  USB_LDD_USB_Interrupt (component USB_LDD)
**
**     Description :
**         USB interrupt handler
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(USB_LDD_USB_Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  USB_LDD_TDeviceDataPtr DevDataPtr = INT_USB0__DEFAULT_RTOS_ISRPARAM;
  uint32_t NewInSignalState;
  uint32_t OtgIntStatus;
  uint32_t UsbIntStatus;
  uint32_t NewOtgInSignalState;
  uint32_t LineState;
  
  DevDataPtr->ISR = TRUE;
  UsbIntStatus = USB_PDD_GetUsbInterruptFlags(USB0_BASE_PTR);
  UsbIntStatus &= USB_PDD_GetUsbInterruptMask(USB0_BASE_PTR);
  OtgIntStatus = USB_PDD_GetOtgInterruptFlags(USB0_BASE_PTR);
  OtgIntStatus &= USB_PDD_GetOtgInterruptMask(USB0_BASE_PTR);
  USB_PDD_ClearOtgInterruptFlags(USB0_BASE_PTR, OtgIntStatus);
  NewOtgInSignalState = DevDataPtr->InSignalsState;        /* Get current signal state */
  NewInSignalState = DevDataPtr->InSignalsState;           /* Get current signal state */
  LineState = (uint32_t)USB_PDD_ReadControlReg(USB0_BASE_PTR); /* Get current line state */
  if (USB_PDD_GetLineStateStableState(USB0_BASE_PTR) != 0U) { /* Line stable stabe for 1ms */
    if ((LineState & USB_PDD_SE0) != 0U) {                 /* SE0? */
      if (USB_PDD_GetResetSignalState(USB0_BASE_PTR) == 0U) { /* Yes, reset signaling in progress? */
        NewOtgInSignalState &= ~(uint32_t)USB_LDD_OTG_B_CONN; /* No, B device is not connected */
      }
    } else {
      NewOtgInSignalState |= USB_LDD_OTG_B_CONN;           /* No SE0, B device is connected */
    }
  }
  if ((UsbIntStatus & USB_PDD_SLEEP_INT) != 0U) {          /* Suspend interrupt? */
    NewOtgInSignalState |= USB_LDD_OTG_A_BUS_SUSPEND;      /* Set A bus suspend flag */
    NewOtgInSignalState |= USB_LDD_OTG_B_BUS_SUSPEND;      /* Set B bus suspend flag */
  }
  if ((UsbIntStatus & USB_PDD_RESUME_INT) != 0U) {         /* Resume interrupt? */
    NewOtgInSignalState |= USB_LDD_OTG_A_BUS_RESUME;       /* Set A bus resume flag */
    NewOtgInSignalState |= USB_LDD_OTG_B_BUS_RESUME;       /* Set A bus resume flag */
  }
  if ((OtgIntStatus & USB_PDD_1_MSEC_INT) != 0U) {         /* 1ms timer interrupt? */
    if (DevDataPtr->OtgMsCounter > 0x00) {                 /* Otg timing in progress? */
      NewOtgInSignalState |= USB_LDD_OTG_1MS_TIMEOUT;      /* Remember timeout */
      DevDataPtr->OtgMsCounter--;                          /* Decrement 1 ms counter */
      if (DevDataPtr->OtgMsCounter == 0x00 ) {             /* Timing done? */
        NewOtgInSignalState |= USB_LDD_OTG_TIMEOUT;        /* Remember timeout */
      }
    }
    NewInSignalState |= USB_LDD_1MS_TIMEOUT;               /* Remember timeout */
    if (DevDataPtr->msCounter > 0x00) {                    /* Otg timing in progress? */
      DevDataPtr->msCounter--;                             /* Decrement 1 ms counter */
      if (DevDataPtr->msCounter == 0x00 ) {                /* Timing done? */
        NewInSignalState |= USB_LDD_TIMEOUT;               /* Remember timeout */
      }
    }
    if ((DevDataPtr->OtgMsCounter == 0x00 ) && (DevDataPtr->msCounter == 0x00 )) { /* Timing done? */
      USB_PDD_Disable1msInterrupt(USB0_BASE_PTR);          /* Yes, disable 1 ms interrupt */
    }
  } /* 1 ms interrupt */
  if (DevDataPtr->InSignalsState != NewOtgInSignalState) { /* Yes, signal state changed?  */
    DevDataPtr->InSignalsState = NewOtgInSignalState;
    USB_LDD_OtgStateMachine(DevDataPtr);                   /* Yes, call state machine */
  }
  USB_LDD_DeviceIsr(DevDataPtr, NewInSignalState);         /* Call device interrupt handler */
  USB_LDD_HostIsr(DevDataPtr, NewInSignalState);           /* Call host interrupt handler */
  DevDataPtr->ISR = FALSE;
}


/*lint -restore Enable MISRA rule (11.4) checking. */
/* END USB_LDD. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 10.0 [05.03]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
