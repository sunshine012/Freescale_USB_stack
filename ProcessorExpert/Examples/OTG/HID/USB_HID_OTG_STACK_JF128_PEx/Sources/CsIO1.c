/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : CsIO1.c
**     Project     : ProcessorExpert
**     Processor   : MK60DN512ZVMD10
**     Component   : ConsoleIO
**     Version     : Component 01.051, Driver 01.00, CPU db: 3.00.003
**     Compiler    : CodeWarrior ARM C Compiler
**     Date/Time   : 2011-11-28, 08:50, # CodeGen: 98
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         MsgQueueInsert  - void CsIO1_MsgQueueInsert(char *pMsgStr);
**         MsgQueuePrint   - bool CsIO1_MsgQueuePrint(void);
**         MsgPrint        - void CsIO1_MsgPrint(char *pMsgStr);
**         Cls             - void CsIO1_Cls(void);
**         ReadLine        - LDD_TError CsIO1_ReadLine(uint8_t *BufferPtr, uint32_t BufferSize);
**         GetWords        - void CsIO1_GetWords(uint8_t *BufferPtr, uint8_t Separator);
**         PrintAt         - void CsIO1_PrintAt(uint32_t Row, uint32_t Col, void* Str);
**         PutChar         - void CsIO1_PutChar(uint8_t Char);
**         GetErrorMessage - char * CsIO1_GetErrorMessage(uint32_t ErrorCode);
**         PrintMcuInfo    - void CsIO1_PrintMcuInfo(void);
**
**     Copyright : 1997 - 2011 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/
/* MODULE CsIO1. */
#include <file_struc.h>
#include "CsIO1.h"
#include "IO_Map.h"
#include "stdio.h"
#include "PE_LDD.h"
#include <stdarg.h>
#include "UART_PDD.h"
#include "AS1.h"
#define MsgCount 400

/* Local variables */
static char* volatile MsgArray[MsgCount];
static volatile uint8_t rBufIdx=0;
static volatile uint8_t wBufIdx=0;
static volatile uint16_t cntOvf=0;
static volatile uint16_t cntPrn=0;
static volatile uint16_t InsertMsgCnt=0;
static const char* FamilyName[] = {"K10","K20","K30","K40","K60","K70","K50/K552","K51/K53"};
static const char* PinCount[] = {"Reserved","Reserved","32","Reserved","48","64","80","81","100","121","144","Reserved","196","Reserved","256","Reserved"};
static const char* RamSize[] = {"Undef","Undef","Undef","Undef","Undef","32K","Undef","64K","96K","128K","Undef","Undef","Undef","Undef","Undef","Undef"};
static const char* DFlashSize[] = {"0K","Undef","Undef","Undef","Undef","Undef","Undef","128K, 16K protection","Undef","256K, 32K protection","Undef","Undef","Undef","Undef","Undef","256K, 32K protection"};
static const char* PFlashSize[] = {"Undef","Undef","Undef","Undef","Undef","Undef","Undef","128K, 4K protection","Undef","256K, 8K protection","Undef","512K, 16K protection","Undef","Undef","Undef","512K, 16K protection"};
static const char* EEpromSize[] = {"Reserved","Reserved","4K","2K","1K","512B","256B","128B","64B","32B","Reserved","Reserved","Reserved","Reserved","Reserved","0B"};

/* Global variables */
char* ErrorMsgTable[] = {
    "ERR_OK",                             /* 0x00U OK */
    "ERR_SPEED",                          /* 0x01U This device does not work in the active speed mode. */
    "ERR_RANGE",                          /* 0x02U Parameter out of range. */
    "ERR_VALUE",                          /* 0x03U Parameter of incorrect value. */
    "ERR_OVERFLOW",                       /* 0x04U Timer overflow. */
    "ERR_MATH",                           /* 0x05U Overflow during evaluation. */
    "ERR_ENABLED",                        /* 0x06U Device is enabled. */
    "ERR_DISABLED",                       /* 0x07U Device is disabled. */
    "ERR_BUSY",                           /* 0x08U  Device is busy. */
    "ERR_NOTAVAIL",                       /* 0x09U Requested value or method not available. */
    "ERR_RXEMPTY",                        /* 0x0AU No data in receiver. */
    "ERR_TXFULL",                         /* 0x0BU Transmitter is full. */
    "ERR_BUSOFF",                         /* 0x0CU Bus not available. */
    "ERR_OVERRUN",                        /* 0x0DU Overrun error is detected. */
    "ERR_FRAMING",                        /* 0x0EU Framing error is detected. */
    "ERR_PARITY",                         /* 0x0FU Parity error is detected. */
    "ERR_NOISE",                          /* 0x10U Noise error is detected. */
    "ERR_IDLE",                           /* 0x11U Idle error is detected. */
    "ERR_FAULT",                          /* 0x12U Fault error is detected. */
    "ERR_BREAK",                          /* 0x13U Break char is received during communication. */
    "ERR_CRC",                            /* 0x14U CRC error is detected. */
    "ERR_ARBITR",                         /* 0x15U A node losts arbitration. This error occurs if two nodes start transmission at the same time. */
    "ERR_PROTECT",                        /* 0x16U Protection error is detected. */
    "ERR_UNDERFLOW",                      /* 0x17U Underflow error is detected. */
    "ERR_UNDERRUN",                       /* 0x18U Underrun error is detected. */
    "ERR_COMMON",                         /* 0x19U Common error of a device. */
    "ERR_LINSYNC",                        /* 0x1AU LIN synchronization error is detected. */
    "ERR_FAILED",                         /* 0x1BU Requested functionality or process failed. */
    "ERR_QFULL"                           /* 0x1CU Queue is full. */
};

char* ErrorParamMsgTable[] = {
    "ERR_PARAM_MASK",                     /* 0x80U Invalid mask. */
    "ERR_PARAM_MODE",                     /* 0x81U Invalid mode. */
    "ERR_PARAM_INDEX",                    /* 0x82U Invalid index. */
    "ERR_PARAM_DATA",                     /* 0x83U Invalid data. */
    "ERR_PARAM_SIZE",                     /* 0x84U Invalid size. */
    "ERR_PARAM_VALUE",                    /* 0x85U Invalid value. */
    "ERR_PARAM_RANGE",                    /* 0x86U Invalid parameter's range or parameters' combination. */
    "ERR_PARAM_LOW_VALUE",                /* 0x87U Invalid value (LOW part). */
    "ERR_PARAM_HIGH_VALUE",               /* 0x88U Invalid value (HIGH part). */
    "ERR_PARAM_ADDRESS",                  /* 0x89U Invalid address. */
    "ERR_PARAM_PARITY",                   /* 0x8AU Invalid parity. */
    "ERR_PARAM_WIDTH",                    /* 0x8BU Invalid width. */
    "ERR_PARAM_LENGTH",                   /* 0x8CU Invalid length. */
    "ERR_PARAM_ADDRESS_TYPE",             /* 0x8DU Invalid address type. */
    "ERR_PARAM_COMMAND_TYPE",             /* 0x8EU Invalid command type. */
    "ERR_PARAM_COMMAND",                  /* 0x8FU Invalid command. */
    "ERR_PARAM_RECIPIENT",                /* 0x90U Invalid recipient. */
    "ERR_PARAM_BUFFER_COUNT",             /* 0x91U Invalid buffer count. */
    "ERR_PARAM_ID",                       /* 0x92U Invalid ID. */
    "ERR_PARAM_GROUP",                    /* 0x93U Invalid group. */
    "ERR_PARAM_CHIP_SELECT",              /* 0x94U Invalid chip select. */
    "ERR_PARAM_ATTRIBUTE_SET",            /* 0x95U Invalid set of attributes. */
    "ERR_PARAM_SAMPLE_COUNT",             /* 0x96U Invalid sample count. */
    "ERR_PARAM_CONDITION",                /* 0x97U Invalid condition. */
    "ERR_PARAM_TICKS"
};                                     /* 0x98U Invalid ticks parameter. */

uint32_t RdLn_BuffIndex = 0;
uint32_t RdRow = 25;
uint32_t RdCol = 6;

/* Internal method prototypes */
int __read_console(__file_handle handle, unsigned char* buffer, size_t * count);
int __write_console(__file_handle handle, unsigned char* buffer, size_t* count);
int __close_console(__file_handle handle);

/*
** ===================================================================
**     Method      :  read_console (component ConsoleIO)
**
**     Description :
**         This method is external. It is used to initialize console.
** ===================================================================
*/
void CsIO1_Init(void)
{
    (void)AS1_Init(NULL);
}

/*
** ===================================================================
**     Method      :  read_console (component ConsoleIO)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
int __read_console(__file_handle handle, unsigned char* buffer, size_t * count)
{
    size_t i;

    (void)handle;

    for (i = 0; i < *count; i++) {
        /* wait until new char is received */
        while ((UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART_S1_RDRF_MASK) == 0) {};

        /* Save a character of the UARTx device into the receive buffer */
        buffer[i] = (unsigned char)UART_PDD_GetChar8(UART0_BASE_PTR);
    }
    return (__no_io_error);
}

/*
** ===================================================================
**     Method      :  write_console (component ConsoleIO)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
int __write_console(__file_handle handle, unsigned char* buffer, size_t* count)
{
    size_t i;
    (void)handle;
    for (i = 0; i < *count; i++) {
        /* Send '\r' before each '\n'.*/
        if (buffer[i] == '\n') {
            /* Wait until UART is ready to write a next character into output buffer */
            while ((UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART_S1_TDRE_MASK) == 0) {};
            /* Save a character into the transmit buffer of the UART0 device */
            UART_PDD_PutChar8(UART0_BASE_PTR, '\r');
        }
        /* Save a character into the transmit buffer of the UART0 device */
        while ((UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART_S1_TDRE_MASK) == 0) {};
        /* Wait until UART is ready for saving a next character into the transmit buffer */
        UART_PDD_PutChar8(UART0_BASE_PTR, (unsigned char)buffer[i]);
    }
    /* Wait until last character is sent */
    while ((UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART_S1_TDRE_MASK) == 0) {};
    return(__no_io_error);
}

/*
** ===================================================================
**     Method      :  close_console (component ConsoleIO)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
int __close_console(__file_handle handle)
{
    (void)handle;
    return(__no_io_error);
}

/*
** ===================================================================
**     Method      :  CsIO1_MsgQueueInsert (component ConsoleIO)
**
**     Description :
**         Insert message to the message queue. Message string must be
**         available until not send to the console = should not be
**         located on the stack.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pMsgStr         - Pointer to message.
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_MsgQueueInsert(char *pMsgStr)
{
    uint8_t wBufIdx_plus_1 = (uint8_t)(wBufIdx+1);

    if (wBufIdx_plus_1 == MsgCount)
    wBufIdx_plus_1=0;
    if (wBufIdx_plus_1==rBufIdx) {
        /*Overflow */
        cntOvf++;
    } else {
        MsgArray[wBufIdx]=pMsgStr;
        wBufIdx = wBufIdx_plus_1;
    }
    InsertMsgCnt++;
}

/*
** ===================================================================
**     Method      :  CsIO1_MsgQueuePrint (component ConsoleIO)
**
**     Description :
**         Prints one message from messge queue to the console.
**     Parameters  : None
**     Returns     :
**         ---             - Returns <false> if queue is empty.
** ===================================================================
*/
bool CsIO1_MsgQueuePrint(void)
{
    uint8_t  rBufIdx_plus_1;
    if(rBufIdx != wBufIdx) {
        printf(MsgArray[rBufIdx]);
        rBufIdx_plus_1 = (uint8_t)(rBufIdx+1);
        if (rBufIdx_plus_1 == MsgCount) {
            rBufIdx=0;
        } else {
            rBufIdx=rBufIdx_plus_1;
        }
        cntPrn++;
        return(TRUE);
    } else {
        return(FALSE);
    }
}

/*
** ===================================================================
**     Method      :  CsIO1_MsgPrint (component ConsoleIO)
**
**     Description :
**         Prints message  directly to the console.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pMsgStr         - Pointer to message.
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_MsgPrint(char *pMsgStr)
{
    printf(pMsgStr);
}

/*
** ===================================================================
**     Method      :  CsIO1_PutChar (component ConsoleIO)
**
**     Description :
**         Prints char
**     Parameters  :
**         NAME            - DESCRIPTION
**         Char            - Char
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_PutChar(uint8_t Char)
{
    while ((UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART_S1_TDRE_MASK) == 0) {};
    UART_PDD_PutChar8(UART0_BASE_PTR, Char);
}

/*
** ===================================================================
**     Method      :  CsIO1_LongToStr (component ConsoleIO)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void LongToStr(char* s, int32_t n)
{
    uint8_t i=0U, j;
    char tmp;
    char Tmp;
    bool sign = (bool)((n < 0) ? TRUE : FALSE);

    if (sign){
        n *= -1;
    }
    if (n == 0){
        s[i++] = '0';
    }
    while (n > 0) {
        Tmp = (char)(((uint32_t)n % 10U) + 0x30U);
        s[i++] = (char)(Tmp);
        n /= 10;
    }
    if (sign){
        s[i++] = '-';
    }
    for(j=0U; j<(i/2U); j++) {
        tmp = s[j];
        s[j] = s[(i-j)-1U];
        s[(i-j)-1U] = tmp;
    }
    s[i] = '\0';
}

/*
** ===================================================================
**     Method      :  CsIO1_MoveTo (component ConsoleIO)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void CsIO1_MoveTo(uint32_t Row, uint32_t Col) {
    char s[15];
    int i;

    CsIO1_PutChar(0x1BU);
    CsIO1_PutChar(0x5BU);
    LongToStr(s, Row);
    i = 0;
    while (s[i] != 0) {
        CsIO1_PutChar(s[i++]);
    }
    CsIO1_PutChar(0x3BU);
    LongToStr(s, Col);
    i = 0;
    while (s[i] != 0) {
        CsIO1_PutChar(s[i++]);
    }
    CsIO1_PutChar(0x48U);
}

/*
** ===================================================================
**     Method      :  CsIO1_Cls (component ConsoleIO)
**
**     Description :
**         Clears screen.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_Cls(void)
{
    CsIO1_PutChar(0x1BU);
    CsIO1_PutChar(0x5BU);
    CsIO1_PutChar(0x32U);
    CsIO1_PutChar(0x4AU);
    CsIO1_MoveTo(1, 1);
}

/*
** ===================================================================
**     Method      :  CsIO1_ReadLine (component ConsoleIO)
**
**     Description :
**         Reads line.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * BufferPtr       - Pointer to buffer
**         BufferSize      - 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint32_t CsIO1_ReadLine(char *BufferPtr, uint32_t BufferSize)
{
    uint32_t Res = ERR_BUSY;
    uint8_t c;

    if (((uint32_t)BufferPtr | (uint32_t)BufferSize) == 0u) { /* BufferPtr == NULL or BufferSize == 0?*/
        RdLn_BuffIndex = 0;                /* Yes, reset buffer index */
        Res = ERR_FAILED;                  /* Return error code */
    } else {
        if ((UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART_S1_RDRF_MASK) != 0) { /* Character recieved? */
            c = (uint8_t)UART_PDD_GetChar8(UART0_BASE_PTR); /* Read char from HW */
            if ((c == '\n') || (c == '\r')) { /* End of line (ENTER)? */
                BufferPtr[RdLn_BuffIndex] = 0u; /* Yes, end string */
                RdLn_BuffIndex = 0;            /* Reset buffer index */
                Res = ERR_OK;                  /* Return error code */
            } else if (c == '\b') {          /* Backspace? */
                if (RdLn_BuffIndex != 0u) {
                    RdLn_BuffIndex--;            /* Update index */
                    CsIO1_PutChar(c);
                    CsIO1_PutChar(' ');
                    CsIO1_PutChar(c);
                }
            } else if (RdLn_BuffIndex < BufferSize) { /* Yes, buffer overflow? */
                BufferPtr[RdLn_BuffIndex] = c; /* No, Put char to the buffer */
                RdLn_BuffIndex++;              /* Update index */
                CsIO1_PutChar(c);              /* Print char to the screen */
            }
        }
    }
    return Res;
}

/*
** ===================================================================
**     Method      :  CsIO1_GetWords (component ConsoleIO)
**
**     Description :
**         Cuts line to the words
**     Parameters  :
**         NAME            - DESCRIPTION
**       * BufferPtr       - Pointer to data buffer
**         Separator       - Separator
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_GetWords(char *BufferPtr, char Separator, ...)
{
    va_list ap;
    char **WordPtr;
    int i = 0;

    va_start(ap, Separator);
    while ((WordPtr = va_arg(ap, char**)) != NULL) {
        while(BufferPtr[i] == Separator){  /* Skip separator character */
            i++;
        };
        *WordPtr = &BufferPtr[i];          /* Remember address on first non-separator character */
        do {
            if (BufferPtr[i] == 0) {         /* End of string? */
                break;
            } else if (BufferPtr[i] == Separator) {
                BufferPtr[i] = 0;
                i++;
                break;
            } else {
                i++;
            }
        } while (1);
    }
    va_end(ap);
}

/*
** ===================================================================
**     Method      :  CsIO1_PrintAt (component ConsoleIO)
**
**     Description :
**         Prints string at given possition.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Row             - Row
**         Col             - Col
**       * Str             - String
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_PrintAt(uint32_t Row, uint32_t Col, char *Str)
{
    uint32_t i=0;

    CsIO1_MoveTo(Row, Col);
    while (Str[i] != 0) {
        CsIO1_PutChar(Str[i++]);
    }
    CsIO1_MoveTo(RdRow, RdCol + RdLn_BuffIndex);
}

/*
** ===================================================================
**     Method      :  CsIO1_GetErrorMessage (component ConsoleIO)
**
**     Description :
**         Reterns error message
**     Parameters  :
**         NAME            - DESCRIPTION
**         ErrorCode       - Error code
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
char * CsIO1_GetErrorMessage(uint32_t ErrorCode)
{
    if (ErrorCode <= ERR_QFULL) {
        return (ErrorMsgTable[ErrorCode]);
    } else if ((ErrorCode >= ERR_PARAM_MASK) & (ErrorCode <= ERR_PARAM_TICKS)) {
        return (ErrorParamMsgTable[ErrorCode-0x80]);
    } else {
        return "Unknown error code";
    }
}

/*
** ===================================================================
**     Method      :  CsIO1_PrintMcuInfo (component ConsoleIO)
**
**     Description :
**         PrintMcuInfo
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void CsIO1_PrintMcuInfo(uint16_t ResetSource)
{
	/*
    printf("*****************************************\n\r");
    printf("MCU:                 %s\n\r",FamilyName[(SIM_SDID >> 4) & 0x07u]);
    printf("Revision ID:         0x%02X\n\r",(SIM_SDID >> 12) & 0x0F);
    printf("Pin count:           %s\n\r",PinCount[(SIM_SDID >> 0) & 0x0Fu]);
    printf("RAM:                 %s\n\r",RamSize[(SIM_SOPT1 >> 12) & 0x0Fu]);
    printf("DFLASH:              %s\n\r",DFlashSize[(SIM_FCFG1 >> 28) & 0x0Fu]);
    printf("PFLASH:              %s\n\r",PFlashSize[(SIM_FCFG1 >> 24) & 0x0Fu]);
    printf("EEprom:              %s\n\r",EEpromSize[(SIM_FCFG1 >> 16) & 0x0Fu]);
*/
#ifdef Cpu_OnReset_EVENT_ENABLED
    printf("Reset src.(0x%04X): ",ResetSource);
    if (ResetSource & RSTSRC_WAKEUP) {
        printf(" LLWU module wakeup reset\n\r");
    }
    if (ResetSource & RSTSRC_LVD) {
        printf(" Low-voltage detect reset\n\r");
    }
    if (ResetSource & RSTSRC_LOC) {
        printf(" Loss-of-clock reset\n\r");
    }
    if (ResetSource & RSTSRC_COP) {
        printf(" Watchdog reset\n\r");
    }
    if (ResetSource & RSTSRC_PIN) {
        printf(" External pin reset\n\r");
    }
    if (ResetSource & RSTSRC_POR) {
        printf(" Power-on reset\n\r");
    }
    if (ResetSource & RSTSRC_JTAG) {
        printf(" JTAG pin reset\n\r");
    }
    if (ResetSource & RSTSRC_LOCKUP) {
        printf(" Core Lock-up reset\n\r");
    }
    if (ResetSource & RSTSRC_SW) {
        printf(" Software reset\n\r");
    }
#else
    (void)ResetSource;
    printf("Reset src            undef - OnReset event is disabled");
#endif
    printf("*****************************************\n\r");
}
/* END CsIO1. */
/*
** ###################################################################
**
**     This file was created by Processor Expert 0.00.00 [05.01]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
